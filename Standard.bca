//
// Descrizione logica di funzionamento automatismo lavorazione travi     16/10/2012
//
// 05.06.08 v4.3C1 AV Prima versione ( riportate le funzione da file BCF)
// 13.06.08 v4.3C2 AV Gestione completa di Suprema(carico a sinistra) e PMT
// 26.09.08 v4.4B5 AV Gestione fori con "ribasso", usando la stessa procedura dei centrini.
// 07.10.08 v4.4B6 DS Se angolo lama >= 85deg si annullano affond. e Zsband in SetParamBlade.
// 18.12.08 v4.4B7 AV Prima gestione rinvio da sotto per fori e ribassi
// 05.03.09 v4.5A1 AV Possibilità scelta strategia per lavorazioni di lama e mortasatrice. ( Con lama ora è possibile rimanere nella geometria)
// 14.04.09 v4.5A2 AV Nuova gestione ribassi
// 08.05.09 v4.5B1 AV Prima versione scelta frese. In TEST.
// 11.09.09 v4.5B2 AV Migliorata gestione rinvio da sotto con scelta frese da lista
// 24.11.09 v4.5B3 AV Prima versione gestione tagli a "cubetti"
// 19.02.10 v4.5B4 AV Nuova gestione per scelta "soluzione opposta".
// 30.03.10 v4.6A3 AV Gestione nuovo metodo calcolo lavorazioni ( tolta la parte ON_ROTATE)
// 04.10.10 v4.6A4 AV Gestione nuova lavorazione ( incastro a pettine) per Heko Spanten
// 14.10.10 v4.6B1 AV Gestione nuova lavorazione per ribassi classe 142 grandi, sfinestratura con lama più mortasatrice negli spigoli
// 18.02.11 v4.6B2 AV Corretta gestione tagli longitudinali parziali con partenza da testa o coda.( se centrali funzionava già correttamente)
// 04.04.11 v4.6B3 AV Per taglio a cubetti: se numero shell più del valore massimo faccio lavorazione tipo sfinestratura. Solo se senza carrelli.
// 12.09.11 v4.6D4 AV Gestione contornature con modifica degli attacchi e uscite.
//                 AV Nuova gestione migliorata per Tagli longitudinali, classe 300.
// 02.11.11 v4.6D5 AV Gestione soluzione opposta se  "C_bHeadFromSide"
//                 AV Gestione lama grande con assi bloccati se  "C_bHeadFromSide"
// 03.02.12 v4.8A1 VS Modifiche varie per macchina Hage.
// 20.03.12 v4.8C1 AV Prima versione gestione macchine per pareti
// 16.10.12 v4.8J1 DS In sheet, se ottimizza rapidi lama tutti i tagli hanno la stessa priorità.
// 05.12.12 v4.8K1 AV Divisione automatismo in BCF-travi e BCF-pareti.
// 29.07.14 v6.1A1 AV Prima versione gestione scelta lame
// 29.11.18 v6.5K3 MA Aggiunta gestione per ottimizzazione lavorazioni e lavorazioni in doppio
// 21.05.19 v6.6E1 MA Aggiunto flag per forzatura rotazione Flip
// 05.03.20 v6.7C1 AV Rimossa vecchia gestione lavorazioni in doppio
// 05.03.20 v6.7C1 AV Aggiunta nuova sezione BEG_INSKIT in ON_FEATURE per gestione speciale cliente
// 15.03.21 v6.8B5 DV Aggiunta possibilità di tenere entrata/uscita come kit se lavorati sheet
//
// ------------------- FUNZIONI PER DEBUG ----------------

   procedure OutDebugVar( num nDeb)
   {
      string  sOut ;

     // separatore
      OUTDEB( nDeb, "--->") ;
     // dati di trave
      sOut = "$$NaB=$NaB $$L=$L $$W=$W $$T=$T $$CutR=$CutR $$CutL=$CutL $$Hp=$Hp $$Mp=$Mp" ;
      OUTDEB( nDeb, sOut) ;
     // dati generali di feature
      sOut = "$$NaF=$NaF $$CaF=$CaF $$Nf=$Nf $$Nh=$Nh $$Nc=$Nc $$F=$F $$S=$S $$Nsf=($Nsf)" ;
      if ( ISSETVAR( $P01)) then
         sOut = sOut + " $$P01=$P01" ;
      if ( ISSETVAR( $P02)) then
         sOut = sOut + " $$P02=$P02" ;
      if ( ISSETVAR( $P03)) then
         sOut = sOut + " $$P03=$P03" ;
      if ( ISSETVAR( $P04)) then
         sOut = sOut + " $$P04=$P04" ;
      if ( ISSETVAR( $P05)) then
         sOut = sOut + " $$P05=$P05" ;
      if ( ISSETVAR( $P06)) then
         sOut = sOut + " $$P06=$P06" ;
      if ( ISSETVAR( $P07)) then
         sOut = sOut + " $$P07=$P07" ;
      if ( ISSETVAR( $P08)) then
         sOut = sOut + " $$P08=$P08" ;
      if ( ISSETVAR( $P09)) then
         sOut = sOut + " $$P09=$P09" ;
      if ( ISSETVAR( $P10)) then
         sOut = sOut + " $$P10=$P10" ;
      if ( ISSETVAR( $P11)) then
         sOut = sOut + " $$P11=$P11" ;
      if ( ISSETVAR( $P12)) then
         sOut = sOut + " $$P12=$P12" ;
      if ( ISSETVAR( $P13)) then
         sOut = sOut + " $$P13=$P13" ;
      if ( ISSETVAR( $P14)) then
         sOut = sOut + " $$P14=$P14" ;
      if ( ISSETVAR( $P15)) then
         sOut = sOut + " $$P15=$P15" ;
      if ( ISSETVAR( $Q01)) then
         sOut = sOut + " $$Q01=$Q01" ;
      OUTDEB( nDeb, sOut) ;
     // dati ausiliari di feature
      sOut = "" ;
      if ( ISSETVAR( $ProcQuality)) then
         sOut = sOut + "$$ProcQuality=$ProcQuality" ;
      if ( ISSETVAR( $Mir)) then
         sOut = sOut + " $$Mir=$Mir" ;
      OUTDEB( nDeb, sOut) ;
     // dati speciali di feature
      sOut = "$$Np=$Np $$Eh=$Eh $$Ev=$Ev $$Pmin=$Pmin $$Pmax=$Pmax $$Cl=$Cl $$C2=$C2 " ;
      if ( ISSETVAR( $El)) then
         sOut = sOut + "$$El=$El " ;
      if ( ISSETVAR( $Ew)) then
         sOut = sOut + "$$Ew=$Ew " ;
      if ( ISSETVAR( $Er)) then
         sOut = sOut + "$$Er=$Er " ;
      if ( ISSETVAR( $Al)) then
         sOut = sOut + "$$Al=$Al " ;
      if ( ISSETVAR( $Av)) then
         sOut = sOut + "$$Av=$Av " ;
      if ( ISSETVAR( $As)) then
         sOut = sOut + "$$As=$As " ;
      if ( ISSETVAR( $Dt)) then
         sOut = sOut + "$$Dt=$Dt " ;
      OUTDEB( nDeb, sOut) ;
      sOut = "" ;
      if ( ISSETVAR( $E1h)) then
         sOut = sOut + "$$E1h=$E1h " ;
      if ( ISSETVAR( $E1v)) then
         sOut = sOut + "$$E1v=$E1v " ;
      if ( ISSETVAR( $E1r)) then
         sOut = sOut + "$$E1r=$E1r " ;
      if ( ISSETVAR( $N1)) then
         sOut = sOut + "$$N1=$N1 " ;
      if ( ISSETVAR( $E2h)) then
         sOut = sOut + "$$E2h=$E2h " ;
      if ( ISSETVAR( $E2v)) then
         sOut = sOut + "$$E2v=$E2v " ;
      if ( ISSETVAR( $E2r)) then
         sOut = sOut + "$$E2r=$E2r " ;
      if ( ISSETVAR( $N2)) then
         sOut = sOut + "$$N2=$N2 " ;
      if ( ISSETVAR( $Hi)) then
         sOut = sOut + "$$Hi=$Hi " ;
      if ( ISSETVAR( $Ho)) then
         sOut = sOut + "$$Ho=$Ho " ;
      if ( ISSETVAR( $Hdi)) then
         sOut = sOut + "$$Hdi=$Hdi " ;
      if ( ISSETVAR( $Hdo)) then
         sOut = sOut + "$$Hdo=$Hdo " ;
      if ( ISSETVAR( $Hsi)) then
         sOut = sOut + "$$Hsi=$Hsi " ;
      if ( ISSETVAR( $Hso)) then
         sOut = sOut + "$$Hso=$Hso " ;
      if ( sOut != "") then
         OUTDEB( nDeb, sOut) ;
   }


// ------------- FUNZIONI PER MESSAGGI DI REPORT -------------
   procedure OutputReport( num nTypeMess, string sOutMessage)
   {
      num    nLenghtNameBeam ;
      string sPhaseBeam ;

      if ( ISSETVAR( $NaB)) then {
         nLenghtNameBeam = STRLEN( $NaB) ;
         if ( nLenghtNameBeam < 2) then
            sPhaseBeam = "_N" ;
         else
            sPhaseBeam = STRMID( $NaB, nLenghtNameBeam - 1, nLenghtNameBeam) ;
         if ( sPhaseBeam != "_R"  AND  sPhaseBeam != "_S"  AND  sPhaseBeam != "_T") then
            sPhaseBeam = "_N" ;
      }

      sOutMessage = OUTSTR( sOutMessage) ;
      OUTREPORT( nTypeMess, "{sPhase}: {sPhaseBeam} - {sOutMessage}") ;

      if ( nTypeMess == _BcfErr  OR  nTypeMess == _BcfWarnErr) then {
         nMachPossible = 0 ;
         nVotoFeature = 0 ;
      }
      elsif ( nTypeMess == _BcfWarn) then
         nMachPossible = 1 ;
   }


// ------------------- FUNZIONI PER ROTAZIONI ----------------

   procedure SetRotFlag( num nFlag)
   {
      nRotFlag = nFlag ;

      if ( bMachineWithCarr) then {
        // gestione pezzi piccoli
         if ( nBeamType != BEAM_STD  AND  nBeamType != BEAM_ON_VAC) then {
            if ( ( nPosXFeat < nReferenceDistance AND $McLeftLoad) OR ( nPosXFeat >= ( $L - nReferenceDistance) AND NOT( $McLeftLoad))) then {
              // taglio o intestature in coda
               if ( $CaF < 2000 OR ( $CaF >= 3100 AND $CaF <= 3250)) then {
                  if ( nFlag != _Tcut) then
                     nRotFlag = _Last ;
               }
              // mortasatura o ribasso in coda
               elsif ( bIsTail) then
                  nRotFlag = _Last ;
              // foro in coda
               elsif ( $CL > 500 AND $CL < 600) then {
                  if ( ( $HI == _Left AND $McLeftLoad) OR ( $HI == _Right  AND  NOT( $McLeftLoad))) then
                     nRotFlag = _Last ;
               }
            }
         }
      }
      else {
         if ( nRotFlag != _Hcut  AND  nRotFlag != _Tcut) then
            nRotFlag = _Std ;
      }
   }

// --------------- FUNZIONI PER VOTO LAVORAZIONI ----------------

   procedure SetVotoFeatureRibasso( vec3 v3DirRibasso)
   {
      if ( bVeryShortBeam) then {
        // se sono sulla faccia sopra e non sul bordo posso lavorare
         if ( ( $Pmax.y < $W  AND  $Pmin.y > 0  AND $Pmax.x < $L  AND  $Pmin.x > 0) AND v3DirRibasso.z > 0) then
            nVotoFeature = 2 ;
         elsif ( v3DirRibasso.z < 0  OR  ABS( v3DirRibasso.y) > 0.15) then {
            if ( v3DirRibasso.x > 0.95  OR  v3DirRibasso.z < -0.95) then
               nVotoFeature = 2 ;
            else
               nVotoFeature = 0 ;
         }
      }
      elsif ( bShortBeam) then {
         if ( $Pmax.x > C_nDistHeadFeat  AND  $Pmin.x < ( $L - C_nDistHeadFeat)) then {
           // se sono sul fianco
            if ( $Pmax.y == $W  OR  $Pmin.y == 0) then {
               if ( v3DirRibasso.z < 0  OR  ABS( v3DirRibasso.y) > 0.15) then
                  nVotoFeature = 0 ;
            }
         }
      }
      if ( bVeryShortBeam  OR  bShortBeam) then {
        // se verso l'alto
         if ( ABS( v3DirRibasso.z) > ABS( v3DirRibasso.y)) then {
            if ( ( $Pmax.x > C_nDistHeadFeat  AND  $Pmin.x < ( $L - C_nDistHeadFeat)) AND ( $Pmin.y < 1  OR  $Pmax.y > ( $W - 1))) then {
               if ( $Pmin.z < ( C_nAltezzaMorseO + C_nSicurezza)  AND  NOT( C_bTableForWall)) then {
                  if ( bLongFeat) then
                     nVotoFeature = 0 ;
                  else
                     nVotoFeature = 1 ;
               }
            }
         }
        // se lavorazione su fianco
         if ( ( ABS( v3DirRibasso.z) < ABS( v3DirRibasso.y)  OR  v3DirRibasso.z < 0  OR  bLongFeat)
               AND  v3DirRibasso.z < 0.985   AND  ABS( v3DirRibasso.y) > 0.1) then {
            if ( bMachineWithCarr  AND  bLongFeat  AND $Pmin.z < ( C_nAltezzaMorseO + C_nSicurezza)) then {
              // se è sulla parte frontale e posso lavorarlo tenendo solo con le morse verticali, dico che posso lavorare
               if ( $Pmax.y < ( $W - 80)  AND  $Pmin.z > 10) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = 0 ;
            }
            else {
               if ( bMachineWithCarr  AND  $Pmin.z < ( C_nAltezzaMorseO + C_nSicurezza)  AND  NOT bLongFeat) then
                  nVotoFeature = MAX( nVotoFeature - 1, 1) ;
               elsif ( bMachineWithCarr  AND  bLongFeat) then
                  nVotoFeature = 1 ;
            }
         }
        // se verso il basso
         elsif ( v3DirRibasso.z < 0) then {
           // se non trovo l'utensile non posso lavorare
            if ( $CL != 142) then {
               if ( nToolIndex != 0) then {
                  if ( NOT C_bHeadFromSide  AND  C_vnTTypeUse[nToolIndex] != 2) then
                     nVotoFeature = 0 ;
                  elsif ( bLongFeat) then
                     nVotoFeature = 1 ;
                  else
                     nVotoFeature = MAX( nVotoFeature - 2, 1) ;
               }
               else {
                  if ( NOT C_bHeadFromSide) then
                     nVotoFeature = 0 ;
               }
            }
         }
      }

     // se con carrelli controllo che sia sopra le morse orizzontali
      if ( bMachineWithCarr) then {
        // se la lavorazione è lungo tutta la trave oppure se è su un'estremità
         if ( nLengthFeat >= (( $L / 3) *2)  OR  ( nLengthFeat > $L / 2 AND ( $Pmin.x == 0  OR  $Pmax.x == $L))) then {
           // se feature spezzata
            if ( bSplit) then {
              // se la feature occupa tutta la faccia ed è nella parte posteriore, proibisco comunque
               if ( $Pmin.z < 2  AND  $Pmax.z > $T-2  AND  $Pmax.y == $W) then
                  nVotoFeature = 0 ;
            }
           // se non spezzo
            else {
               if ( $CL == 121) then {
                 // controllo se posso effettivamente lavorare in questa posizione
                  if ( $Pmax.z == $T) then
                     nVotoFeature = 5 ;
                  else
                     nVotoFeature = 2 ;
                  if ( $Pmax.y == $W) then {
                     if ( $Pmax.z == $T AND ( $Pmin.z < ( $T/2) OR  $Pmin.z < 30)) then
                        nVotoFeature = 0 ;
                     elsif ( $Pmin.z == 0 AND ( ( $T - $Pmax.z) < 20  OR  $Pmax.z > 80)) then
                        nVotoFeature = 0 ;
                     elsif ( $Pmin.z == 0 AND $Pmin.y < ($W-50)) then
                        nVotoFeature = 0 ;
                  }
                  // se è su faccia anteriore
                  elsif ( $Pmin.y == 0) then {
                     if ( $Pmin.z == 0) then {
                        if ( $L <= C_nLenVeryShortBeam  AND  ( $T-$Pmax.z) < 100) then {
                           nManageFlip = 1 ;
                           nVotoFeature = 0 ;
                        }
                        elsif ( $Pmax.y > $W/2) then
                           nVotoFeature = 0 ;
                     }
                  }
               }
               elsif ( $CL == 141  OR  $CL == 132  OR $CL == 151) then {
                 // se verso l'alto e contro le battute provo a fare flip per portare lavorazione sul fronte
                  if ( $Np.z == 1 AND $Pmax.y > $W-30  AND nLengthFeat > $L / 2) then {
                     nManageFlip = 1 ;
                  }
               }
               elsif ( $N1.z < 0.707  OR  $N2.z < 0.707) then {
                 // se nonostante non sia rivolto verso l'alto sono comunque sopra le morse lavoro comunque
                  if ( $Pmin.z < ( C_nAltezzaMorseO + C_nSicurezza)  AND  $W-$Pmax.y < 110) then
                     nVotoFeature = 0 ;
               }
            }
         }
      }
   }

   procedure SetVotoFeatureIncastro( num nTipoLavorazione)
   {
      if ( nTipoLavorazione == _TaglioSopra) then {
        // se taglio concavo
         if ( $CL == 421 OR $CL == 422) then {
            if ( ( $N1.z < 0  AND $N2.z < 0.866)  OR ( $N2.z < 0  AND $N1.z < 0.866)) then
               nVotoFeature = 0 ;
            else
               nVotoFeature = 5 ;
         }
         else
            nVotoFeature = 5 ;
      }
      elsif ( nTipoLavorazione == _SvuotaFresa) then {
         if ( bVeryShortBeam) then {
            if ( $N1.z >= 0  AND  ABS( $N1.y) < 0.15) then
               nVotoFeature = 4 ;
            else
               nVotoFeature = 0 ;
         }
         elsif ( bShortBeam) then {
            if ( nPosXFeat < C_nDistHeadInca  OR  nPosXFeat > ( $L - C_nDistHeadInca)) then
               nVotoFeature = 3 ;
            else {
               if ( $N1.z >= 0  AND  ABS( $N1.y) < 0.15) then
                  nVotoFeature = 4 ;
               else
                  nVotoFeature = 0 ;
            }
         }
         else {
            if ( $N1.z > ABS( $N1.y)) then
               nVotoFeature = 5 ;
            else {
               if ( $N1.z >= 0) then
                  nVotoFeature = 4 ;
               elsif ( C_bHeadFromSide) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = 0 ;
            }
         }
      }
      elsif ( nTipoLavorazione == _TaglioFianco) then {
         if ( bVeryShortBeam) then
            nVotoFeature = 0 ;
         elsif ( bShortBeam) then {
            if ( nPosXFeat < C_nDistHeadInca  OR  nPosXFeat > ( $L - C_nDistHeadInca)) then
               nVotoFeature = 1 ;
            else
               nVotoFeature = 0 ;
         }
         else
            nVotoFeature = 3 ;
      }
      elsif ( nTipoLavorazione == _ContFresa) then {
         nVotoFeature = 2 ;
      }
      elsif ( nTipoLavorazione == _TaglioCubetti) then {
         if ( bShortBeam) then
            nVotoFeature = 0 ;
         else {
            if ( $Np.z > 0) then
               nVotoFeature = 2 ;
            elsif ( $Np.z == 0) then
               nVotoFeature = 1 ;
            else
               nVotoFeature = 0 ;
         }
      }
   }

   procedure SetVotoFeatureTaglioLama( num nTipoTaglio, vec3 v3NormCut)
   {
     // forzo che sto facendo comunque un taglio a cubetti
      if ( bCutCubetti) then
         nTipoTaglio = _TaglioCubetti ;

      if ( nTipoTaglio == _TaglioSopra) then {
        // se trave molto piccola
         if ( bVeryShortBeam ) then {
           // se feature lunga
            if ( nLengthFeat > C_nLenLongFeatSmallPiece) then {
               if ( nBeamType == BEAM_SMALL) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = 0 ;
            }
           // se feature non lunga devo comunque cercare di privilegiare la lavorazione dal sopra e non di fianco
            else {
               if ( ABS( v3NormCut.z) > ABS( v3NormCut.y)) then {
                  if ( v3NormCut.z >= 0) then
                     nVotoFeature = 3 ;
                  else
                     nVotoFeature = 2 ;
               }
               else
                  nVotoFeature = 1 ;
            }
         }
         elsif ( bShortBeam  AND  nLengthFeat > C_nLenLongFeatSmallPiece) then
            nVotoFeature = 2 ;
         else {
           // se taglio di lama controllo normale
            if ( ( $CL > 400  AND  $CL < 500)  AND  ABS( v3NormCut.z) < 0.05  AND  ( nLengthFeat > C_nLenLongFeat  AND  $NF == 1)) then {
              // se ho i carrelli ma posso usare un sottopezzo, permetto taglio longitudinale
               if ( bMachineWithCarr  AND  C_bCanUseSubPiece) then
                  nVotoFeature = 2 ;
               elsif ( C_bTableForWall) then
                  nVotoFeature = 2 ;
               else
                  nVotoFeature = 0 ;
            }
            else {
               if ( bMustExecuteCubetti) then
                  nVotoFeature = 1 ;
               else {
                  if ( bSplitRowPart) then
                     nVotoFeature = 2 ;
                  else {
                     if ( bLongFeat) then
                        nVotoFeature = 3 ;
                     else
                        nVotoFeature = 5 ;
                  }
               }
            }
         }
        // cerco di privilegiare se possibile la lavorazione del pezzo da sdraiato
         if ( $W > $T) then
            nVotoFeature = nVotoFeature + 1 ;
      }
      elsif ( nTipoTaglio == _TaglioFianco) then {
         if ( bVeryShortBeam) then {
            if ( ABS( v3NormCut.y) > 0.15) then
               nVotoFeature = 0 ;
            else {
               if ( v3NormCut.z >= 0) then
                  nVotoFeature = 2 ;
               else
                  nVotoFeature = 0 ;
            }
         }
         elsif ( bShortBeam) then {
            if ( ABS( v3NormCut.y) >= 0.5) then
               nVotoFeature = 0 ;
            else {
               if ( v3NormCut.z >= 0) then {
                  if ( ABS( v3NormCut.y) > 0.15) then
                     nVotoFeature = 2 ;
                  else
                     nVotoFeature = 3 ;
               }
               else {
                  if ( v3NormCut.z <= -0.5) then
                     nVotoFeature = 1 ;
                  else
                     nVotoFeature = 0 ;
               }
            }
         }
         else {
            if ( v3NormCut.z >= 0) then
               nVotoFeature = 4 ;
            else {
               if ( bLongFeat) then {
                  if ( $CL == 411) then
                     nVotoFeature = 0 ;
                  else
                     nVotoFeature = 1 ;
               }
               else {
                 // se da sotto e di fianco, deve essere praticamente trasversale
                  if ( $CL == 411  AND ABS( v3NormCut.y) > 0.09) then
                     nVotoFeature = 0 ;
                  elsif ( bMustExecuteCubetti) then
                     nVotoFeature = 1 ;
                  else
                     nVotoFeature = 3 ;
               }
            }
         }
      }
      elsif ( nTipoTaglio == _TaglioCubetti) then {
         if ( bMachineWithCarr  AND  NOT( C_bTableForWall)) then {
            if ( nLengthFeat > ( $L / 2)  AND  C_nExecuteCubetti != 5  AND  ( NOT( C_bCanUseSubPiece)  OR  ABS( v3NormCut.z) < 0.966)) then {
               if ( $Pmin.z < C_nAltezzaMorseO + 10) then
                  nVotoFeature = 0 ;
               else
                  nVotoFeature = 1 ;
            }
            elsif ( bLongFeat  AND  ABS( v3NormCut.z) > ABS( v3NormCut.y)) then
               nVotoFeature = 3 ;
            elsif ( NOT( bLongFeat)  AND  ABS( v3NormCut.z) > ABS( v3NormCut.y)) then
               nVotoFeature = 2 ;
            elsif ( ABS( v3NormCut.y) < 0.05) then
               nVotoFeature = 3 ;
            elsif ( ABS( v3NormCut.z) < 0.05  AND  NOT( bLongFeat)) then
               nVotoFeature = 3 ;
            elsif ( NOT( bShortBeam)) then {
               if ( ABS( v3NormCut.z) < 0.05  AND  nLengthFeat > C_nLenLongFeat) then {
                  if ( ( nLengthFeat < ( $L / 2)  AND  C_bCanUseSubPiece)  OR  C_nExecuteCubetti == 5  OR  nLengthFeat < C_nMaxLenDimCube) then
                     nVotoFeature = 2 ;
                  else
                     nVotoFeature = 0 ;
               }
               else
                  nVotoFeature = 2 ;
            }
            else {
              // se voglio fare sempre cubetti do un minimo voto perchè potrebbe poi essere lavorato con un taglio di lama semplice
               if ( C_nExecuteCubetti == 5) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = 0 ;
            }
         }
         else
            nVotoFeature = 3 ;
      }
      elsif ( nTipoTaglio == _TaglioSvuota) then {
         nVotoFeature = 1 ;
      }
   }

   procedure SetVotoFeatureTaglioLong()
   {
     // setto il voto
      if ( bMachineWithCarr) then {
         if ( $Pmin.z < C_nAltezzaMorseO  AND  NOT( bSplit)) then {
            if ( C_bCanUseSubPiece  OR  NOT bLongFeat) then {
               if ( $CL > 330) then {
                  if ( $F == 1) then
                     nVotoFeature = 0 ;
                  elsif ( $F == 3) then
                     nVotoFeature = 3 ;
                  else
                     nVotoFeature = 1 ;
               }
               else {
                  if ( $N1.z < 0) then {
                     if ( ( $Pmax.y - $Pmin.y) > ( $W / 3)) then
                        nVotoFeature = 0 ;
                     else
                        nVotoFeature = 1 ;
                  }
                  else
                     nVotoFeature = 1 ;
               }
            }
           // se convesso posso farlo solo su faccia sopra
            elsif ( $AS < 180 AND $AS > 0 AND $F != 3) then {
               nVotoFeature = 0 ;
            }
            elsif ( C_bCarrTurn  AND  $CL > 300 AND  $CL < 330  AND  $Np.y < 0.35  AND  $Pmin.z > 30) then {
               if ( $W-$Pmax.y > 120) then
                  nVotoFeature = 5 ;
               else
                  nVotoFeature = 1 ;
            }
            elsif ( C_bCarrTurn  AND  $CL > 300 AND  $CL < 330 AND $Np.y <= 0) then {
               if ( $Np.z < 0) then {
                  if ( ( $Pmax.y - $Pmin.y) > ( $W / 3)) then
                     nVotoFeature = 0 ;
                  else {
                     if ( $W > 320) then
                        nVotoFeature = 1 ;
                     else {
                        nVotoFeature = 1 ;
                       // faccio finta non sia completo
                        nMachPossible = 1 ;
                     }
                  }
               }
               else
                  nVotoFeature = 3 ;
            }
            elsif ( C_bCarrTurn  AND  ISSETVAR( $N2)) then {
               if ( $F == 4  AND  $W > 320) then
                  nVotoFeature = 1 ;
               elsif ( $CL > 330  AND  ( $F == 1  OR  $F == 2)) then
                  nVotoFeature = 0 ;
               else {
                  nVotoFeature = 1 ;
                 // faccio finta non sia completo
                  nMachPossible = 1 ;
               }
            }
            else {
               nVotoFeature = 0 ;
               // se occupa tutta la faccia posteriore non posso lavorare (altrimenti non ho più appoggi), quindi forzo rotazione pezzo
               if ( $Pmin.z < 5 AND $Pmax.z > $T-5 AND $N1.y > 0) then {
                 // se il taglio è esattamente come fosse la faccia retro, allora non serve fare flip
                  if ( $N1.z > 0 AND ( $N1.z != 0 OR $Pmin.y != $W OR $Pmax.y != $W)) then
                     nManageFlip = 1 ;
                  nMachPossible = 0 ;
               }
            }
         }
         else {
            nVotoFeature = 3 ;
           // se la posizione della lavorazione impedisce pinzaggio corretto
            if ( $Np.z < 0) then {
               if ( $Pmax.y > $W-50  OR  $Pmax.y > $W/2) then
                  nVotoFeature = 0 ;
               elsif ( $Np.y < 0  AND  $Pmax.z > ($T - 5)  AND  $W < 100) then {
                  nManageFlip = 1 ;
                  nMachPossible = 0 ;
               }
            }
            elsif ( $Np.z > 0) then {
               if ( $Np.y > 0  AND  $Pmin.z < 10 ) then {
                  nManageFlip = 1 ;
                  nMachPossible = 0 ;
               }
            }
           // do una priorità più alta per mettere la feature più lontano dalle morse
            elsif ( ( $Pmin.z > $Pmin.y  AND  $Pmax.y == $W)  OR   ( $Pmin.z > ( $W - $pmax.y)  AND  $Pmin.y == 0)) then
               nVotoFeature = 5 ;
           // se taglio longitudinale che rimuove tutta la parte di appoggio non posso lavorare
            elsif ( $CL > 300 AND $CL < 330  AND  $Np.y > 0) then {
               nVotoFeature = 0 ;
            }
            else
               nVotoFeature = 3 ;
         }
      }
      elsif ( C_bTableForWall) then {
        // se doppio taglio
         if ( $CL > 330) then {
            if ( $F == 3) then
               nVotoFeature = 3 ;
            elsif ( $F == 2  OR  $F == 4) then
               nVotoFeature = 1 ;
            else
               nVotoFeature = 0 ;
         }
        // se taglio singolo
         else {
            if ( $N1.z > 0) then
               nVotoFeature = 3 ;
            elsif ( $N1.z == 0) then
               nVotoFeature = 2 ;
            else
               nVotoFeature = 1 ;
         }
      }
      else
         nVotoFeature = 3 ;
   }

// ------------------- FUNZIONI GENERALI --------------------------
   procedure GetIndexHoleCont()
   {
      num nIndex ;
      num nMinimumDiamHole ;
      num nTotHole ;
      num nI ;

      if ( C_bExecuteCenteringHole) then {
         nTotHole = GETHOLESINFO( &nMinimumDiamHole) ;
         if ( nTotHole > 0) then {
            nNumberCentering = 0 ;
            nI = 1 ;
            while ( C_vDiamFre[nI] != 0) {
               if ( C_vDiamFre[nI] <= nMinimumDiamHole) then {
                  if ( C_vDiamFre[nI + 1] <= nMinimumDiamHole  AND  C_vDiamFre[nI + 1] != 0) then
                     nNumberCentering = nI + 1 ;
                  else
                     nNumberCentering = nI ;
               }
               nI = nI + 1 ;
            }
         }
      }

      if ( nNumberCentering == 0) then
         nNumberCentering = 1 ;
   }

   procedure ExecPockOnFace( string sFace, num nTypeFeat)
   {
      vec3 v3NormF ;

      bToolFind = FindTool( nTypeFeat, nNormal, 1, sFace, sFace, _TypeTMach_Rib, _nForceToolToUse) ;
      if ( bToolFind) then {
         sKit = C_sPrefSvuot + sToolKit ;
         GETFACENORMAL( sFace, &v3NormF) ;
         CalculateHeadSolution( v3NormF) ;
         InsertKit( sKit, sFace, nPosXFeat, nPri) ;
      }
   }

   procedure ExecContOnFace( string sFace, string sFace2, num nTypeFeat)
   {
      bToolFind = FindTool( nTypeFeat, nProfil, 1, sFace, sFace2, _TypeTMach_Rib, _nForceToolToUse) ;
      if ( bToolFind) then {
         sKit = C_sPrefCont + sToolKit ;
         SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
         SETKITDIR( _Nord) ;
         VerifyAndSetStep( sKit, 0, FALSE) ;
         SETKITDEPTH( 2) ;
         InsertKit( sKit, sFace + "," + sFace2, nPosXFeat, nPri) ;
      }
   }

// --------------------- FUNZIONI BEAM ----------------------------
// --------------------- FUNZIONI WALL ----------------------------

   function NumToStringBit( num nNum, num nForceLen) : STRING
   {
      num    nCalcAppo ;
      string sBits ;

     // init
      sBits = "" ;

     // divisioni successive
      while( nNum > 0) {
         nCalcAppo = floor( nNum / 2) ;
         if (( nNum - nCalcAppo * 2) == 1) then
            sBits = "1" + sBits ;
         else
            sBits = "0" + sBits ;
         nNum = nCalcAppo ;
      }
     // forzo lunghezza
      while( STRLEN( sBits) < nForceLen)
         sBits = "0" + sBits ;
     // risultato
      return sBits ;
   }

   function VerifySpecialCommand( string sNameSpecialCommand) : BOOL
   {
      num nI = 1 ;

      while ( nI < 6) {
         if ( C_vsNameSpecial[nI] == sNameSpecialCommand) then
            return C_vbEnableSpecial[nI] ;
         nI = nI + 1 ;
      }
     // per default lo speciale si esegue
      return TRUE ;
   }

   procedure SetLeadInOutCont( bool bForce, num nTypeIn, num nTypeOut, string & sNameKitToModify)
   {
      bool bEnlargeLead = FALSE ;

     // se sono sullo sheet e non è un foro
      if ( $IsSheet  AND  NOT( $CL > 500  AND  $CL < 600)  AND NOT( bForce)) then {
         nTypeIn = C_nSheetLeadInType ;
         nTypeOut = C_nSheetLeadInType ;
      }

     // se il diametro non è settato lo rileggo
      if ( nToolDiam == 0) then
         GETKITDATA( sNameKitToModify, _ToolDiam, 0, &nToolDiam) ;

     // eventuali considerazioni speciali
      if ( ( $CaF >= 3100  AND  $CaF <= 3106)  OR  $Caf == 3250) then
         bEnlargeLead = TRUE ;

     // sistemo il collegamento sull'entrata della lavorazione
      if ( nTypeIn == _Clg_Lineare) then {
         SETKITLEADINTYPE( _LioLinear) ;
         if ( $IsSheet) then {
            SETKITLEADINTANG( nToolDiam / 2) ;
            SETKITLEADINLENC( 0.1) ;
         }
         else {
            SETKITLEADINTANG( ( nToolDiam / 2) + 6) ;
            SETKITLEADINLENC( 3) ;
         }
         SETKITLEADINPERP( 0) ;
         nTypeLeadMach = 1 ;
      }
      elsif ( nTypeIn == _Clg_AntiScheggia) then {
         SETKITLEADINTYPE( _LioTangent) ;
         SETKITLEADINTANG( 1) ;
         SETKITLEADINPERP( -1) ;
         SETKITLEADINLENC( 10) ;
         nTypeLeadMach = 2 ;
      }
      elsif ( nTypeIn == _Clg_Perpendicolare) then {
         SETKITLEADINTYPE( _LioPerp) ;
         SETKITLEADINTANG( 0) ;
         nTypeLeadMach = 3 ;
      }
      elsif ( nTypeIn == _Clg_Tangente) then {
         SETKITLEADINTYPE( _LioTangent) ;
         if ( bEnlargeLead) then
            SETKITLEADINTANG( nToolDiam) ;
         else
            SETKITLEADINTANG( nToolDiam / 1.5) ;
         SETKITLEADINPERP( ( nToolDiam / 2) / 5) ;
         SETKITLEADINLENC( 5) ;
         nTypeLeadMach = 4 ;
      }
      elsif ( nTypeIn == _Clg_Nessuno) then {
         SETKITLEADINTYPE( _LioNone) ;
         SETKITLEADINLENC( 0.1) ;
         nTypeLeadMach = 5 ;
      }
      elsif ( nTypeIn == _Clg_Kit) then{
        //non necessario perché prende i valori del kit
         nTypeLeadMach = 6 ;
      }

     // sistemo il collegamento sull'uscita della lavorazione
      if ( nTypeOut == _Clg_Lineare) then {
         SETKITLEADOUTTYPE( _LioLinear) ;
         if ( $IsSheet) then {
            SETKITLEADOUTTANG( nToolDiam / 2) ;
            SETKITLEADOUTLENC( 0.1) ;
         }
         else {
            SETKITLEADOUTTANG( ( nToolDiam / 2) + 6) ;
            SETKITLEADOUTLENC( 3) ;
         }
         SETKITLEADOUTPERP( 0) ;
      }
      elsif ( nTypeOut == _Clg_AntiScheggia) then {
         SETKITLEADOUTTYPE( _LioTangent) ;
      }
      elsif ( nTypeOut == _Clg_Perpendicolare) then {
         SETKITLEADOUTTYPE( _LioPerp) ;
         SETKITLEADOUTTANG( 0) ;
      }
      elsif ( nTypeOut == _Clg_Tangente) then {
         SETKITLEADOUTTYPE( _LioTangent) ;
         if ( bEnlargeLead) then
            SETKITLEADOUTTANG( nToolDiam) ;
         else
            SETKITLEADOUTTANG( nToolDiam / 1.5) ;
         SETKITLEADOUTPERP( ( nToolDiam / 2) / 5) ;
         SETKITLEADOUTLENC( 0.1) ;
      }
      elsif ( nTypeOut == _Clg_Nessuno) then {
         SETKITLEADOUTTYPE( _LioNone) ;
         SETKITLEADOUTLENC( 0.1) ;
      }
      elsif ( nTypeOut == _Clg_Kit) then{
       //non necessario perché prende i valori del kit
      }
   }

   function FindMaxDepthMill( string sNomeUte) : NUM
   {
      num nTotLengthTool ;
      num nThickTool ;
      num nToolHLen ;
      num nToolHDiam ;
      num nTotDiamTool ;
      num nTypeTool ;

      if ( NOT( GETTOOLHOLDER( sNomeUte, &nToolHDiam, &nToolHLen))) then {
         nToolHDiam = 60 ;
         nToolHLen = 70 ;
      }
      if ( GETTOOLDATA( sNomeUte, _ToolLen, &nTotLengthTool) AND GETTOOLDATA( sNomeUte, _ToolDiam, &nTotDiamTool)) then {
        // recuperto tipo utensile
         GETTOOLDATA( sNomeUte, _ToolType, &nTypeTool) ;
        // se utensile lama devo aggiungere anche lo spessore dell'utensile
         if ( nTypeTool == _TtBlade) then {
            GETTOOLDATA( sNomeUte, _ToolThick, &nThickTool) ;
            nTotLengthTool = nTotLengthTool + nThickTool ;
         }

        // salvo il diametro dell'utensile
         nToolDiam = nTotDiamTool ;
         if ( nTotDiamTool > nToolHDiam) then {
            nToolHLen = 0 ;
            return ( nTotLengthTool - C_nSicurezza) ;
         }
         else
            return ( nTotLengthTool - nToolHLen - C_nSicurezza) ;
      }
      else
         return -1 ;
   }

  // recupera i dati utensile e ritorna, in caso di fresa se utensile compatibile con materiale
   function GetToolParam( string sSearchName) : BOOL
   {
      bool bMaterial = TRUE ;
      bool bFound = FALSE ;
      num nTLen ;
      num nI ;

     // cerco nell'elenco delle frese
      nI = 1 ;
      while ( C_vsNomeUte[nI] != ""  AND  nI <= 15) {
         if ( C_vsNomeUte[nI] == sSearchName) then {
            nToolIndex = nI ;
            GETTOOLHOLDER( C_vsNomeUte[nToolIndex], &nTHDiam, &nTHLen) ;
            GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolLen, &nTLen) ;
            GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolDiam, &nToolDiam) ;
            GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolPos, &nToolPos) ;

            if ( nToolDiam > ( nTHDiam + 1)) then
               nToolLen = nTLen - C_nSicurezza ;
            else
               nToolLen = nTLen - nTHLen - C_nSicurezza ;
            nPri = nPri + C_vnAddPriMach[nToolIndex] ;

            if ( sMaterial != C_vsMaterial[nI]  AND  sMaterial != ""  AND  C_vsMaterial[nI] != "") then
               bMaterial = FALSE ;
            bFound = TRUE ;
         }
         nI = nI + 1 ;
      }

     // se non ho trovato cerco il nome direttamente
      if ( NOT( bFound)) then {
         GETTOOLHOLDER( sSearchName, &nTHDiam, &nTHLen) ;
         GETTOOLDATA( sSearchName, _ToolLen, &nTLen) ;
         GETTOOLDATA( sSearchName, _ToolDiam, &nToolDiam) ;

         if ( nToolDiam > ( nTHDiam + 1)) then
            nToolLen = nTLen - C_nSicurezza ;
         else
            nToolLen = nTLen - nTHLen - C_nSicurezza ;
      }

      return bMaterial ;
   }

  // BIT: 1-BlockHaus, 2-Tenoni, 3-Tasche, 4-CodaRondine, 5-TagliLongitudinali, 6-Profili
   function VerifyTypeTMach( num nTypeReq, num nTypeT) : BOOL
   {
      num    nMaxToolType = 8 ;
      string nStringBit ;

      nStringBit = NumToStringBit( nTypeT, nMaxToolType) ;

     // se BlockHaus
      if ( nTypeReq == _TypeTMach_BH   AND  STRMID( nStringBit, 8, 1) == "1") then
         return TRUE ;
     // se tenone
      elsif ( nTypeReq == _TypeTMach_Ten   AND  STRMID( nStringBit, 7, 1) == "1") then
         return TRUE ;
     // se tasche
      elsif ( nTypeReq == _TypeTMach_Rib   AND  STRMID( nStringBit, 6, 1) == "1") then
         return TRUE ;
     // se coda di rondine
      elsif ( nTypeReq == _TypeTMach_CR   AND  STRMID( nStringBit, 5, 1) == "1") then
         return TRUE ;
     // se taglio longitudinale
      elsif ( nTypeReq == _TypeTMach_LCut   AND  STRMID( nStringBit, 4, 1) == "1") then
         return TRUE ;
     // se profilature
      elsif ( nTypeReq == _TypeTMach_Prof   AND  STRMID( nStringBit, 3, 1) == "1") then
         return TRUE ;
      else
         return FALSE ;

   }

   function FindMaxMatBlade( string sBladeName) : NUM
   {
      num nTempMaxMatBlade ;
      num nBDiam ;

      GETTOOLDATA( sBladeName, _ToolDiam, &nBDiam) ;
      GETTOOLDATA( sBladeName, _ToolMaxMat, &nTempMaxMatBlade) ;
     // se non è settato il massimo materiale lo calcolo in base al porta-utensile
      if ( nTempMaxMatBlade == 0) then {
         GETTOOLHOLDER( sBladeName, &nTHDiam, &nTHLen) ;
         nTempMaxMatBlade = ( nBDiam / 2) - ( nTHDiam/2) - C_nSicurezza ;
      }
      if ( $T > 430) then {
         nTempMaxMatBlade = nTempMaxMatBlade - 30 ;
      }
      return nTempMaxMatBlade ;
   }


  // Funzione scelta lama
   function FindBlade( string sFacciaPrincipale, bool bNoFlange, bool bVertCut, num nAlt, num nHor, num nMaxThick, bool bForceMachComplete) : BOOL
   {
      bool bWorkOk ;
      bool bDataOK ;
      bool bFound = FALSE ;
      bool bOk ;
      num nI ;
      num nCycle ;
      num nMaxMatBlade ;
      num nBDiam ;
      num nAngleBlade ;
      num nIngFlangia ;
      num nLenIngFlangia ;
      num nLenIngDado ;
      num nRealMaxMat[15] = 0 ;
      num nToolMaxMat = 0 ;
      num nAppoWid ;
      string sAppoFaceNormal = "" ;

      if ( sFacciaPrincipale != "") then {
        // se ci sono più facce, prendo sempre la prima. Il calcolo della normale con più facce non funziona.
         sAppoFaceNormal = sFacciaPrincipale ;
         sAppoFaceNormal = GetFirstFaceInList( &sAppoFaceNormal) ;
         GETFACENORMAL( sAppoFaceNormal, &v3Appo) ;
      }
      else
         v3Appo = VEC3( 0, 0, 1) ;

     // se spessore zero vuol dire che non devo controllarlo, posso usare lo spessore che voglio
      if ( nMaxThick <= 0) then
         nMaxThick = 999 ;

      nCycle = 1 ;
      while ( NOT( bFound)  AND  nCycle <= 2) {
        // resetto valori ingombro calcolati in cicli precedenti
         nLenIngDado = 0 ;
         nLenIngFlangia = 0 ;
         nI = 1 ;
        // controllo lama utilizzabile
         while ( C_vsNomeUteBlade[nI] != "") {
            bDataOK = GETTOOLDATA( C_vsNomeUteBlade[nI], _ToolDiam, &nBDiam)  AND  GETKITDATA( C_vsNomeKitBlade[nI], _ToolThick, 0, &nBladeThick) ;

            if ( NOT( bDataOK)  OR  C_vnPriUseBlade[nI] <= 0) then
               C_vbBUsable[nI] = FALSE ;
            elsif ( sMaterial != ""  AND  C_vsMaterialBlade[nI] != sMaterial  AND  C_vsMaterialBlade[nI] != "") then
               C_vbBUsable[nI] = FALSE ;
            elsif ( COMPARE( ABS( v3Appo.z), 0, 1e-6) != 0  AND  C_vnTTypeUseBlade[nI] == 2) then
               C_vbBUsable[nI] = FALSE ;
            elsif ( bNoFlange  AND  C_vbFlangia[nI]) then
               C_vbBUsable[nI] = FALSE ;
            elsif ( nCycle == 1  AND  (( $T > C_vnMaxBladeDepth[nI]  AND  C_vnMaxBladeDepth[nI] > 0)  OR  ( $T < C_vnMinBladeDepth[nI]  AND  C_vnMinBladeDepth[nI] > 0))) then
               C_vbBUsable[nI] = FALSE ;
            elsif ( nBladeThick > nMaxThick) then
               C_vbBUsable[nI] = FALSE ;
            else {
              // se taglio dal sopra e non è taglio longitudinale
               if ( bVertCut) then {
                  GETTOOLHOLDER( C_vsNomeUteBlade[nI], &nTHDiam, &nTHLen) ;
                 // se porta-utensile non definito, metto un valore di default
                  if ( nTHDiam == 0) then
                     nTHDiam = C_nDiamMotore + C_nSicurezza ;

                  nAngleBlade = ASIN( v3Appo.z) ;
                  if ( ABS( nAngleBlade) != 90) then {
                    // gestione speciale per tagli longitudinali. Verifico se devo controllare anche l'ingombro flangia o se sono all'esterno
                     nAppoWid = (  ABS(SIN( nAngleBlade)) * FindMaxMatBlade( C_vsNomeUteBlade[nI])) ;
                     if ( $CL > 300  AND  $CL < 400  AND  nAppoWid > $W) then {
                        nLenIngFlangia = nTHDiam / 2 ;
                     }
                     else {
                       // se ho la flangia
                        if ( C_vbFlangia[nI]) then {
                           nLenIngFlangia =  ABS( TAN( nAngleBlade) * ( 15.8 + C_nSicurezza)) + nTHDiam / 2 ;
                           if ( v3Appo.z > 0) then
                              nLenIngDado = ABS ( TAN( nAngleBlade) * ( 60.8 + C_nSicurezza)) + 38 ;
                        }
                       // se non ho la flangia controllo solo di essere in sicurezza
                        else {
                           nLenIngFlangia =  ABS( TAN( nAngleBlade) * ( C_nSicurezza)) + nTHDiam / 2 ;
                        }
                     }
                  }
                  else
                     nLenIngFlangia = nTHDiam / 2 ;

                  if ( nLenIngFlangia < nLenIngDado) then
                     nLenIngFlangia = nLenIngDado ;
                 // salvo in array apposito
                  nRealMaxMat[nI] = ( ( nBDiam / 2) - nLenIngFlangia) ;

                 // controllo con ingombro motore
                  bOk = GETTOOLDATA( C_vsNomeUteBlade[nI], _ToolMaxMat, &nToolMaxMat) ;
                  nRealMaxMat[nI] = MIN ( nRealMaxMat[nI], nToolMaxMat) ;
                  
                  if ( $T > 430) then {
                     nRealMaxMat[nI] = nRealMaxMat[nI] - 30 ;
                  }

                  if ( nAlt > nRealMaxMat[nI]  AND  bForceMachComplete) then
                     C_vbBUsable[nI] = FALSE ;
               }
              // se taglio di fianco
               else {
                  nRealMaxMat[nI] = FindMaxMatBlade( C_vsNomeUteBlade[nI]) ;
                  
                  if ( nHor > ( nRealMaxMat[nI] * 2)  AND  bForceMachComplete) then
                     C_vbBUsable[nI] = FALSE ;
               }
            }
           // se l'utensile è utilizzabile dico che ne ho trovato almeno uno
            if ( C_vbBUsable[nI]) then
               bFound = TRUE ;
            nI = nI + 1 ;
         }

        // se no nho trovato niente al primo ciclo
         if ( NOT( bFound)  AND  nCycle == 1) then {
           // resetto il vettore
            nI = 1 ;
            while ( C_vsNomeUteBlade[nI] != "") {
               C_vbBUsable[nI] = TRUE ;
               nI = nI + 1 ;
            }
         }
         nCycle = nCycle + 1 ;
      }

     // scelgo la lama tra quelle disponibili
      nBladeIndex = 0 ;
      nI = 1 ;
      while ( C_vsNomeUteBlade[nI] != "") {
         if ( C_vbBUsable[nI]) then {
           // cerco lama con priorità più alta
            if ( nBladeIndex > 0) then {
               if ( C_vnPriUseBlade[nI] > C_vnPriUseBlade[nBladeIndex]) then
                  nBladeIndex = nI ;
            }
            else
               nBladeIndex = nI ;
         }
         nI = nI + 1 ;
      }

     // resetto il vettore
      nI = 1 ;
      while ( C_vsNomeUteBlade[nI] != "") {
         C_vbBUsable[nI] = TRUE ;
         nI = nI + 1 ;
      }

      if ( nBladeIndex > 0) then {
        // se non è stato settato prendo il massimo, altrimenti uso quello reale calcolato in base all'inclinazione
         if ( nRealMaxMat[nBladeIndex] == 0) then
            nBladeMaxMat = FindMaxMatBlade( C_vsNomeUteBlade[nBladeIndex]) ;
         else
            nBladeMaxMat = nRealMaxMat[nBladeIndex] ;
         GETTOOLDATA( C_vsNomeUteBlade[nBladeIndex], _ToolDiam, &nBladeDiam) ;
         GETTOOLDATA( C_vsNomeUteBlade[nBladeIndex], _ToolThick, &nBladeThick) ;
         return TRUE ;
      }
      else {
         nBladeMaxMat = 0 ;
         nBladeDiam = 0 ;
         nBladeThick = 0 ;
         return FALSE ;
      }
   }

  // TypeUse: 1 = utensile normale, 2 = utensile su rinvio da sotto
   function FindTool( num nRadOnFeat, num nTypeMach, num nTypeUse, string sFacciaPrincipale, string sFacciaSecondaria, num nTypeToolMach, num nForceToolParam) : BOOL
   {
      num nTDiamA ;
      num nTDiamB ;
      num nTLen ;
      num nI ;
      num nTLenUtile = 0 ;
      num nLenDimension ;
      num nWidDimension ;
      num nRiseDimension ;
      bool bDataOK ;

     // azzero un eventuale utensile precedente
      nToolIndex = 0 ;

     // gestione speciale per classe 142
      if ( $CL == 142  AND  NOT( bMultFace)) then {
        // QQQ se non è multifaccia ricalcolo i valori. Per il momento nessuna funzione riesce a darmi le dimensioni corrette della feature. Solo questa e in queta combinazione mi ritorna qualcosa di sensato. DA VERIFICARE
         GETFACEFACEANGLW( "F02", "F01", &nAng, &nRiseDimension, &nWidDimension) ;
         nLenDimension = $EW ;
         nWidDimension = $ER ;
      }
     // gestione speciale per classe 142
      elsif ( $CL == 141  AND  NOT( bMultFace)) then {
         GETFACEFACEANGLW( "F01", "F02", &nAng, &nLenDimension, &nWidDimension) ;
         nRiseDimension = $ER ;
      }
     // gestione speciale per taglio o taglio longitudinale
      elsif ( ( ( $CL > 400  AND  $CL < 499)  OR  ( $CL > 300  AND  $CL < 399))  AND  NOT( bMultFace)) then {
         nLenDimension = $EL ;
         nWidDimension = $ER ;
        // ci possono essere dei casi nei quali non calcola $ER
         if ( nWidDimension == 0) then
            GETFACEHVREXT( sFacciaPrincipale, &nEaH, &nWidDimension, &nEaR) ;
         nRiseDimension = $EW ;
      }
     // gestione speciale per forature descritte come superfici
      elsif ( $Cl == 511  OR  $CL == 512  OR  $Cl == 521  OR  $Cl == 531  OR  $Cl == 541) then {
         nLenDimension = $EL ;
         nWidDimension = $EW ;
         nRiseDimension = $ER ;
      }
     // lavorazioni standard, quando i dati son già stati calcolati nelle apposite variabili
      elsif ( ( nTypeMach == nStandard  OR  $CL == 128)  AND  NOT( bMultFace)) then {
         nLenDimension = $EL ;
         nWidDimension = $EW ;
         nRiseDimension = $ER ;
      }
     // lavorazione normali: la profondità è $ER
      elsif ( nTypeMach == nNormal) then {
         if ( sFacciaPrincipale != sFacciaSecondaria) then {
            GETFACEFACEANGLW( sFacciaPrincipale, sFacciaSecondaria, &nAng, &nLenDimension, &nWidDimension) ;
            GETFACEHVREXT( sFacciaPrincipale, &nEaH, &nEaV, &nRiseDimension) ;
         }
         else
            GETFACEHVREXT( sFacciaPrincipale, &nLenDimension, &nWidDimension, &nRiseDimension) ;
      }
     // lavorazione tipo i profili: la profondità è $EL
      elsif ( nTypeMach == nProfil) then {
         if ( sFacciaPrincipale != sFacciaSecondaria) then {
            GETFACEFACEANGLW( sFacciaPrincipale, sFacciaSecondaria, &nAng, &nRiseDimension, &nWidDimension) ;
            GETFACEHVREXT( sFacciaPrincipale, &nEaH, &nEaV, &nLenDimension) ;
            GETFACENORMAL( sFacciaPrincipale, &v3Appo) ;
           // se profilo arcuato prendo valori da estensioni verticali e orizzontali
            if ( $CaF == 3105) then {
               nRiseDimension = nEaV ;
               nWidDimension = nEaH ;
            }
         }
         else {
            GETFACEHVREXT( sFacciaPrincipale, &nWidDimension, &nRiseDimension, &nLenDimension) ;
            GETFACENORMAL( sFacciaPrincipale, &v3Appo) ;
         }
      }
     // lavorazione della faccia secondaria quando la faccia principale è verso il basso: la profondità è $EW
      elsif ( nTypeMach == nInvert) then {
         GETFACEFACEANGLW( sFacciaPrincipale, sFacciaSecondaria, &nAng, &nLenDimension, &nRiseDimension) ;
         GETFACEHVREXT( sFacciaPrincipale, &nEaH, &nEaV, &nWidDimension) ;
      }

     // se non sono riuscito a calcolare le dimensioni assegno quelle standard
      if ( nLenDimension == 0  OR  nWidDimension == 0  OR  nRiseDimension == 0) then {
         nLenDimension = $EL ;
         nWidDimension = $EW ;
         nRiseDimension = $ER ;
      }

      nI = 1 ;
     // Controllo le dimensioni degli utensili
      while ( C_vsNomeUte[nI] != "") {
         bDataOK = GETTOOLDATA( C_vsNomeUte[nI], _ToolDiam, &nTDiamA) ;
         if ( NOT( bDataOK)  OR  C_vnPriUse[nI] <= 0  OR  ( nTypeUse != C_vnTTypeUse[nI]  AND  NOT( C_bHeadFromSide))) then
            C_vbTUsable[nI] = FALSE ;
         elsif ( NOT( VerifyTypeTMach( nTypeToolMach, C_vnTypeMachUse[nI]))) then
            C_vbTUsable[nI] = FALSE ;
         elsif ( ( $T > C_vnMaxMillDepth[nI]  AND  C_vnMaxMillDepth[nI] > 0)  OR  ( $T < C_vnMinMillDepth[nI]  AND  C_vnMinMillDepth[nI] > 0)) then
            C_vbTUsable[nI] = FALSE ;
         elsif ( sMaterial != ""  AND  C_vsMaterial[nI] != sMaterial  AND  C_vsMaterial[nI] != "") then
            C_vbTUsable[nI] = FALSE ;
        // se non può lavorare di testa, su sheet non posso mai utilizzarlo
         elsif ( NOT( C_vbWorkByHead[nI])  AND  $IsSheet) then
            C_vbTUsable[nI] = FALSE ;
         else {
           // se non c'è problema cerco la fresa più grande in assoluto
            if ( nRadOnFeat == nOpenFeat) then {
              // per il momento se non ci sono problemi vanno bene tutti
              // poi si potrebbe controllare gli utensili di finitura ecc....
            }
           // se non c'è problema di raggio ma ci sono le superfici di contorno ( tipo classe 132)
            elsif ( nRadOnFeat == nCheckDiamFeat) {
               if ( nTDiamA > nWidDimension) then
                  C_vbTUsable[nI] = FALSE ;
               elsif ( $CL == 512) then {
                 // se non può lavorare di testa, non posso lavorare
                  if ( NOT( C_vbWorkByHead[nI])) then
                     C_vbTUsable[nI] = FALSE ;
               }
            }
           // se c'è il problema del raggio sulle tasche
            elsif ( nRadOnFeat == nRadiusFeat) then {
              // controllo che il raggio non sia maggiore del limite impostato in configurazione. La classe 142 ha una gestione speciale
               if ( nTypeToolMach == _TypeTMach_Prof) then {
                  if ( nTDiamA > ( C_nLimitRadiusProfile * 2)  AND  ( ( $Caf >= 3100  AND  $Caf <= 3106) OR $Caf <= 3250)) then
                     C_vbTUsable[nI] = FALSE ;
               }
               elsif ( nTDiamA > ( C_nLimitRadius * 2)  AND  $CL != 142) then
                  C_vbTUsable[nI] = FALSE ;
               elsif ( $CL == 128) then {
                  if ( $P04 == 4  AND  ( ( nTDiamA / 2) > $P10  AND  $P10 != 0)) then
                     C_vbTUsable[nI] = FALSE ;
                  else {
                    // se non può lavorare di testa, non posso lavorare
                     if ( NOT( C_vbWorkByHead[nI])) then
                        C_vbTUsable[nI] = FALSE ;
                    // se diametro come larghezza non posso lavorare ( dovrebbe entrare di testa nel pieno)
                     elsif ( nTDiamA > nLenDimension  OR  nTDiamA > nWidDimension) then
                        C_vbTUsable[nI] = FALSE ;
                  }
               }
               elsif ( $CL == 131) then {
                 // se devo fare la svuotatura controllo le dimensioni della tasca
                  if ( ( C_nExecuteRecessFinish == 1)  AND  ( nTDiamA > nLenDimension  AND  nTDiamA > ( nWidDimension / 2))) then
                     C_vbTUsable[nI] = FALSE ;
               }
               elsif ( $CL == 132) then {
                  if ( nTDiamA > nWidDimension) then
                     C_vbTUsable[nI] = FALSE ;
               }
               elsif ( nTDiamA > nLenDimension  AND  nTDiamA > nWidDimension  AND  nTypeMach != nProfil) then
                  C_vbTUsable[nI] = FALSE ;
               elsif ( $CL == 141) then {
                 if ( nTDiamA > nLenDimension  OR  nTDiamA > ( nWidDimension * 2)) then
                     C_vbTUsable[nI] = FALSE ;
               }
               elsif ( $CL == 142  OR  ( $CL > 150 AND $CL < 160)  OR  $CL == 128) then {
                 // se non può lavorare di testa, non posso lavorare
                  if ( NOT( C_vbWorkByHead[nI])) then
                     C_vbTUsable[nI] = FALSE ;
                 // se diametro come larghezza non posso lavorare ( dovrebbe entrare di testa nel pieno)
                  elsif ( nTDiamA > nLenDimension  OR  nTDiamA > nWidDimension) then
                     C_vbTUsable[nI] = FALSE ;
               }
            }
         }
         nI = nI + 1 ;
      }

     // cerco utensile più grande e con priorità più alta
      nToolIndex = 0 ;
      nI = 1 ;
      while ( C_vsNomeUte[nI] != "") {
         if ( C_vbTUsable[nI]) then {
            GETTOOLHOLDER( C_vsNomeUte[nI], &nTHDiam, &nTHLen) ;
            GETTOOLDATA( C_vsNomeUte[nI], _ToolLen, &nTLen) ;
            GETTOOLDATA( C_vsNomeUte[nI], _ToolDiam, &nTDiamA) ;
            if ( nTDiamA > nTHDiam) then
               nTLenUtile = nTLen - C_nSicurezza ;
            else
               nTLenUtile = nTLen - nTHLen - C_nSicurezza ;

           // se riesco a lavorare completamente
            if ( nTLenUtile >= nRiseDimension) then {
               
               if ( nToolIndex > 0) then {
                 // se pari priorità prendo quello più grande
                  if ( C_vnPriUse[nI] == C_vnPriUse[nToolIndex]  OR  nForceToolParam == nForceMaxRadius) then {
                     GETTOOLDATA( C_vsNomeUte[nI], _ToolDiam, &nTDiamA) ;
                     GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolDiam, &nTDiamB) ;
                    // se voglio utensile più grande
                     if ( nForceToolParam == nForceMaxRadius) then {
                       // se è molto più grande oppure se è leggermente più grande e ha la priorità più alta
                        if ( nTDiamA > ( nTDiamB + 10)  OR  ( (nTDiamA > nTDiamB) AND C_vnPriUse[nI] > ( C_vnPriUse[nToolIndex]+2))) then
                           nToolIndex = nI ;
                     }
                    // se stessa priorità prendo utensile con diametro più grande
                     elsif ( C_vnPriUse[nI] == C_vnPriUse[nToolIndex]) then {
                        if ( nTDiamA > nTDiamB  OR  bMachNotComplete) then
                           nToolIndex = nI ;
                     }
                  }
                 // prendo quello con priorità più alta oppure se lavorazione in precedenza non completa
                  elsif ( C_vnPriUse[nI] > C_vnPriUse[nToolIndex]  OR  bMachNotComplete) then
                     nToolIndex = nI ;

               }
               else
                  nToolIndex = nI ;

              // dichiaro lavorazione completa
               bMachNotComplete = FALSE ;
            }
           // se lavorazione non completa
            else {
              // se come profilo posso solamente se la faccia è orizzontale
               if ( ( nTypeMach != nProfil  OR  ABS( v3Appo.z) == 1)  OR  ( nTypeMach == nProfil  OR  ABS( v3Appo.z) == 0)) then {
                  if ( nToolIndex > 0) then {
                     GETTOOLHOLDER( C_vsNomeUte[nToolIndex], &nTHDiam, &nTHLen) ;
                     GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolLen, &nTLen) ;
                     GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolDiam, &nTDiamA) ;
                     if ( nTDiamA > nTHDiam) then
                        nTLenUtile = nTLen - C_nSicurezza ;
                     else
                        nTLenUtile = nTLen - nTHLen - C_nSicurezza ;

                     if ( nTLenUtile < nRiseDimension) then {
                       // prendo quello con priorità più alta
                        if ( C_vnPriUse[nI] > C_vnPriUse[nToolIndex]) then {
                           bMachNotComplete = TRUE ;
                           nToolIndex = nI ;
                        }
                       // se pari proprietà prendo quello più grande
                        elsif ( C_vnPriUse[nI] == C_vnPriUse[nToolIndex]) then {
                           GETTOOLDATA( C_vsNomeUte[nI], _ToolDiam, &nTDiamA) ;
                           GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolDiam, &nTDiamB) ;
                           if ( nTDiamA > nTDiamB) then {
                              bMachNotComplete = TRUE ;
                              nToolIndex = nI ;
                           }
                        }
                     }
                  }
                  else {
                     bMachNotComplete = TRUE ;
                     nToolIndex = nI ;
                  }
               }
            }
         }
         nI = nI + 1 ;
      }
     // resetto il vettore
      nI = 1 ;
      while ( C_vsNomeUte[nI] != "") {
         C_vbTUsable[nI] = TRUE ;
         nI = nI + 1 ;
      }

      if ( nToolIndex > 0) then {
         nToolLen = FindMaxDepthMill( C_vsNomeUte[nToolIndex]) ;
         sToolKit = C_vsNomeKit[nToolIndex] ;
         nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;

         return TRUE ;
      }
      else {
        // OutputReport( _BcfWarnErr, "Error Kit NOT FIND - ({$NaF})") ;
         return FALSE ;
      }
   }

   procedure SetParamMach()
   {

     // se è parziale o non completo abbasso priorità
      if ( nMachPossible != 2) then {
         nVotoFeature = 1 ;
      }

      OUTDEB( 4, _OrNoLav, "-> FEATURE={$NaF} : Ok={nMachPossible} Voto={nVotoFeature} Flag={nManagementFlag}") ;
     // se il carrello si ribalta devo cercare di fare tutte le feature il prima possibile
      if ( C_bCarrTurn  AND  nManagementFlag != _HCut  AND  nManagementFlag != _TCut  AND ( $CL < 300  OR  $CL > 399)) then {
         if ( nPosXFeat < 200  OR  nPosXFeat > $L-200  OR  NOT( bLongFeat)) then
            nManagementFlag = _Std ;
         else
            nManagementFlag = _First ;
      }

      nVotoFeature2 = MAX( nVotoFeature - 1, 0) ;
      if ( C_bCarrTurn) then {
         if ( bSplit  AND  nVotoFeature > 0) then
            nVotoFeature2 = 1 ;
         if ( ( $CL >= 300  AND  $CL <= 399)) then
            nVotoFeature2 = 0 ;
         elsif ( $CL == 141 AND nLengthFeat > $L / 2) then
            nVotoFeature2 = 0 ;
         elsif ( $CL == 132) then {
            if ( nLengthFeat > $L / 2  AND  NOT( bSplit)) then
               nVotoFeature2 = 0 ;
            elsif ( nLengthFeat > $L / 2 AND ( $N1.z < 0 OR  $N1.y < 0)) then
               nVotoFeature2 = 0 ;
         } 
         elsif ( $CL == 121 AND nLengthFeat > $L / 2  AND ( $Pmax.z == $T  AND  $Pmin.z < $T/2  AND  $Pmin.y == 0)) then
            nVotoFeature2 = 0 ;
         elsif ( $CaF == 1030 AND nLengthFeat > $L / 2) then
            nVotoFeature2 = 0 ;
        // se foro da fare doppio posso solo in posizione normale
         elsif ( $CL > 500  AND  $CL < 600  AND  bDoubleHoleDone) then
            nVotoFeature2 = 0 ;
         elsif ( nVotoFeature > 0) then
            nVotoFeature2 = MAX( 1, CEIL( nVotoFeature2 / 2)) ;
         elsif ( ( bHoleToTop  AND  nVotoFeature == 0  AND  ( $CL >= 500  AND  $CL <= 599)) AND C_nAntiBreakHoles != 1) then {
            nVotoFeature = 1 ;
            nVotoFeature2 = 0 ;
         }
         elsif ( nLengthFeat > $L/1.25) then
            nVotoFeature2 = 1 ;
      }

     // modifiche speciali per cliente ( nel caso si volesse agire su voto o flag lavorazione)
      CustomerSpecialManagement( _ON_END_FEAT) ;
      AddRotFea( nVotoFeature, nVotoFeature2, nMachPossible, nManagementFlag, nManageFlip) ;
   }

   procedure SetBeamCompIndex()
   {
      num nCompZ = 0 ;
      num nCompY = 0 ;

     // decido come compensare in base alle classi
      // ==========  CLASSE RIBASSO  ==============
      if ( $CL > 100  AND  $CL < 200) then {
         if ( $CL == 121  OR  $CL == 122) then {
            if ( $Pmax.z == $T) then {
               v3Appo = CROSS( $N1, $N2) ;
              // se feature frontale o posteriore
               if ( ABS( v3Appo.z) > ABS( v3Appo.y)) then {
                  if ( $Pmin.y == 0) then
                     nCompY = 1 ;
               }
               else
                  nCompZ = 1 ;
            }
         }
         elsif ( $CL == 132) then {
           // se rivolto maggiormente verso l'alto compenso in Z altrimenti in Y
            if ( $N1.z > ABS( $N1.y)) then
               nCompZ = 1 ;
            else {
               if ( $N1.y < 0) then
                  nCompY = 1 ;
            }
         }
         elsif ( $CL == 131  OR  $CL == 141) then {
            if ( $N1.z > ABS( $N1.y)) then
               nCompZ = 1 ;
            else {
               if ( $N1.y < 0) then
                  nCompY = 1 ;
            }
           // se la feature è nella parte bassa non compenso la Z
            if ( $Pmin.z == 0) then
               nCompZ = 0 ;
         }
         elsif ( $CL == 151) then {
            if ( $N1.z > ABS( $N1.y)) then
               nCompZ = 1 ;
            else {
               if ( $N1.y < 0) then
                  nCompY = 1 ;
            }
         }
      }
      // ==========  CLASSE INCASTRO  ==============
      elsif ( $CL > 200  AND  $CL < 300) then {
        // se faccia retro
         if ( $F == 2) then {
            if ( $Pmax.z < $T) then
               nCompZ = 1 ;
            else
               nCompZ = 2 ;
         }
        // se faccia sopra
         elsif ( $F == 3) then {
            nCompZ = 1 ;
            if ( $Pmin.y > 0) then
               nCompY = 2 ;
         }
        // se faccia fronte
         elsif ( $F == 4) then {
            nCompY = 1 ;
            if ( $Pmax.z < $T) then
               nCompZ = 1 ;
            else
               nCompZ = 2 ;
         }
      }
      // ==========  CLASSE TAGLIO LONGITUDINALE  ==============
      elsif ( $CL > 300  AND  $CL < 400) then {
        // se taglio longitudinale singolo
         if ( $CaF < 3010) then {
            if ( $N1.z > $N1.y  AND  $N1.z > 0) then
               nCompZ = 1 ;
            else
               nCompY = 1 ;
         }
        // se taglio longitudinale doppio
         else {
            if ( $F == 2) then {
               nCompZ = 2 ;
            }
            elsif ( $F == 3) then {
               nCompY = 2 ;
               nCompZ = 1 ;
            }
            elsif ( $F == 4) then {
               nCompY = 1 ;
               nCompZ = 2 ;
            }
         }
      }
      // ==========  CLASSE TAGLIO  ==============
      elsif ( $CL > 400  AND  $CL < 500) then {
        // se ho solo una faccia
         if ( $Nf == 1) then {
           // correzione Z
            if ( $N1.z > 0) then {
              // se taglio sopra allora correggo tutto
               if ( $Pmin.z > $T/2) then
                  nCompZ = 1 ;
              // se il taglio parte sotto la metà allora correggo solo per metà
               elsif ( $Pmin.z > 20) then
                  nCompZ = 2 ;
              // se il taglio parte da sotto allora non compenso
            }
           // correzione Y
            if ( $N1.y < 0) then {
              // se taglio frontale allora correggo tutto
               if ( $Pmax.y < $W/2) then
                  nCompY = 1 ;
              // se il taglio parte sotto la metà allora correggo solo per metà
               elsif ( $Pmax.y < $W-20) then
                  nCompY = 2 ;
              // se il taglio parte da dietro allora non compenso
            }
            elsif ( $N1.y > 0) then {
              // se taglio posteriore ma parte frontalmente allora correggo tutto
               if ( $Pmin.y < 20) then
                  nCompY = 1 ;
              // altrimenti non compenso mai
            }
         }
        // se ho due facce
         else {
           // compenso sempre della metà
           // se riferimento sopra compenso in Z
            if ( $F == 3) then
               nCompZ = 2 ;
           // se su faccia frontale compenso in Y
            if ( $F == 4) then
               nCompY = 2 ;
         }
      }
      // ==========  CLASSE FORO  ==============
      elsif ( $CL > 500  AND  $CL < 600) then {
        // se faccia dietro
         if ( $F == 2) then {
            if ( ( $Pmax.z + $Pmin.z) / 2 < $T/2) then
               nCompZ = 1 ;
            elsif ( ( $Pmax.z + $Pmin.z) / 2 == $T/2) then
               nCompZ = 2 ;
         }
        // se faccia sopra
         elsif ( $F == 3) then {
            nCompZ = 1 ;
            if ( ( $Pmax.y + $Pmin.y) / 2 < $W/2) then
               nCompY = 1 ;
            elsif ( ( $Pmax.y + $Pmin.y) / 2 == $W/2) then
               nCompY = 2 ;
         }
        // se faccia fronte
         elsif ( $F == 4) then {
            nCompY = 1 ;
            if ( ( $Pmax.z + $Pmin.z) / 2 > $T/2) then
               nCompZ = 1 ;
            elsif ( ( $Pmax.z + $Pmin.z) / 2 == $T/2) then
               nCompZ = 2 ;
         }
      }
      // ==========  CLASSE CONTORNO LIBERO  ==============
      elsif ( $CL > 600  AND  $CL < 700) then {
        // se riferimento sopra compenso in Y (la superficie è messa in verticale)
         if ( $F == 3) then
            nCompY = 2 ;
        // se riferimento fronte compenso in Z (la superficie è in orizzontale)
         if ( $F == 4) then
            nCompZ = 2 ;

      }
      // ==========  ALTRE FEATURE  ==============
      else {
        // se riferimento sopra
         if ( $F == 3) then
            nCompZ = 1 ;
        // se riferimento fronte
         if ( $F == 4) then
            nCompY = 1 ;
      }

      SETKITPARAM( 3, nCompY) ;
      SETKITPARAM( 4, nCompZ) ;
   }

   procedure InsertKit( string sNameKit, string sFace, num nPosition, num nPriority)
   {
      bool bInsert ;
      string sToolName ;

     // personalizzazione cliente
      CustomerSpecialManagement( _BEG_INSKIT) ;

     // se richiesto devo settare gli indici di compensazione dimensione trave
      if ( C_bManageComp) then
         SetBeamCompIndex() ;

     // devo metterlo in una variabile globale, altrimenti la funzione OutPutReport non conosce il valore
      sAppoNameKit = sNameKit ;
      sGlobFace = sFace ;
      nGlobPos = nPosition ;
      nGlobPri = nPriority ;

     // se si inverte
      if ( bSuffInvert) then {
         SETKITINVERT( bSuffInvert) ;
         bSuffInvert = FALSE ;
      }
     // se cambia la soluzione
      if ( bSuffSolOpp) then {
         SETKITFLIPSOLUTION( bSuffSolOpp) ;
         bSuffSolOpp = FALSE ;
      }
     // per fori: se utilizzare gestione speciale
      if ( bSuffSolSpeHole) then {
         sAppoNameKit = sAppoNameKit + C_sSuffSolSpeHole ;
         bSuffSolSpeHole = FALSE ;
      }
     // per contornature : se lavorazione perpendicolare rispetto alla superficie
      if ( bSuffWorkPerp) then {
         SETKITPERPENDICULAR( bSuffWorkPerp) ;
         bSuffWorkPerp = FALSE ;
      }
     // se richiesto blocco asse C a 180°
      if ( bSpecialSuff180) then {
        // controllo che sia un taglio di lama
         if ( GETKITTYPE( sAppoNameKit) == _KitCont) then {
            GETKITDATA( sAppoNameKit, _ToolName, 1, &sToolName) ;
            GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
            if ( nToolType == _TtBlade) then
               bAppo = SETKITFIXEDAXIS( "C1", 180) ;
         }
         bSpecialSuff180 = FALSE ;
      }
      if ( C_bMachiningOptimize) then
         SETKITMOVEABLE( TRUE) ;
     // se classe foro abilito minimizzazione dei rapidi
      elsif ( $CL == 501 AND C_bDrillOptimize) then
         SETKITMOVEABLE( TRUE) ;

      CustomerSpecialManagement( _BEFORE_INSKIT) ;
      bInsert = ADDKIT( sAppoNameKit, sGlobFace, nGlobPos, nGlobPri + nPriAdd) ;
      if ( NOT( bInsert)) then
         OutputReport( _BcfErr, "Error Name Kit :  {sAppoNameKit}") ;
      CustomerSpecialManagement( _AFTER_INSKIT) ;
   }


   procedure CheckDrill( num nDiamDrill, string sNameDrill, bool bShortHole)
   {
      num nType ;
      num nDiamTool ;

     // controllo se esiste il kit
      if ( GETKITDATA( sNameDrill, _ToolDiam, 0, &nDiamTool) AND sNameDrill != "") then {
         nType = GETKITTYPE( sNameDrill) ;
        // se non esiste il kit
         if ( nType == _KitNone) then
            OutputReport( _BcfErr, OUTSTR( "{sErrMissKit}: {sNameDrill}")) ;
        // se gestione kit di foratura
         elsif ( nDiamDrill > 0) then {
            if ( nType != _KitDrill  AND  nType != _KitMdrill) then {
               if ( ( nType != _KitCont AND nType != _KitPock) OR nDiamDrill <= nDiamTool) then
                  OutputReport( _BcfErr, OUTSTR( "{sErrTypeKit}: {sNameDrill}")) ;
            }
         }
        // se gestione kit contornatura/svuotatura
         else {
            if ( nType != _KitCont  AND  nType != _KitPock  AND  bShortHole) then
               OutputReport( _BcfWarn, OUTSTR( "{sErrTypeKit}: {sNameDrill}")) ;
         }
      }
   }

   function CheckPriSmallPiece( num nPriority) : NUM
   {
      if ( ISSETVAR( $Caf)  AND  ISSETVAR( $CL)) then {
         if ( bMachineWithCarr) then {
            if ( nBeamType == BEAM_STD  OR  nBeamType == BEAM_ON_VAC) then
               nPriority = nPriority + 10000 ;
            else {
              // se pezzo per caduta, faccio il taglio di separazione come ultimo
               if ( $L < 400  AND  nManagementFlag == _Tcut) then
                  return 5 ;
               elsif ( $CaF == 3010 OR $CaF == 3012) then
                  return nPriority ;
               elsif ( ( nPosXFeat < C_nDistHeadFeat AND $McLeftLoad) OR ( nPosXFeat >= ( $L - C_nDistHeadFeat) AND NOT( $McLeftLoad))) then {
                  if ( $CaF < 2000 OR ( $CaF >= 3100 AND $CaF <= 3250)) then  // taglio o intestature in coda
                     return nPriority ;
                  elsif ( bIsTail) then        // altre lavorazioni in coda
                     return nPriority ;
                  elsif ( $CL > 500 AND $CL < 600) then {   // foro in coda
                     if ( ( $HI == _Left AND $McLeftLoad) OR ( $HI == _Right AND NOT( $McLeftLoad))) then
                        return nPriority ;
                     else
                        nPriority = nPriority + 10000 ;
                  }
                 // dichiaro che il ribasso è in coda (verrà poi usato per calcolare la priorità delle lavorazioni)
                  elsif ( ( $PMax.x < C_nDistHeadFeat AND $McLeftLoad) OR ( $PMin.x >= ( $L - C_nDistHeadFeat) AND NOT( $McLeftLoad))) then
                     return nPriority ;
                  else
                     nPriority = nPriority + 10000 ;
               }
               else
                  nPriority = nPriority + 10000 ;
            }
            return nPriority ;
         }
        // senza carrelli non esiste la gestione dei pezzi piccoli
         else
            return nPriority ;
      }
     // se variabili non sono settate non calcolo niente e ritorno priorità passata
      else
         return nPriority ;
   }


   function GetFaceArea( string sFaceTempP, string sFaceTempS) : NUM
   {
      num nFaceArea ;

      GETFACEFACEANGLW( sFaceTempP, sFaceTempS, &nAng, &nLen, &nWid) ;
      nFaceArea = nLen * nWid ;

      return nFaceArea ;
   }

   procedure ExecuteBladeCont( string sNameFace, num nNeedNoFlange, num nDirection, bool bSideCont, bool bSetBladeOverMat, bool bLastPassage, string sNameFace2)
   {
      bool    bNeedCalcHeadSol = FALSE ;
      bool    bBladeFound ;
      num     nLenLead ;
      num     nWidLoc ;
      num     nLenLoc ;
      string  sNameBladeToolCut = "" ;
      string  sNameBladeToolCont = "" ;
      vec3    v3NormContCut ;

     // se non c'è settato il kit devo ricalcolare la soluzione
      if ( sKit == "") then
         bNeedCalcHeadSol = TRUE ;

     // QQQ VERIFICARE DIMENSIONI FACCIA PER CERCARE LAMA CORRETTA
      bBladeFound = FindBlade( sNameFace, OPT( nNeedNoFlange == 1, TRUE, FALSE), TRUE, 0, 0, 0, _bForceComplete) ;
      if ( NOT bBladeFound ) then {
         bError = TRUE ;
      }
      else {
         sKit = C_sPrefCont + C_vsNomeKitBlade[nBladeIndex] ;

        // ricacolo la soluzione della testa
         if ( bNeedCalcHeadSol) then {
            CalculateToolDir( sNameFace, sNameFace2) ;
         }
   
         if ( sKit != "") then {
           // lettura diametro lama
            GETKITDATA( sKit, _ToolDiam, 0, &nBladeDiam) ;
   
           // se sto facendo un taglio a cubetti la priorità deriva direttamente dai tagli di lama
            if ( bCutCubetti  OR  ( $CL > 400  AND  $CL < 500)) then {
               GETFACENORMAL( sNameFace, &v3NormContCut) ;
   
              // se sto utilizzando la lama 1 non abbasso la priorità
              // nPri = C_nPriBla + C_vnAddPriMachBlade[nBladeIndex] ;
   
               SetPriorityBlade( v3NormContCut, sNameFace) ;
            }
            else {
               if ( ( $CL == 132  OR  $CL == 232  OR  $Caf == 1030)  AND C_nExecuteRecessFinish == 3) then {
                 // priorità già calcolata
               }
               else
                  nPri = OPT( C_bExecRecessAsLastMach, 50, CheckPriSmallPiece( C_nPriBla)) ;
            }
   
           // recupero dimensioni faccia
            GETFACEFACEANGLW( sNameFace, sNameFace2, &nAng, &nLenLoc, &nWidLoc) ;
            if ( sNameFace == sNameFace2  AND  $CL != 411) then
               nLenLead = MAX( nLenLoc, nWidLoc) + 30 ;
            elsif ( $CL == 411  AND  sNameFace == sNameFace2) then
               nLenLead = $EV + 30 ;
            else
               nLenLead = nWidLoc + 30 ;
   
           // se lavorazioni di fianco
            if ( bSideCont) then {
               SETKITLEADINTYPE( _LioPath) ;
               SETKITLEADOUTTYPE( _LioPath) ;
               SETKITLEADINTANG( 5) ;
               SETKITLEADOUTTANG( 5) ;
               SETKITLEADINPERP( 0) ;
               SETKITLEADOUTPERP( 0) ;
               SETKITLEADINLENC( nLenLead) ;
               SETKITLEADOUTLENC( nLenLead) ;
               SETKITDIR( nDirection) ;
               if ( bSetBladeOverMat) then
                  SETKITOVERMAT( 3) ;
            }
           // se lavorazioni da sopra
            else {
               SETKITLEADINTYPE( _LioPath) ;
               SETKITLEADOUTTYPE( _LioPath) ;
               SETKITLEADINPERP( 0) ;
               SETKITLEADOUTPERP( 0) ;
               SETKITDIR( nDirection) ;
   
               if ( bLastPassage) then {
                  SETKITLEADINTANG( 5) ;
                  SETKITLEADOUTTANG( 5) ;
                  SETKITLEADINLENC( nLenLead) ;
                  SETKITLEADOUTLENC( nLenLead) ;
               }
               else {
                  if ( ABS( v3NormContCut.z) < 0.173) then {
                     SETKITLEADINTANG( ( nBladeDiam / 2) - 10) ;
                     SETKITLEADOUTTANG( ( nBladeDiam / 2) - 10) ;
                  }
                  else {
                     SETKITLEADINTANG( ( nBladeDiam / 2) + 10) ;
                     SETKITLEADOUTTANG( ( nBladeDiam / 2) + 10) ;
                  }
                  SETKITLEADINLENC( 5) ;
                  SETKITLEADOUTLENC( 5) ;
                  if ( bSetBladeOverMat) then
                     SETKITDEPTH( -2) ;
               }
            }
            SETKITRISE( 0) ;
            InsertKit( sKit, sNameFace, nPosXFeat, nPri) ;
            bError = FALSE ;
         }
         else {
            OutputReport( _BcfWarnErr, "{sError} {sCut}:1 {$NaF} {sNotExecute}") ;
            bError = TRUE ;
         }
      }
   }

// VALORI DI RITORNO : 0 = con fresa, 1 = lama che taglia fino al fondo + mortasatrice, 2 = lama solo in parte + mortasatrice
   function VerifyExecutionWindowMill( string sNameFace) : NUM
   {
      bool bBladeFound ;
      num nRiseExt = $ER ;
      num nHeightExt = $EH ;
      num nTypeMillWind ;

     // nel caso sia un doppio taglio devo verificare entrambe le facce
      if ( $CL > 400 AND $CL <= 499  AND  $NF == 2) then {
         nRiseExt = MAX( $ER, $E2R) ;
         nHeightExt = MAX( $EH, $E2H) ;
      }

      bBladeFound = FindBlade( sNameFace, FALSE, TRUE, nRiseExt, nHeightExt, 0, _bForceComplete) ;
      nTypeMillWind = -1 ;
      if ( ( C_nStrategyWindow == 1  OR  C_nStrategyWindow == 2) AND ( C_sSuffBladeWind != ""  OR  C_sSuffBladeOpenWind != "")  AND  bBladeFound) then {
         if ( ABS( $Np.z) == 1 AND $CL == 142 AND ( $EH > ( nBladeDiam / 3)  AND  $EV > ( nBladeDiam / 3))) then
            nTypeMillWind = 1 ;
         elsif ( $Np.z == 0 AND  $CL > 400  AND  $CL <= 499  AND ( nHeightExt > ( nBladeDiam / 3)  AND  nRiseExt > ( nBladeDiam / 3))) then
            nTypeMillWind = 1 ;
         elsif ( ( ( $CL == 121  AND  $Np.z == 0)  OR  ( $CL == 132  AND  $Np.z > 0.707))    AND ( nLengthFeat > C_nLenLongFeat)  AND  $EL > nBladeDiam  AND  $EW > nBladeDiam) then
            nTypeMillWind = 1 ;
      }
      elsif ( C_nStrategyWindow == 3  OR  C_nStrategyWindow == 4) then {
        // i controlli vengono fatti dopo
         nTypeMillWind = 0 ;
      }

      return nTypeMillWind ;
   }

   procedure AddCutWindow( string sNameBladeKit)
   {
      nVotoFeature = 1 ;
      SETKITDEPTH( MIN( 5, nBladeMaxMat - $T)) ;
      nPri = CheckPriSmallPiece( 50) ;
      InsertKit( sNameBladeKit, "F01,F02,F03,F04,F05,F06", nPosXFeat, nPri) ;
     // se è un taglio di lama dichiaro che è stato fatto completamente, altrimenti entrerebbe anche per l'eventuale seconda faccia
      if ( $CL > 400 AND $CL <= 499) then
         bCutComplete = TRUE ;
   }

   procedure AddWindowFinish()
   {
      num    nFaces ;
      num    nI = 1 ;
      num    nAngle ;
      num    nDeltaZ ;
      num    nLenRadiusBlade ;
      num    nRise ;
      num    nRaggioLama = nBladeDiam / 2 ;
      string sFace[6] ;

     // se devo lavorare solo con lama esco subito
      if ( C_nStrategyWindow == 1) then
         return ;

     // lavoro con mortasatrice solo se riesco a lavorare completamente
      if ( $T < ( nMaxMatMortaise - ( nLargMort / 2 + 5))   AND   nUseMillToWin != 0) then {

         nPri = CheckPriSmallPiece( 49) ;
         nFaces = GetCanonicFaces( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
         GETFACEFACEANGLW( sFace[1], "A01", &nAng, &nLen, &nWid) ;

        // Creo faccia perpendicolare
         if ( $CL == 142) then
            ADDAUXFACE( "A01", OPT( $Np.z > 0, $Np, -$Np), TRUE, 1, TRUE) ;
         elsif ( $Np.z == 0) then
            ADDAUXFACE( "A01", VEC3(0,0,1), TRUE, 1, TRUE) ;

         while ( nI <= nFaces) {
            GETFACEHVREXT( sFace[nI], &nLen, &nWid, &nRise) ;

           // controllo di tagliare completamente la faccia
            nAngle = ASIN( ( nLen / 2) / nRaggioLama) ;
            nDeltaZ = nRaggioLama * ( 1 - COS( nAngle)) - $T ;

           // se riesco a tagliare completamente, calcolo la lunghezza della lavorazione che deve eseguire la mortasatrice
            if ( nDeltaZ > 0) then {
               if ( $T > nBladeMaxMat) then
                  nUseMillToWin = 2 ;
               else
                  nUseMillToWin = 1 ;
            }
           // se non riesco a tagliare completamente
            else
              // Se lo spessore della trave è troppo per la lama o se la faccia è troppo piccola e non riesco ad arrivare sul fondo
                  nUseMillToWin = 2 ;

            if ( nUseMillToWin == 1) then {
               nLenRadiusBlade = CalcCornerBlade( TRUE, nBladeDiam) ;
            }
            elsif ( nUseMillToWin == 2) then {
               nLenRadiusBlade = ( nLen / 2) + ( nLargMort / 2) ;
            }

           // primo lato
            GETTOOLDIR( "A01", sFace[nI], &nToolDir, &v3ToolDir) ;
            SETKITDIR( nToolDir) ;
            SETKITLEADINTANG( nLenRadiusBlade - nLen) ;
            SETKITOVERMAT( -( nLargMort / 2 + 5)) ;
            bSuffWorkPerp = TRUE ;
            SETKITPERPENDICULAR( bSuffWorkPerp) ;
           // se entro nel pieno devo diminuire la velocità
           // QQQ MANCA FUNZIONE. Sarebbe utile leggere la feed impostata e modificare quella. NON mettere un nuovo parametro.
              // if ( nUseMillToWin == 2) then
              //    SETKITFEED ( nFeed / 3) ;
            InsertKit( C_sNameKitMortaise, "A01", nPosXFeat, nPri) ;
           // secondo lato
            SETKITFLIPSIDE( TRUE) ;
            SETKITDIR( nToolDir) ;
            SETKITLEADINTANG( nLenRadiusBlade - nLen) ;
            SETKITOVERMAT( -( nLargMort / 2 + 5)) ;
            bSuffWorkPerp = TRUE ;
            SETKITPERPENDICULAR( bSuffWorkPerp) ;
            InsertKit( C_sNameKitMortaise, "A01", nPosXFeat, nPri) ;
            nI = nI + 1 ;
         }
      }
      else
         OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
   }


   function CalcCornerBlade( bool bCalcLen, num nDiamUsedBlade) : NUM
   {
      num nAngle ;
      num nLenRadiusBlade ;

      nAngle = ASIN( ( ( nDiamUsedBlade / 2) - $T) / ( nDiamUsedBlade / 2)) ;
      nLenRadiusBlade = COS( nAngle) * ( nDiamUsedBlade / 2) ;

      if ( bCalcLen) then
         nLenRadiusBlade = MAX( nLenRadiusBlade, C_nSheetLimitLenBladeCut) ;

      return nLenRadiusBlade ;
   }


   procedure VerifyExecutionCubetti( bool bCheckVolume, string sFaccia1, vec3 v3AppoNormFaccia, bool bAllowCalcCubetti)
   {
      num nVolume ;

     // se sono già in taglio a cubetti non devo verificare nulla
      if ( NOT( bCutCubetti)  AND  bAllowCalcCubetti) then {

        // QQQ il calcolo del volume è provvisorio ed approssimativo. Serve funzione.
         GETFACEHVREXT( sFaccia1, &nEaH, &nEaV, &nEaR) ;
        // QQQQ  BISOGNA CONTROLLARE SE UNA ESTENSIONE E' PIU' DEL MAXMAT LAMA E DARE UNA PRIORITA' PIU' ALTA IN DECISIONE SE FARE CUBETTI
         nVolume = nEaH * nEaR * OPT( nEaV == 0, 1, nEaV) / 1000 ;

         if ( C_bTableForWall  OR  nLengthFeat > C_nMaxLenDimCube) then
            bExecuteCubetti = FALSE ;
         elsif ( bVeryShortBeam  OR ( bShortBeam  AND  $Pmax.x > C_nDistHeadFeat  AND  $Pmin.x < ( $L - C_nDistHeadFeat))) then
            bExecuteCubetti = FALSE ;
        // elsif ( nLengthFeat > ( $L / 2)  AND  ( bMachineWithCarr  AND  ( NOT( C_bCanUseSubPiece)  OR  ABS( v3AppoNormFaccia.z) < 0.966))  AND  C_nExecuteCubetti > 3) then
        //    bExecuteCubetti = FALSE ;
       //  elsif ( nEaH < nBladeMaxMat  AND  nEaV < nBladeMaxMat  AND  C_nExecuteCubetti > 3) then
        //    bExecuteCubetti = FALSE ;
      //   elsif ( nLengthFeat < C_nMaxLenDimCube  AND  nLengthFeat < $L) then
       //     bExecuteCubetti = FALSE ;
        // se non ho trovato lame vuol dire che la faccia è troppo grande per lavorarla normalmente
         elsif ( nBladeIndex == 0) then
            bExecuteCubetti = TRUE ;
        // non eseguire mai i cubetti
         elsif ( C_nExecuteCubetti == 1) then
            bExecuteCubetti = FALSE ;
        // se taglio di lama uso sempre lavorazione a cubetti a meno che non sia vietato
         elsif ( $CL > 400  AND  $CL < 500  AND  NOT bCheckVolume  AND  $Eh > nBladeMaxMat  AND  $Ew > nBladeMaxMat) then
            bExecuteCubetti = TRUE ;
        // gestione speciale Giunto Gerber
         elsif ( $CaF == 1070  AND  sFaccia1 == "F03") then
            bExecuteCubetti = FALSE ;
        // fare il minimo possibile
         elsif ( C_nExecuteCubetti == 2  AND( nVolume > 20000  OR  ( $ER > nToolLen AND bToolFind))) then
            bExecuteCubetti = TRUE ;
         // standard
         elsif ( C_nExecuteCubetti == 3  AND( nVolume > 5000  OR  ( $ER > nToolLen AND bToolFind))) then
            bExecuteCubetti = TRUE ;
        // massimo
         elsif ( C_nExecuteCubetti == 4  AND  nEaR > 10  AND  nVolume > 400  AND  nLengthFeat < $L) then
            bExecuteCubetti = TRUE ;
        // sempre
         elsif ( C_nExecuteCubetti == 5) then
            bExecuteCubetti = TRUE ;
         else
            bExecuteCubetti = FALSE ;

         if ( v3AppoNormFaccia.z < -0.02) then {
            bMustExecuteCubetti = bExecuteCubetti ;
            bExecuteCubetti = FALSE ;
         }
      }
   }

   procedure ExecuteCubetti( string sMainFace, string sSecondFace)
   {
      bool   bExeCubeCube ;
      bool   bSideCont ;
      bool   bExistSecFace ;
      bool   bSetOverMatFacePar ;
      bool   bRaw ;
      bool   bCubeOK ;
      bool   bSwitchFace = FALSE ;   // serve per capire quale è la faccia principale. Sulle facce perpendicolari ho un sovramateriale di 2mm
      bool   bLastPassageCube = FALSE ;
      num    nShell ;
      num    nI ;
      num    nJ ;
      num    nDirCube ;
      num    nDirCont ;
      num    nDirContLast ;
      num    nDimOrto ;
      num    nDimPara ;
      num    nAngleFace ;
      string sAppoMainFace ;
      string sOrto ;
      string sLastOrto ;
      string sPara ;
      string sAppoFakeFace ;
      vec3   v3FaceO ;
      vec3   v3FaceP ;
      vec3   v3AppoFace ;

      bExeCubeCube = FALSE ;
      bError = FALSE ;
      bWindowCut = FALSE ;
      bSetOverMatFacePar = FALSE ;

     // se supera la massima lunghezza consentita esco subito
      if ( nLengthFeat > C_nMaxLenDimCube) then {
         bError = TRUE ;
         return ;
      }

     // se taglio convesso processo una faccia per volta
      if ( $CL == 424 OR $CL == 425 OR $CL == 426 OR $CL == 427) then
         sSecondFace = sMainFace ;

     // mi salvo la normale della faccia principale
      GETFACENORMAL( sMainFace, &v3PriCube) ;
     // se esiste la faccia secondaria, ne calcolo la normale
      if ( sSecondFace != sMainFace  AND  sSecondFace != "")
         bExistSecFace = GETFACENORMAL( sSecondFace, &v3SecCube) ;
      else
         bExistSecFace = FALSE ;

      GETFACEHVREXT( sMainFace, &nEaH, &nEaV, &nEaR) ;

      bFirstShell = FALSE ;
     // trovo direzione creazione cubetti
     // se due facce
      if ( bExistSecFace) then {
        // recupero angolo tra le facce
         if ( NOT( ISSETVAR( $AS))) then {
            GETFACEFACEANGLW( sMainFace, sSecondFace, &nAngleFace) ;
         }
         else
            nAngleFace = $AS ;

        // recupero angolo tra le facce
         if ( NOT( ISSETVAR( $AS))) then {
            GETFACEFACEANGLW( sMainFace, sSecondFace, &nAngleFace) ;
         }
         else
            nAngleFace = $AS ;

        // se angolo tra le facce minore di 90° bisogna creare faccia perpendicolare a faccia principale
         if ( nAngleFace < 50) then {
            bError = TRUE ;
         }
         else {
           // se normale faccia principale orizzontale
            if ( v3PriCube.z == 0) then {
               if ( v3SecCube.z > 0 /* OR  ( ABS( v3SecCube.x) == 1 AND  nAngleFace < 90.5)*/) then {  // commentato perchè su scassi a L esattamente verticali questo controllo non funziona
                 // scambio il nome delle facce
                  sAppo = sSecondFace ;
                  sSecondFace = sMainFace ;
                  sMainFace = sAppo ;
                 // scambio le normali
                  v3Appo = v3SecCube ;
                  v3SecCube = v3PriCube ;
                  v3PriCube = v3Appo ;
                  GETFACEHVREXT( sMainFace, &nEaH, &nEaV, &nEaR) ;
                  bSwitchFace = TRUE ;
               }
              // devo controllare faccia secondaria
               if ( ABS( v3SecCube.z) == 1) then {
                  if ( v3SecCube.z > 0) then
                     nDirCube = _AdFromZp ;
                  else
                     nDirCube = _AdFromZm ;
               }
               elsif ( ABS( v3SecCube.x) > ABS( v3SecCube.y)  OR  ABS( v3PriCube.y) > 0.996) then {
                  if ( v3SecCube.x > 0) then
                     nDirCube = _AdFromXp ;
                  else
                     nDirCube = _AdFromXm ;
               }
               else {
                  if ( v3SecCube.y > 0) then
                     nDirCube = _AdFromYp ;
                  else
                     nDirCube = _AdFromYm ;
               }
              // impostazione parametri
               nDimOrto = C_nDimCutCubeOrtoSide ;
               nDimPara = C_nDimCutCubeParaSide ;
            }
            elsif ( v3PriCube.z == 1  OR  ( v3PriCube.z > 0  AND  v3SecCube.z == 0)) then {
              // scambio il nome delle facce
               if ( ( v3SecCube.z == 0  AND  v3SecCube.y != 0)  AND  nAngleFace < 90.5  AND  v3PriCube.z == 1) then {
                  sAppo = sSecondFace ;
                  sSecondFace = sMainFace ;
                  sMainFace = sAppo ;
                 // scambio le normali
                  v3Appo = v3SecCube ;
                  v3SecCube = v3PriCube ;
                  v3PriCube = v3Appo ;
                  GETFACEHVREXT( sMainFace, &nEaH, &nEaV, &nEaR) ;
                  bExeCubeCube = TRUE ;
                  bSwitchFace = TRUE ;
               }
              // devo controllare faccia secondaria
               if ( ABS( v3SecCube.x) > ABS( v3SecCube.z)  OR  v3PriCube.z > 0.707) then {
                 // se diretta più verso Y allora creo cubetti in Y, altrimenti in X
                  if ( ABS( v3SecCube.y) > ABS( v3SecCube.x)) then {
                     if ( v3SecCube.y > 0) then
                        nDirCube = _AdFromYp ;
                     else
                        nDirCube = _AdFromYm ;
                  }
                  else {
                     if ( v3SecCube.x > 0) then
                        nDirCube = _AdFromXp ;
                     else
                        nDirCube = _AdFromXm ;
                  }
               }
               else {
                  if ( ABS( v3SecCube.x) == ABS( v3SecCube.z)) then {
                     if ( v3SecCube.y > 0) then
                        nDirCube = _AdFromYp ;
                     else
                        nDirCube = _AdFromYm ;
                  }
                  else {
                     if ( v3SecCube.z > 0) then
                        nDirCube = _AdFromZp ;
                     else
                        nDirCube = _AdFromZm ;
                  }
               }
              // impostazione parametri
               nDimOrto = C_nDimCutCubeOrtoTop ;
               nDimPara = C_nDimCutCubeParaTop ;
            }
            elsif ( v3PriCube.z > 0  AND  v3SecCube.z > 0) then {
              // se rivolti verso l'alto e inclinati, generalmente non si riescono ad applicare i cubetti (per errore della funzione)
               v3Appo = CROSS( v3PriCube, v3SecCube) ;
               if ( v3Appo.z != 0) then {
                  nDirCube = 0 ;
               }
               else {
                  nDirCube = _AdFromZp ;
               // impostazione parametri
                  nDimOrto = C_nDimCutCubeOrtoTop ;
                  nDimPara = C_nDimCutCubeParaTop ;
               }
            }
            elsif ( ( v3PriCube.z > 0  AND  v3SecCube.z < 0)  OR  ( v3PriCube.z < 0  AND  v3SecCube.z > 0)) then {
               if ( ( v3PriCube.z > 0  AND  ABS( v3PriCube.z) > ABS( v3SecCube.z)) OR ( v3SecCube.z > 0  AND  ABS( v3SecCube.z) > ABS( v3PriCube.z))) then {
                  if ( v3PriCube.z > 0) then {
                     v3AppoFace = v3PriCube ;
                     sAppoMainFace = sMainFace ;
                  }
                  else {
                     v3AppoFace = v3SecCube ;
                     sAppoMainFace = sSecondFace ;
                  }
                  GETFACEHVREXT( sAppoMainFace, &nEaH, &nEaV, &nEaR) ;
                 // controllo se l'estensione normale alla faccia principale è minore della massima dimensione del cubetto
                  if ( nEaR < C_nDimCutCubeOrtoTop  OR  C_bHeadFromSide) then {
                     if ( v3AppoFace.x > 0) then
                        nDirCube = _AdFromXp ;
                     else
                        nDirCube = _AdFromXm ;
                  }
                  else {
                     if ( v3PriCube.z <= 0) then {
                        v3AppoFace = v3PriCube ;
                        GETFACEHVREXT( sMainFace, &nEaH, &nEaV, &nEaR) ;
                     }
                     else {
                        v3AppoFace = v3SecCube ;
                        GETFACEHVREXT( sSecondFace, &nEaH, &nEaV, &nEaR) ;
                     }
                    // controllo se l'estensione verticakle della faccia secondaria è minore della massima dimensione del cubetto
                     if ( nEaV < C_nDimCutCubeOrtoTop  OR  C_bHeadFromSide) then {
                        if ( v3AppoFace.x > 0) then
                           nDirCube = _AdFromXp ;
                        else
                           nDirCube = _AdFromXm ;
                     }
                     else
                        bError = TRUE ;
                  }
               }
              // impostazione parametri
               nDimOrto = C_nDimCutCubeOrtoTop ;
               nDimPara = C_nDimCutCubeParaTop ;
            }
         }
      }
      else {
        // se inclinato verso Z oppure se taglio dritto e l'estensione orizzontale è meno della larcghezza di un cubetto, altrimenti creando verso X+/- c'è il rischio che la lama approci dal sotto.
         if ( v3PriCube.z > 0.5  OR  ( ABS( v3PriCube.y) < 0.087 AND nEaH < C_nDimCutCubeOrtoSide  AND nEaV < C_nDimCutCubeParaSide)) then {
            if ( C_bSingleCutCubeTop) then {
               nDirCube = _AdFromZp ;
               nDirContLast = _NearZp ;
               bFirstShell = TRUE ;
              // impostazione parametri
               nDimOrto = C_nDimCutCubeOrtoTop ;
               nDimPara = C_nDimCutCubeParaTop ;
            }
            else {
               bExeCubeCube = TRUE ;
               nDirCube = _AdFromZm ;
               nDirContLast = _NearZp ;
              // impostazione parametri
               nDimOrto = C_nDimCutCubeParaTop ;
               nDimPara = C_nDimCutCubeParaTop ;
            }
         }
        // se rivolto verso l'alto
         elsif ( v3PriCube.z > -0.087) then {
           // controllo se la faccia è più o meno trasversale
            if ( ABS( v3PriCube.y) < 0.08) then {
               if ( /* v3PriCube.z == 0  OR */ v3PriCube.z > 0.5) then {
                  if ( v3PriCube.x > 0) then
                     nDirCube = _AdFromXp ;
                  else
                     nDirCube = _AdFromXm ;
               }
               else {
                  if ( v3PriCube.z == 0) then {
                     if ( v3PriCube.y > 0) then
                        nDirCube = _AdFromYp ;
                     else
                        nDirCube = _AdFromYm ;
                  }
                  else
                     nDirCube = _AdFromZp ;
               }
            }
           // altrimenti altri casi
            elsif ( ABS( v3PriCube.x) > 0.707) then {
               if ( v3PriCube.y > 0) then
                  nDirCube = _AdFromYp ;
               else
                  nDirCube = _AdFromYm ;
            }
           // faccia principale prevalentemente parallela all' asse trave
            elsif ( ABS( v3PriCube.y) > 0.707) then {
               if ( v3PriCube.x > 0) then
                  nDirCube = _AdFromXp ;
               else
                  nDirCube = _AdFromXm ;
            }
            elsif ( v3PriCube.x > 0) then {
               nDirCube = _AdFromXp ;
            }
            else {
               nDirCube = _AdFromXm ;
            }
         }
         else
            bError = TRUE ;
      }

     // vedo se usare sempre lama piccola o anche lama grande
      if ( C_bNoDiffSolution  OR  nEaR > C_nDimCutCubeOrtoSide) then {
         if ( C_bNoDiffSolution  OR  ( NOT( C_bSingleCutCubeTop) AND  NOT( bExistSecFace))) then
            bExeCubeCube = TRUE ;
         nDimOrto = C_nDimCutCubeParaSide ;
         nDimPara = C_nDimCutCubeParaSide ;
      }
      else {
         nDimOrto = C_nDimCutCubeOrtoSide ;
         nDimPara = C_nDimCutCubeParaSide ;
         bFirstShell = TRUE ;
      }

     // se sto facendo un taglio lungo (più o meno verticale) che deve essere solo spezzato
      if ( ( ( $CL >= 424 AND $CL <= 427)  OR  NOT bExistSecFace) AND  nDirCube != _AdFromZm  AND  nDirCube != _AdFromZp  AND  nEaV < nBladeMaxMat  AND  NOT C_bNoDiffSolution  AND  ABS( v3PriCube.z) < 0.087) then {
         // impostare nuovi parametri in questa condizione speciale
         nDimPara = C_nMaxSfridoCube ;
        // se dai calcoli richiedo spezzatura, ma da configurazione non voglio esco
         if ( C_nMaxSfridoCube == 0) then {
            bError = TRUE ;
            return ;
         }
         nDimOrto = C_nDimCutCubeOrtoSide ;
         bSplitRowPart = TRUE ;
         bFirstShell = TRUE ;
         bExeCubeCube = FALSE ;
      }

     // se ho del grezzo aggiuntivo, controllo se devo tenerne conto
      if ( C_nHeadOverMat > 0) then {
        // se taglio di testa o coda devo sempre tener conto del grezzo
         if ( nManagementFlag == _Hcut  OR  nManagementFlag == _Tcut) then
            bRaw = TRUE ;
        // se sulla testa
         elsif ( $Pmin.x == 0  OR  $CaF < 3000) then {
           // se c'è un taglio di lama sicuramente ho già tagliato il grezzo
            if ( GETCOPLANARCUTPOINT( vec3( 0, 0, 0), _DirXm)) then
               bRaw = FALSE ;
            else
               bRaw = TRUE ;
         }
        // se sulla coda
         elsif ( $Pmax.x == $L  OR  $CaF < 3000) then {
           // se c'è un taglio di lama sicuramente ho già tagliato il grezzo
            if ( GETCOPLANARCUTPOINT( vec3( $L, 0, 0), _DirXp)) then
               bRaw = FALSE ;
            else
               bRaw = TRUE ;
         }
      }

     // prima provo con nuovo metodo in caso di feature a due facce, altrimenti provo vecchio metodo
      if ( bExistSecFace) then
         bCubeOK = ADDAUXDIHEDRONS( sMainFace, nDimOrto, nDimPara, 7, bRaw)  AND  nDirCube != 0 ;
      
      if ( NOT( bExistSecFace)  OR  NOT( bCubeOK)) then
     // calcolo dei cubetti ( in realtà diedri)
         bCubeOK = ADDAUXDIHEDRONS( sMainFace, nDimOrto, nDimPara, nDirCube, bRaw)  AND  nDirCube != 0 ;

     // salvo direzione dei cubetti in variabile globale
      nDirCutCubetti = nDirCube ;
     // recupero numero shell
      nShell = GETADNUMSHELL() ;
      OUTDEB( 10, "Cubetti : MainF={sMainFace}, Dir={nDirCube}, Ok={bCubeOK}, DimOrto={nDimOrto}, DimPara={nDimPara}, SecF={sSecondFace}, nShell={nShell}, bRaw={bRaw}") ;

     // se le shell calcolate superano il numero massimo definito dall'utente faccio sfinestratura
      if ( ( nShell > C_nMaxNumShell  OR  NOT( bCubeOK))  AND  NOT( bSecondFaceCubetti)  AND
         ( C_nStrategyWindow == 1  OR  C_nStrategyWindow == 2)  AND v3PriCube.z == 0) then {
         nUseMillToWin = VerifyExecutionWindowMill( sMainFace) ;
         if ( nUseMillToWin > 0) then {
            FindBlade(  sMainFace + "," + sSecondFace, FALSE, TRUE, $T, 0, 0, _bForceComplete) ;
            AddCutWindow( C_vsNomeKitBlade[nBladeIndex] + C_sSuffBladeOpenWind) ;
            if ( bExistSecFace  AND ( $CL != 424  AND  $CL != 425  AND  $CL != 426  AND  $CL != 427)) then {
               AddWindowFinish() ;
            }
            bCubeOK = FALSE ;
            bSplitRowPart = FALSE ;
            bWindowCut = TRUE ;
         }
      }
      if ( bCubeOK  AND  NOT( bWindowCut)  AND  nShell > 0) then {
        // dico che è stato fatto almeno una lavorazione di cubettatura
         bCubettiUsed = TRUE ;
         bSideCont = FALSE ;
         nI = 1 ;
         while ( nI <= nShell) {
           // se ho già lavorato a cubetti faccio solo ultima shell
            if ( ( bSecondFaceCubetti  AND  nI == nShell)  OR  NOT( bSecondFaceCubetti)) then {
               bCutCubetti = TRUE ;
               nJ = 1 ;
              // se devo eseguire un cubetto alla volta
               if ( bExeCubeCube) then {
                  while ( GETADCUTSNAME( nI, nJ, &sOrto, &sPara)) {
                     if ( sPara != "") then {
                        GETFACENORMAL( sPara, &v3FaceP) ;
                        if ( v3FaceP.z > 0.707  AND  ( v3FaceP.z < v3FaceP.x  OR  v3FaceP.z < v3FaceP.y)) then {
                           GETFACEHVREXT( sPara, &nEaH, &nEaV, &nEaR) ;
                           FindKitBlade( nInvert, nEaV, nEaH, sPara, v3FaceP, OPT( sOrto == "", sLastOrto, sOrto), 0, TRUE) ;
                        }
                        elsif ( sOrto != ""  OR  nDirCube != _AdFromZm) then {
                           if ( ABS( v3FaceP.z) <= ABS( v3FaceP.y)  OR  bExistSecFace) then
                              bSideCont = TRUE ;
                           bSuffWorkPerp = TRUE ;
                           if ( sOrto != "") then
                              CalculateToolDir( sPara, sOrto) ;
                           ExecuteBladeCont( sPara, nNormal, nToolDir, bSideCont, OPT( bSwitchFace, TRUE, FALSE), FALSE, sOrto) ;
                        }
                        else {
                           if ( ABS( v3FaceP.z) <= ABS( v3FaceP.y)  OR  bExistSecFace) then
                              bSideCont = TRUE ;
                           bSuffWorkPerp = TRUE ;
                           ExecuteBladeCont( sPara, nNormal, nDirContLast, bSideCont, OPT( bSwitchFace, TRUE, FALSE), FALSE, sOrto) ;
                        }
                        bSideCont = FALSE ;
                     }
                     if ( sOrto != "") then {
                        bCutLess = TRUE ;
                        GETFACEHVREXT( sOrto, &nEaH, &nEaV, &nEaR) ;
                        GETFACENORMAL( sOrto, &v3FaceO) ;
                        GETFACENORMAL( sPara, &v3FaceP) ;
                        v3Appo = CROSS( v3FaceO, v3FaceP) ;
                        if ( v3Appo.z == 0) then {
                           if ( ABS( v3FaceO.z) >= 0.996) then {
                              if ( bExistSecFace) then
                                 bSideCont = TRUE ;
                              bSuffWorkPerp = TRUE ;
                              CalculateToolDir( sOrto, sPara) ;
                              ExecuteBladeCont( sOrto, nNormal, nToolDir, bSideCont, OPT( bSwitchFace, FALSE, TRUE), FALSE, sPara) ;
                           }
                           else
                              FindKitBlade( nNormal, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                        }
                        elsif ( ABS( v3FaceP.z) <= 0.707) then
                           FindKitBlade( nInvert, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                        else {
                           if ( bExistSecFace) then
                              bSideCont = TRUE ;
                           bSuffWorkPerp = TRUE ;
                           CalculateToolDir( sOrto, sPara) ;
                           ExecuteBladeCont( sOrto, nNormal, nToolDir, bSideCont, OPT( bSwitchFace, FALSE, TRUE), FALSE, sPara) ;
                        }
                        sLastOrto = sOrto ;
                        bSideCont = FALSE ;
                        bCutLess = FALSE ;
                     }
                     nJ = nJ + 1 ;
                  }
               }
              // se tagli ortogonali e poi paralleli
               else {
                 // se devo dividere in più parti lo sfrido faccio un taglio unico
                  if ( bSplitRowPart) then {
                    // lavoro facce perpendicolari
                     while ( GETADCUTSNAME( nI, nJ, &sOrto, &sPara)) {
                        if ( sOrto != "") then {
                           bCutLess = TRUE ;
                           GETFACEHVREXT( sOrto, &nEaH, &nEaV, &nEaR) ;
                           GETFACENORMAL( sOrto, &v3FaceO) ;
                           GETFACENORMAL( sPara, &v3FaceP) ;
                           if ( ABS( v3FaceO.z) < 0.05) then
                              FindKitBlade( nInvert, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                           else
                              FindKitBlade( nNormal, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                           bCutLess = FALSE ;
                        }
                        nJ = nJ + 1 ;
                     }
                    // lavoro facce parallele
                     nJ = 1 ;
                     sAppo = "" ;
                     while ( GETADCUTSNAME( nI, nJ, &sOrto, &sPara)) {
                        if ( sPara != "") then
                           sAppo = sAppo + sPara + "," ;
                        nJ = nJ + 1 ;
                     }

                     GETFACEHVREXT( sAppo, &nEaH, &nEaV, &nEaR) ;
                     GETFACENORMAL( sAppo, &v3FaceP) ;
                     bCutMore = TRUE ;
                     if ( ABS( v3FaceO.z) < 0.05) then
                        FindKitBlade( nNormal, nEaV, nEaH, sAppo, v3FaceP, sAppo, 0, TRUE) ;
                     else
                        FindKitBlade( nInvert, nEaV, nEaH, sAppo, v3FaceP, sAppo, 0, TRUE) ;
                     bCutMore = FALSE ;
                    // se sono alla fine resetto il flag
                     if ( nI == nShell) then
                        bSplitRowPart = FALSE ;
                     bSideCont = FALSE ;
                  }
                  else {
                    // se ho già lavorato a cubetti non faccio passate perpendicolari
                     if ( NOT( bSecondFaceCubetti)) then {
                       // lavoro facce ortogonali
                        while ( GETADCUTSNAME( nI, nJ, &sOrto, &sPara)) {
                           if ( sOrto != "") then {
                             // se ho un cubetto acuto
                              if ( STRCOMPARE( sOrto, "OT", FALSE) > 0) then
                                 bAcuteAngle = TRUE ;
                             // se ho un'altra faccia orizzontale allora taglio meno. L'ultimo taglio sullo spigolo invece deve essere fatto a zero
                              if ( GETADCUTSNAME( nI, nJ+1, &sAppoFakeFace, &sAppoFakeFace)) then
                                 bCutLess = TRUE ;
                              GETFACEHVREXT( sOrto, &nEaH, &nEaV, &nEaR) ;
                              GETFACENORMAL( sOrto, &v3FaceO) ;
                              GETFACENORMAL( sPara, &v3FaceP) ;
                              v3Appo = CROSS( v3FaceO, v3FaceP) ;
                              if ( v3Appo.z == 0) then {
                                 if ( nDirCutCubetti == _AdFromZm  OR  nDirCutCubetti == _AdFromZp) then {
                                    bSideCont = TRUE ;
                                    bSuffWorkPerp = TRUE ;
                                    CalculateToolDir( sOrto, sPara) ;
                                    ExecuteBladeCont( sOrto, OPT( nShell == 1, nInvert, nNormal), nToolDir, bSideCont, OPT( bSwitchFace, FALSE, TRUE), FALSE, sPara) ;
                                 }
                                 else
                                    FindKitBlade( nNormal, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                              }
                              elsif ( ABS( v3FaceO.z) <= 0.707  AND  ABS( v3Appo.z) > 0.707) then
                                 FindKitBlade( nInvert, nEaV, nEaH, sOrto, v3FaceO, sPara, 0, TRUE) ;
                              else {
                                 if ( bExistSecFace) then
                                    bSideCont = TRUE ;
                                 bSuffWorkPerp = TRUE ;
                                 CalculateToolDir( sOrto, sPara) ;
                                 ExecuteBladeCont( sOrto, OPT( nShell == 1, nInvert, nNormal), nToolDir, bSideCont, OPT( bSwitchFace, FALSE, TRUE), FALSE, sPara) ;
                              }
                              bAcuteAngle = FALSE ;
                              bSideCont = FALSE ;
                              bCutLess = FALSE ;
                           }
                           nJ = nJ + 1 ;
                        }
                     }
                     nJ = 1 ;
                     bFirstShell = FALSE ;
                    // lavoro facce parallele
                     while ( GETADCUTSNAME( nI, nJ, &sOrto, &sPara)) {
                        if ( sPara != "") then {
                          // se ho un cubetto acuto
                           if ( STRCOMPARE( sPara, "PT", FALSE) > 0) then
                                 bAcuteAngle = TRUE ;

                           if ( sOrto == "") then {
                              bLastPassageCube = TRUE ;
                              sOrto = sLastOrto ;
                           }
                           GETFACEHVREXT( sPara, &nEaH, &nEaV, &nEaR) ;
                           GETFACENORMAL( sPara, &v3FaceP) ;
                          // se ho facce ortogonali decido come lavorare
                           if ( NOT( bLastPassageCube)) then {
                              GETFACENORMAL( sOrto, &v3FaceO) ;
                              v3Appo = CROSS( v3FaceO, v3FaceP) ;

                             // controllo se il taglio è più o meno orizzontale
                              if ( ABS( v3Appo.z) < 0.174) then {
                                // se ho poco materiale sopra non serve fare passata di finitura, infatti in pezzo non pesa sopra la lama e non rovina la superficie sotto
                                // QQQ sono costretto anche a controllare la lunghezza perchè non è ammesso da lavorazione un collegamento L maggiore di 1000
                                 if ( nEaR > 50  AND  $EW < 990) then
                                    bSetOverMatFacePar = TRUE ;
                              }
                              if ( v3Appo.z == 0) then {
                                 if ( nShell > 1  OR  v3FaceP.z > 0.985  OR  v3FaceO.z < 0) then {
                                    bSuffWorkPerp = TRUE ;
                                    CalculateToolDir( sPara, sOrto) ;
                                    ExecuteBladeCont( sPara, nNormal, nToolDir, bSideCont, bSetOverMatFacePar, FALSE, sOrto) ;
                                 }
                                 else {
                                    FindKitBlade( nNormal, nEaV, nEaH, sPara, v3FaceP, sOrto, 0, TRUE) ;
                                    bSetOverMatFacePar = FALSE ;
                                 }
                              }
                              elsif ( ABS( v3Appo.z) > 0.707) then {
                                 if ( NOT( bExistSecFace)) then
                                    bCutMore = TRUE ;
                                 FindKitBlade( nInvert, nEaV, nEaH, sPara, v3FaceP, sOrto, 0, TRUE) ;
                                 bCutMore = FALSE ;
                                 bSetOverMatFacePar = FALSE ;
                              }
                              else {
                                 if ( bExistSecFace) then
                                    bSideCont = TRUE ;
                                 bSuffWorkPerp = TRUE ;
                                 CalculateToolDir( sPara, sOrto) ;
                                 ExecuteBladeCont( sPara, nNormal, nToolDir, bSideCont, bSetOverMatFacePar, FALSE, sOrto) ;
                              }

                              bAcuteAngle = FALSE ;
                              sLastOrto = sOrto ;
                              bSideCont = FALSE ;
                           }
                          // se non ho facce ortogonali, applico direttamente un taglio di lama
                           else {
                              bCutMore = TRUE ;
                              if ( NOT( bExistSecFace)  AND  nEaV < nBladeMaxMat) then
                                 FindKitBlade( nNormal, nEaV, nEaH, sPara, v3FaceP, sPara, 0, TRUE) ;
                              else
                                 FindKitBlade( nInvert, nEaV, nEaH, sPara, v3FaceP, sPara, 0, TRUE) ;
                              bSetOverMatFacePar = FALSE ;
                              bLastPassageCube = FALSE ;
                              bCutMore = FALSE ;
                           }
                        }
                        nJ = nJ + 1 ;
                     }
                  }
               }
            }
            nI = nI + 1 ;
         }

        // se sono stato più alto devo fare passata finale per togliere i 2 millimetri che ho lasciato per evitare che il cubetto,
        // appoggiato sulla lama, segni la superficie "buona".
         if ( bSetOverMatFacePar) then {
           // se cubetti tra due facce
            if ( sMainFace != sSecondFace) then
               GETFACEFACEANGLW( sMainFace, sSecondFace, &nAng, &nLen, &nWid) ;
            else {
               if ( nDirCube ==  _AdFromZm  OR  nDirCube == _AdFromZp) then
                  nWid = $EV ;
               else
                  nWid = $EH ;
            }

            if ( nWid > nBladeDiam  AND  nLen > nBladeDiam) then {
               bSuffWorkPerp = TRUE ;
               SETKITOVERMAT( nBladeDiam - 50) ;
               CalculateToolDir( sPara, sOrto) ;
               ExecuteBladeCont( sMainFace, nNormal, nToolDir, bSideCont, bSetOverMatFacePar, TRUE, sSecondFace) ;
            }
            
            bSuffWorkPerp = TRUE ;
            CalculateToolDir( sPara, sOrto) ;
            ExecuteBladeCont( sMainFace, nNormal, nToolDir, bSideCont, bSetOverMatFacePar, TRUE, sSecondFace) ;
         }
         bSecondFaceCubetti = TRUE ;
         bFirstShell = FALSE ;
      }
      elsif ( ( NOT bCubeOK  AND  NOT bWindowCut) OR  nShell == 0) then {
         bExecuteCubetti = FALSE ;
         bError = TRUE ;
      }

     // resetto tutti i valori
      bCutCubetti = FALSE ;
      bSplitRowPart = FALSE ;
   }

   procedure VerifyAndSetStep( string sCheckedKit, num nStep, bool bForceStep)
   {
      num nMaxMatTool ;
      num nToolType ;

     // verifico tipo di utensile
      GETKITDATA( sCheckedKit, _ToolType, 1, &nToolType) ;
     // gestione speciale feature tenone
      if ( $CaF == 1050) then {
        // prendo spessore lama oppure massimo materiale se fresa
         if ( nToolType == _TtBlade) then
            GETKITDATA( sCheckedKit, _ToolThick, 1, &nMaxMatTool) ;
         else
            GETKITDATA( sCheckedKit, _ToolMaxMat, 1, &nMaxMatTool) ;
        // parametri corretti
         if ( bForceStep) then {
            if ( nStep < nMaxMatTool) then
               SETKITSTEP( nStep) ;
            else
               SETKITSTEP( nMaxMatTool) ;
         }
         else {
           // se step congruenti con massimo materiale
            if ( nStep <= nMaxMatTool  AND  C_nMinStepTenon <= nMaxMatTool) then {
               if ( C_nMinStepTenon >= nStep) then
                  SETKITSTEP( C_nMinStepTenon) ;
               else
                  SETKITSTEP( nStep) ;
            }
           // incongruenza tra parametri ( step più grande del massimo materiale utensile)
            else {
               if ( nMaxMatTool <= C_nMinStepTenon  AND  nMaxMatTool > 0) then
                  SETKITSTEP( nMaxMatTool) ;
               else
                  SETKITSTEP( C_nMinStepTenon) ;
            }
         }
      }
     // gestione speciale feature taglio longitudinale
      elsif ( $CaF == 3010  OR  $CaF == 3012) then {
        // controllo tipologia utensile. Se fresa prendo il massimo materiale, se lama uso step da kit
         if ( nToolType == _TtBlade) then {
            if ( bForceStep) then
               SETKITSTEP( nStep) ;
            else {
               GETKITDATA( sCheckedKit, _KitStep, 0, &nMaxMatTool) ;
               if ( nMaxMatTool == 0) then {
                  if ( nStep == 0) then
                     SETKITSTEP( C_nSecurityStep) ;
                  else
                     SETKITSTEP( MIN( C_nSecurityStep, nStep)) ;
               }
            }
         }
         else {
            if ( bForceStep) then
               SETKITSTEP( nStep) ;
            else {
               GETKITDATA( sCheckedKit, _ToolMaxMat, 0, &nMaxMatTool) ;
               SETKITSTEP( nMaxMatTool) ;
            }
         }
      }
     // feature non speciali
      else {
        // se forzo l'impostazione dello step
         if ( bForceStep) then
            SETKITSTEP( nStep) ;
        // controllo che lo step non sia nullo
         else {
            GETKITDATA( sCheckedKit, _KitStep, 0, &nMaxMatTool) ;
            if ( nMaxMatTool == 0) then {
               if ( nStep == 0) then
                  SETKITSTEP( C_nSecurityStep) ;
               else
                  SETKITSTEP( MIN( C_nSecurityStep, nStep)) ;
            }
         }
      }
   }

// ----------------- CALCOLO POSIZIONE ------------------
   function GetPosMachArea() : NUM
   {
      num nRefToCalc ;

      nRefToCalc = C_nDimCarr + ( C_nDiamMotore / 2) + 100 ; // aggiungo 100mm per sicurezza

      if ( bPieceEnlarged) then {
         return 1 ;
      }
      elsif ( $L > C_nLenVeryShortBeam) then {
         if ( nPosXFeat < nRefToCalc) then
            return 1 ;
         elsif ( nPosXFeat >= nRefToCalc  AND  nPosXFeat < ( $L / 2)) then
            return 2 ;
         elsif ( nPosXFeat >= ( $L / 2)  AND  nPosXFeat < ( $L - nRefToCalc)) then
            return 3 ;
         else
            return 4 ;
      }
      else {
         if ( nPosXFeat < ( $L / 2)) then
            return 1 ;
         else
            return 4 ;
      }
   }

// ----------------- CALCOLO DIREZIONI ------------------
   procedure CalculateHeadSolution( vec3 v3AppoToolDir)
   {
      num nKitToolPos ;

      GETKITDATA( sKit, _ToolPos, 0, &nKitToolPos) ;
     // se posizione dell'utensile 0 provo a richiamare la funzione cercando il primo utensile
      if ( nKitToolPos == 0) then
         GETKITDATA( sKit, _ToolPos, 1, &nKitToolPos) ;
     // vedo se utensile su testa normale o su revolver
      bKX5 = C_nFirstPosSecSpeHead > nKitToolPos  OR  C_nFirstPosSecSpeHead == 0;

      bSuffSolSpeHole = FALSE ;
      bSuffSolOpp = FALSE ;

     // testa con canotto in verticale (tipo CMS)
      if ( NOT C_bHeadFromSide) then {
        // se esattamente perpendicolare alla trave
         if ( v3AppoToolDir.z == 1) then {
            if ( nPosYFeat < $W/2) then
               bSpecialSuff180 = TRUE ;
         }
         elsif ( v3AppoToolDir.z < 0.99  AND  ABS( v3AppoToolDir.y) > 0.02) then {
           // se quasi perpendicolare alla trave
            if ( ABS( v3AppoToolDir.y) > 0.975) then {
               if ( bMachineWithCarr) then {
                 // gestione speciale per suprema con RX4
                  if ( nToolNumber == 2  AND  C_nFirstPosSecSpeHead > 0) then {
                     if ( ( ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4)  AND v3AppoToolDir.y <= 0)  OR
                        ( ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3)  AND v3AppoToolDir.y >= 0)) then
                        bSuffSolOpp = TRUE ;
                     else
                        bSuffSolSpeHole = TRUE ;
                  }
                  elsif ( NOT( bKX5)) then {
                     // se sono quasi perpendicolare e uso revolver scelgo sempre soluzione normale
                     // if ( ( nPosXFeat <= ( $L / 2)  AND v3AppoToolDir.y <= 0)  OR  ( nPosXFeat > ( $L / 2)  AND v3AppoToolDir.y >= 0)) then
                        // bSuffSolOpp = TRUE ;
                  }
                  else {
                     if ( ( ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4)  AND v3AppoToolDir.y <= 0)  OR
                        ( ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3)  AND v3AppoToolDir.y >= 0)) then
                        bSuffSolOpp = TRUE ;
                  }
                 // se non importa soluzione devo invertire soluzione se foro invertito
                  if ( bCanInvert  AND  bHoleInvert) then {
                     if ( NOT( bSuffSolSpeHole)) then {
                        bSuffSolOpp = NOT( bSuffSolOpp) ;
                        if ( nToolNumber == 2  AND  C_nFirstPosSecSpeHead > 0) then
                           bSuffSolSpeHole = NOT( bSuffSolOpp) ;
                     }
                  }
               }
            }
            elsif ( v3AppoToolDir.z > 0.707) then {
               if ( ( ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4)  AND v3AppoToolDir.y >= 0)  OR
                  ( ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3)  AND v3AppoToolDir.y <= 0)) then {
                  bSuffSolOpp = TRUE ;
               }
            }
            elsif ( ( v3AppoToolDir.x < 0 AND v3AppoToolDir.y < 0)  OR  ( v3AppoToolDir.x > 0 AND v3AppoToolDir.y > 0)) then {
               if ( bKX5) then {
                 // se la feature è "troncante" devo tenere il braccio verso l'esterno
                  if ( $CaF < 3000 /* OR  ( $Pmin.x == 0  OR  $Pmax.x == $L)*/) then {
                     if ( ( ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4)  AND v3AppoToolDir.y <= 0)  OR
                        ( ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3)  AND v3AppoToolDir.y >= 0)) then {
                        bSuffSolOpp = TRUE ;
                     }
                  }
                  else
                     bSuffSolOpp = TRUE ;
               }
            }
            else {
               if ( NOT( bKX5)) then {
                  if ( ABS( v3AppoToolDir.y) < 0.95) then
                     bSuffSolOpp = TRUE ;
               }
               else {
                 // se la feature è "troncante" devo tenere il braccio verso l'esterno
                  if ( $CaF < 3000 /* OR  ( $Pmin.x == 0  OR  $Pmax.x == $L)*/) then {
                     if ( ( ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4)  AND v3AppoToolDir.y <= 0)  OR
                        ( ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3)  AND v3AppoToolDir.y >= 0)) then {
                        bSuffSolOpp = TRUE ;
                     }
                  }
               }
            }
            if ( bSuffWorkPerp  OR  C_bOtherSolution) then
               bSuffSolOpp = NOT( bSuffSolOpp) ;
         }
         else {
           // se non sono sulla testa o coda devo mettere braccio in posizione opportuna
          //  if ( $Pmin.x > 0  AND  $Pmax.x < $L) then {
               if ( ( $Np.y < 0  AND  v3AppoToolDir.x < 0)  OR  ( $Np.y > 0  AND  v3AppoToolDir.x > 0)) then
                  bSuffSolOpp = TRUE ;
          //  }
         }
      }
     // testa con canotto orizzontale (tipo HAGE)
      else {
        // con testa di fianco si controlla solo quando si sta lavorando da sotto
         if ( v3AppoToolDir.z < 0  AND  ABS( v3AppoToolDir.x) < 0.15) then {
            if ( v3AppoToolDir.x <= 0) then {
               if ( GetPosMachArea() == 2  OR  GetPosMachArea() == 4) then
                  bSuffSolOpp = TRUE ;
            }
            elsif ( v3AppoToolDir.x > 0) then {
               if ( GetPosMachArea() == 1  OR  GetPosMachArea() == 3) then
                  bSuffSolOpp = TRUE ;
            }
         }
         elsif ( COMPARE( ABS( v3AppoToolDir.z), 1, 1e-5) == 0) then {
            if ( $Pmax.x == $L) then
               bSuffSolOpp = TRUE ;
         }
         elsif ( bCutCubetti) then {
            if ( nDirCutCubetti == _AdFromXm  AND  v3AppoToolDir.x < 0  AND  $Pmin.z < 1) then
               bSuffSolOpp = TRUE ;
            elsif ( nDirCutCubetti == _AdFromXp AND v3AppoToolDir.x > 0  AND  $Pmin.z < 1) then
               bSuffSolOpp = TRUE ;
         }
         elsif ( COMPARE( ABS( v3AppoToolDir.z), 0, 1e-5) == 0) then {
            if ( $Pmax.z < $T  AND  ( $Pmin.x == 0  OR  $Pmax.x == $L)) then
               bSuffSolOpp = TRUE ;
         }
      }
   }

   procedure CalculateToolDir( string sFirstFace, string sSecondFace)
   {
      bool bOldValCalcPrerp = FALSE ;
      num  nAppoLoc ;

      GETTOOLDIR( sFirstFace, sSecondFace, &nToolDir, &v3ToolDir) ;
      SETKITDIR( nToolDir) ;

     // se lavorazione perpendicolare la direzione deve essere calcolata contraria
      if ( /* bCutCubetti  OR */ bSuffWorkPerp) then {
         GETTOOLDIR( sSecondFace, sFirstFace, &nAppoLoc, &v3ToolDir) ;
        // devo far finta che la lavorazione in questo caso non è più perpendicolare, perchè ho già ricalcolato la direzione dell'utensile e quindi non deve essere più invertita nel calcolo della soluzione
         bOldValCalcPrerp = bSuffWorkPerp ;
         bSuffWorkPerp = FALSE ;
      }
      CalculateHeadSolution( v3ToolDir) ;
     // ripristino vecchio valore lavorazione perpendicolare
      bSuffWorkPerp = bOldValCalcPrerp ;
   }

// ------------- FUNZIONI PER RINVIO SPECIALE -----------
  // TypeWork :  1 - Foro normale,  2 - Foro invertito,  3 - Contornatura,  4 - Svuotatura
   function SpecialWorkWithRR( num nTypeWork, string sNameFace, num nWidthFace) : BOOL
   {
      string sNameTempKit = "" ;
      num nToolMaxMat ;
      num nPriRR = 0 ;

      if ( ABS( $Np.z) == 1) then {

        // la priorità standard del rinvio è sempre metà della priorità standard della fresa
         nPriRR = CheckPriSmallPiece( C_nPriFre / 2) ;

         GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolMaxMat, &nToolMaxMat) ;

        // da eseguire foratura
         if ( nTypeWork == 1  OR  nTypeWork == 2) then {
            if ( nToolDiam == nWidthFace) then {
               sNameTempKit = C_sPrefFor + C_vsNomeKit[nToolIndex] ;
               if ( nTypeWork == 2) then
                  bSuffInvert = TRUE ;
               SETKITMAXMAT( nToolMaxMat) ;
               if ( $ER > nToolMaxMat) then
                  nLenFirstHole = nToolMaxMat ;
               else
                  nLenFirstHole = $ER ;
            }
            else {
               if ( nTypeWork == 2) then {
                 // QQQ creare foro con geometria invertita se il tipo di lavoro è 2
                  sNameFace = "AH01" ;
               }
               if ( nWidthFace < ( nToolDiam * 2)) then
                  sNameTempKit = C_sPrefCont + C_vsNomeKit[nToolIndex] ;
               else
                  sNameTempKit = C_sPrefSvuot + C_vsNomeKit[nToolIndex] ;
               if ( $ER > nToolMaxMat) then {
                  SETKITDEPTH( nToolMaxMat) ;
                  nLenFirstHole = nToolMaxMat ;
               }
               else
                  nLenFirstHole = $ER ;
            }

            InsertKit( sNameTempKit, sNameFace, nPosXFeat, nPriRR) ;

            return TRUE ;
         }
        // da eseguire contornatura
         elsif ( nTypeWork == 3) then {
            sNameTempKit = C_sPrefCont + C_vsNomeKit[nToolIndex] ;
            CalculateToolDir( sNameFace, "F01") ;
            if ( $ER > nToolMaxMat) then
               SETKITDEPTH( ( nToolMaxMat - C_nSicurezza) - $ER) ;
            InsertKit( sNameTempKit, sNameFace, nPosXFeat, nPri) ;
            return TRUE ;
         }
        // da eseguire svuotatura
         elsif ( nTypeWork == 4) then {
            sNameTempKit = C_sPrefSvuot + C_vsNomeKit[nToolIndex] ;
            if ( $ER > nToolMaxMat) then
               SETKITDEPTH( ( nToolMaxMat - C_nSicurezza) - $ER) ;
            InsertKit( sNameTempKit, sNameFace, nPosXFeat, nPriRR) ;
            return TRUE ;
         }
      }

     // errore passaggio parametri
      bError = TRUE ;
      return FALSE ;

   }

// ------------------- FUNZIONI PER FORI ----------------

   function ExecuteCentering( num nDiam, num nMaxAffDrill, num nAngleHole, num nPriorityHole) : BOOL
   {
      string sNameHoleCent = "" ;
      num    nPriCentrino ;
      num    nMaxMatCent = 0 ;

      sKit2 = "" ;
      if ( ( C_bExecuteCenteringHole  OR  bNotFindAnotherKit  OR  GETPARENTHOLE()  OR
         ( nAngleHole > 10 AND nAngleHole < 80 AND nMaxAffDrill > C_nLenLongHole)) AND  C_vDiamFre[nNumberCentering] != 0) then {
         if ( bHoleInvert) then
            bSuffInvert = TRUE ;
        // eseguo centrino come un preforo
         if ( C_vDiamFre[nNumberCentering] == nDiam) then {
            sNameHoleCent = "H01" ;
            sKit2 = C_sPrefFor + C_vNomeFreBase[nNumberCentering] ;
            if ( $ER < C_nMaxDepthFreCentrino) then {
               SETKITMAXMAT( $ER) ;
               nLenFirstHole = $ER ;
               bHoleComplete = TRUE ;
            }
            else {
               bHoleComplete = FALSE ;
               SETKITMAXMAT( C_nDepthFreCentrino) ;
               if ( bNotFindAnotherKit) then {
                  GETKITDATA( sKit2, _KitMaxMat, 0, &nMaxMatCent) ;
                  if ( nLenFirstHole == 0) then
                     nLenFirstHole = nMaxMatCent ;
                  else
                     nLenSecondHole = nMaxMatCent ;
               }
            }
         }
        // eseguo centrino come contornatura \ svuotatura
         elsif ( C_vDiamFre[nNumberCentering] < nDiam) then {
            v3Appo = $Np ;
           // cambio il diametro del foro e lo eseguo come svuotatura
            if ( C_vDiamFre[nNumberCentering] + 0.6 > nDiam) then {
               if ( bHoleInvert) then {
                  sNameHoleCent = "AH11" ;
                  ADDAUXHOLE( "H01", sNameHoleCent, TRUE, $ER, C_vDiamFre[nNumberCentering] + 0.6) ;
                  v3Appo = VEC3( 0, 0, 0) - $Np ;
               }
               else {
                  sNameHoleCent = "AH01" ;
                  ADDAUXHOLE( "H01", sNameHoleCent, FALSE, $ER, C_vDiamFre[nNumberCentering] + 0.6) ;
               }
            }
            else {
               if ( bHoleInvert) then {
                  sNameHoleCent = "AH11" ;
                  ADDAUXHOLE( "H01", sNameHoleCent, TRUE) ;
                  v3Appo = VEC3( 0, 0, 0) - $Np ;
               }
               else
                  sNameHoleCent = "H01" ;
            }

           // eseguo centrino come una contornatura
            if ( C_vDiamFre[nNumberCentering] >= ( nDiam / 2)) then
               sKit2 = C_sPrefCont + C_vNomeFreBase[nNumberCentering] ;
           // eseguo centrino come una svuotatura
            else
               sKit2 = C_sPrefSvuot + C_vNomeFreBase[nNumberCentering] ;
            SetParamHole( sKit2, v3Appo) ;
            SETKITDEPTH( C_nDepthFreCentrino) ;

           // controllo se lavoro completamente il foro con la fresa per centrino
            if ( $ER <= C_nMaxDepthFreCentrino) then {
               SETKITDEPTH( $ER) ;
               nLenFirstHole = $ER ;
               bHoleComplete = TRUE ;
            }
            else {
              // se preforo deve essere più largo del foro
               SETKITOVERMAT( -0.75) ;

               bHoleComplete = FALSE ;
               if ( bNotFindAnotherKit) then {
                  SETKITDEPTH( C_nMaxDepthFreCentrino) ;
                  if ( nLenFirstHole == 0) then
                     nLenFirstHole = C_nMaxDepthFreCentrino ;
                  else
                     nLenSecondHole = C_nMaxDepthFreCentrino ;
               }
            }
         }
        // non è possibile usare la fresa per fare il centrino
         else {
            sKit2 = "" ;
            if ( C_bExecuteCenteringHole  OR  ( nDiam >= C_vDiamFre[1]  AND  C_vDiamFre[1] > 0)) then {
               if ( NOT( bNotFindAnotherKit)) then {
                  if ( nMaxAffDrill > C_nLenLongHole) then
                     OutputReport( _BcfWarn, "{sAttention} {sHole} : {$NaF} {sNotComplete}") ;
               }
            }
         }

         if ( sKit2 != "") then {
           // vedo se il foro in questione è il ribasso di un altro foro
            if ( GETPARENTHOLE()) then
               nPriCentrino = -1000 ;
            else
               nPriCentrino = 0 ;
            nPriCentrino = nPriCentrino + ( nPriorityHole + 300) + ( $Hp * C_nDeltaSquad) ;
            nPriCentrino = CheckPriSmallPiece( nPriCentrino) ;
            nPri = nPri + ( $HP * C_nDeltaSquad) ;
            SetLeadInOutCont( FALSE, _Clg_Nessuno, _Clg_Nessuno, &sKit2) ;
            InsertKit( sKit2, sNameHoleCent, nPosXFeat, nPriCentrino) ;
            return TRUE ;
         }
      }
      bHoleComplete = FALSE ;
      return FALSE ;
   }

   procedure CheckTypeTool( string sNameKit, vec3 v3NormalHole)
   {
      bool  bPosUteOk ;
      bool  bTypeLongHole ;
      num   nPosUte = 0 ;
      num   nKitMachType ;


      nKitMachType = GETKITTYPE( sNameKit) ;
      if ( nKitMachType == _KitDrill) then
         bCanInvert = TRUE ;
      elsif ( nKitMachType == _KitCont OR nKitMachType == _KitPock) then
         bCanInvert = FALSE ;
      else
         bError = TRUE ;

      bTypeLongHole = GETKITDATA( sNameKit, _KitToolsNbr, 0, &nToolNumber) ;
      if ( ( bTypeLongHole  AND  nToolNumber == 2  AND  nKitMachType == _KitDrill) OR ( C_bExecuteCenteringHole  AND NOT( bHoleWithMill))) then {
         nPri = nPri + ( $HP * C_nDeltaSquad) ;
         bPosUteOk = GETKITDATA( sNameKit, _ToolPos, 2, &nPosUte) ;
      }
      else
         bPosUteOk = GETKITDATA( sNameKit, _ToolPos, 1, &nPosUte) ;

      if ( C_nFirstPosSecSpeHead == 0) then
         bKX5 = TRUE ;
      elsif ( bPosUteOk) then {
        // testa KX5
         if ( nPosUte < C_nFirstPosSecSpeHead) then
            bKX5 = TRUE ;
        // testa RX4
         elsif ( nPosUte >= C_nFirstPosSecSpeHead) then
            bKX5 = FALSE ;
        // errore
         else {
            bKX5 = FALSE ;
            bError = TRUE ;
         }
      }
      else
         bError = TRUE ;

     // cerco la soluzione più appropriata
      SetParamHole( sNameKit, v3NormalHole) ;
   }

   procedure CheckDepthHole( num nAffForo)
   {
      if ( sKit != "") then {
        // Se utilizzo gruppo a forare, non ho più controllo su affondamenti ecc... 
         if ( GETKITTYPE( sKit) != _KitMdrill) then {
            if ( bError) then
               OutputReport( _BcfWarnErr, "{sError} {sHole}:2 {$NaF} {sNotExecute}") ;
            elsif ( nAffForo > ( nLenFirstHole + nLenSecondHole)) then {
               if ( bCanDoubleHole) then
                  OutputReport( _BcfWarn, "{sAttention} {sHole} {sDouble}: {$NaF} {sNotComplete}") ;
               else
                  OutputReport( _BcfWarn, "{sAttention} {sHole}: {$NaF} {sNotComplete}") ;
            }
         }
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sHole}:2 {$NaF} {sNotExecute}") ;
   }

   procedure SetParamHole( string sNameKit, vec3 v3NormalHole)
   {
      num nToolNbr ;
      num CheckIsOk ;
      num nHoleFace ;
      num nDirectionHole ;

      GETKITDATA( sNameKit, _KitToolsNbr, 0, &nToolNbr) ;

      if ( bHoleInvert) then {
         nHoleFace = $HO ;
         nDirectionHole = $HDO ;
      }
      else {
         nHoleFace = $HI ;
         nDirectionHole = $HDI ;
      }

      if ( $CaF == 3031) then {
         bSuffSolSpeHole = FALSE ;
         bSuffSolOpp = FALSE ;
      }
      elsif ( nHoleFace == _Top  OR  nHoleFace == _Left  OR  nHoleFace == _Right) then {
         if ( nToolNbr == 2  AND  C_nFirstPosSecSpeHead > 0) then
            bSuffSolSpeHole = TRUE ;
         else
            bSuffSolSpeHole = FALSE ;
      }
      else
         CalculateHeadSolution( v3NormalHole) ;

   }

  // ritorna un numero da sommare alla priorità, con un valore che diminuisce da destra a sinistra
   function SetPriorityHole( num nFace) : NUM
   {
      num nKitType ;
      num nPesoFaccia = 0 ;

      nKitType = GETKITTYPE( sKit) ;

      if ( NOT( bMachineWithCarr)  OR  C_bDrillOptimizeByFace) then {
         if ( nKitType == _KitDrill) then {
            nFace = ABS( nFace) ;
            if ( nFace == _Right) then
               nPesoFaccia = 500 ;
            elsif ( nFace == _Top) then
               nPesoFaccia = 400 ;
            elsif ( nFace == _Front) then
               nPesoFaccia = 300 ;
            elsif ( nFace == _Back) then
               nPesoFaccia = 200 ;
            elsif ( nFace == _Left) then
               nPesoFaccia = 100 ;
            else
               nPesoFaccia = 0 ;
         }
         else
            nPesoFaccia = 0 ;
      }
      else
         nPesoFaccia = 0 ;

      return nPesoFaccia ;
   }

   // ritorna la distanza di "affondamento nagativo" ( per evitare collisione con fori angolati)
   function CalculateAddLen( string sKitName, num nAngleHole, num nDiamHole, num nDiamTool) : NUM
   {
      bool   bFaceExist ;
      num    nLenIngFlangia = 0 ;
      num    nLenIngPortaUte = 0 ;
      num    nLenIngMotore = 0 ;
      string sToolName ;

      bFaceExist = GETKITDATA( sKitName, _ToolName, 1, &sToolName) ;
      bFaceExist = bFaceExist  AND  GETTOOLHOLDER( sToolName, &nTHDiam, &nTHLen) ;
      if ( NOT( bFaceExist)) then {
         nTHDiam = C_nDiamGhiera ;
         nTHLen = 90 ;
      }

      if ( nAngleHole != 0 AND nAngleHole != 90 AND nAngleHole != 180 AND nAngleHole != 270) then {
        // calcolo quanto devo stare fuori
         nLenIngFlangia =  ABS ( TAN( nAngleHole) * ( nTHDiam + nDiamHole - nDiamTool) / 2) ;
         nLenIngPortaUte = ABS ( TAN( nAngleHole) * ( C_nDiamNasoMandrino + nDiamHole - nDiamTool) / 2) ;
         if ( ( C_bNoDiffSolution AND ( $HI != _Top  AND  $HO != _Top))  OR  NOT( C_bNoDiffSolution)) then
            nLenIngMotore = ABS ( TAN( nAngleHole) * ( C_nDiamMotore + nDiamHole - nDiamTool) / 2) ;
      }
      else {
         nLenIngFlangia =  0 ;
         nLenIngPortaUte = 0 ;
         nLenIngMotore = 0 ;
      }


      GETKITDATA( sKitName, _ToolLen, 0, &nToolLen) ;
      GETKITDATA( sKitName, _ToolDiam, 0, &nToolDiam) ;
      if ( nToolDiam > nTHDiam) then
         nTHLen = 0 ;

     // sottraggo la distanza dal punto calcolato al naso mandrino o al motore
      nLenIngPortaUte = nLenIngPortaUte - nTHLen ;
      nLenIngMotore = nLenIngMotore - ( nTHLen + C_nCollDist1) ;

     // calcolo soluzione più restrittiva
      if ( nLenIngFlangia > nLenIngPortaUte) then {
         if ( nLenIngMotore > nLenIngFlangia) then
            nLenIngFlangia = nLenIngMotore ;
      }
      else {
         if ( nLenIngPortaUte > nLenIngMotore) then
            nLenIngFlangia = nLenIngPortaUte ;
         else
            nLenIngFlangia = nLenIngMotore ;
      }

     // aggiungo distanza di sicurezza
      if ( nAngleHole != 0 AND nAngleHole != 90 AND nAngleHole != 180 AND nAngleHole != 270) then
         nLenIngFlangia = nLenIngFlangia + ( C_nSicurezza / COS( nAngleHole)) ;

      return nLenIngFlangia ;
   }

   procedure ApplyInterpolatedHoleKit( num nDiamTool, num nDiamHole, string sNameHoleKit)
   {

      v3Appo = $Np ;
      if ( nDiamTool + 0.6 > nDiamHole) then {
         if ( bHoleInvert) then {
            sNameHole = "AH21" ;
            ADDAUXHOLE( "H01", sNameHole, TRUE, $ER, nDiamTool + 0.6) ;
            v3Appo = VEC3( 0, 0, 0) - v3Appo ;
         }
         else {
            sNameHole = "AH01" ;
            ADDAUXHOLE( "H01", sNameHole, FALSE, $ER, nDiamTool + 0.6) ;
         }
      }
      else {
         if ( bHoleInvert) then {
            sNameHole = "AH21" ;
            ADDAUXHOLE( "H01", sNameHole, TRUE) ;
            v3Appo = VEC3( 0, 0, 0) - v3Appo ;
         }
         else
            sNameHole = "H01" ;
      }
      sKit = sNameHoleKit ;
      CheckTypeTool( sNameHoleKit, v3Appo) ;
   }

   // 0 = nessun kit trovato, 1 = foro eseguito completamente, -1 = foro eseguito ma non completo
   function FindKitHole( num nDiam, num nLen, num nAngle, num nType, num nPriorityHole) : NUM
   {
      bool bIsOk ;
      bool bMatCompatible = TRUE ;
      num  nCont ;
      num  nAffDrill ;
      num  nIngombro ;
      num  nIngombroS ;
      num  nDiamUtensile ;
      num  nDiamUtensile2 ;
      num  nKitType ;
      num  nToolType ;
      num  nPosUte ;
      string sToolName ;

      nCont = 1 ;
      nAffDrill = 0 ;
      nDiamUtensile = 0 ;
      sKit = "" ;
      sKit2 = "" ;
      bNotFindAnotherKit = FALSE ;
      bVeryLongHole = FALSE ;
      bHoleComplete = FALSE ;
      bIsOk = TRUE ;
      bLongHole = FALSE ;
      bHoleWithMill = FALSE ;

      nSolutionHole = nType ;
      bHoleInvert = OPT( nSolutionHole == nInvert, TRUE, FALSE) ;

      while ( nCont <= 60  AND ( C_vNomeForCorto[nCont] != ""  OR  C_vNomeForLungo[nCont] != "")) {
        // se kit di foratura
         if ( C_vDiamFor[nCont] > 0  AND  sKit == "") then {
            nPri = CheckPriSmallPiece( nPriorityHole) ;
           // controllo il tipo d iutensile in caso debba creare un foro con tolleranza
            GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
            GETTOOLDATA( sToolName, _ToolType, &nToolType) ;

            if ( C_vDiamFor[nCont] == nDiam) then {
              // alzo priorità in base all'ordine nella tabella
               nPri = nPri +  ( nCont * 100) ;
               
              // controllo per caso se potesse essere gruppo a forare
               nKitType = GETKITTYPE( C_vNomeForCorto[nCont]) ;
               if ( nKitType == _KitMdrill) then {
                 // posso lavorare solo se foro rivolto verso l'alto.
                 // Non posso andare a vedere le punte all'interno, quindi suppongo che siano corrette e che si possa lavorare il foro completamente
                  if ( $HI == 1) then {
                     sKit = C_vNomeForCorto[nCont] ;
                    // dico che il kit deve essere unito ad altri
                     SetKitJoin( TRUE) ;
                  }
                 // se il foro parte dal basso
                  elsif ( $HO == 1  AND  $HI == -6) then {
                     sNameHole = "AH11" ;
                     ADDAUXHOLE( "H01", sNameHole, TRUE) ;
                     sKit = C_vNomeForCorto[nCont] ;
                    // dico che il kit deve essere unito ad altri
                     SetKitJoin( TRUE) ;
                  }
                  else
                     bIsOk = FALSE ;
               }
              // casi standard
               elsif ( C_vNomeForCorto[nCont] != ""  AND
                     GETKITDATA( C_vNomeForCorto[nCont], _ToolMaxMat, 0, &nAffDrill)  AND
                     GETKITDATA( C_vNomeForCorto[nCont], _ToolDiam, 0, &nDiamUtensile)) then {

                 // cerco tra le frese inserite per recuperare i parametri
                  GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
                  GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
                  if ( nToolType == _TtMilling) then
                     bMatCompatible = GetToolParam( sToolName) ;

                 // se materiale compatibile inserisco utensile
                  if ( bMatCompatible) then {
                    // gestione speciale per punta da 65
                     bHoleSpe65 = TRUE ;
                     if ( C_vDiamFor[nCont] == 65 AND ABS( nAngle) != 0 AND ABS( nAngle) != 90) then
                        bHoleSpe65 = FALSE ;
                     if ( ( nLen + CalculateAddLen( C_vNomeForCorto[nCont], nAngle, nDiam, nDiamUtensile)) <= nAffDrill AND bHoleSpe65) then {
                        // se sotto i 50mm devo farlo con il centrino (a meno che non sia una fresa)
                        if ( STRSTR( C_vNomeForCorto[nCont], C_sPrefNoCentrino) == 0  OR  C_sPrefNoCentrino == "") then {
                           GETKITDATA( C_vNomeForCorto[nCont], _ToolType, 1, &nToolType) ;
                           if ( ( $ER < C_nMaxDepthFreCentrino OR nAffDrill > C_nLenLongHole)  AND  ( nToolType == _TtTip OR GETPARENTHOLE())) then
                              ExecuteCentering( nDiam, nAffDrill, nAngle, nPriorityHole) ;
                        }
                        if ( NOT( bHoleComplete)) then {
                           sKit = C_vNomeForCorto[nCont] ;
                           CheckTypeTool( C_vNomeForCorto[nCont], $Np) ;
                        }
                     }
                     elsif ( C_vNomeForLungo[nCont] != ""  AND
                        GETKITDATA( C_vNomeForLungo[nCont], _ToolMaxMat, 0, &nAffDrill)  AND
                        GETKITDATA( C_vNomeForLungo[nCont], _ToolDiam, 0, &nDiamUtensile)) then {
                        if ( ( STRSTR( C_vNomeForLungo[nCont], C_sPrefNoCentrino) == 0  OR  C_sPrefNoCentrino == "")  AND  nToolNumber < 2) then {
                           GETKITDATA( C_vNomeForLungo[nCont], _ToolType, 1, &nToolType) ;
                           if ( ( $ER < C_nMaxDepthFreCentrino OR nAffDrill > C_nLenLongHole)  AND  ( nToolType == _TtTip OR GETPARENTHOLE())) then
                              ExecuteCentering( nDiam, nAffDrill, nAngle, nPriorityHole) ;
                        }
                        if ( NOT( bHoleComplete)) then {
                           sKit = C_vNomeForLungo[nCont] ;
                           CheckTypeTool( C_vNomeForLungo[nCont], $Np) ;
                           if ( ( nLen + CalculateAddLen( C_vNomeForLungo[nCont], nAngle, nDiam, nDiamUtensile)) > nAffDrill) then
                              bIsOk = FALSE ;
                           bLongHole = TRUE ;
                          // dico che non posso lavorare da sopra perchè ho una punta lunghissima
                           if ( nAffDrill > C_nMaxLenLongHole) then
                              bVeryLongHole = TRUE ;
                        }
                     }
                     else {
                        nKitType = GETKITTYPE( C_vNomeForCorto[nCont]) ;
                        // se sotto i 50mm devo farlo con il centrino (a meno che non sia una fresa)
                        if ( STRSTR( C_vNomeForCorto[nCont], C_sPrefNoCentrino) == 0  OR  C_sPrefNoCentrino == "") then {
                           GETKITDATA( C_vNomeForCorto[nCont], _ToolType, 1, &nToolType) ;
                           if ( ( $ER < C_nMaxDepthFreCentrino OR nAffDrill > C_nLenLongHole OR C_bExecuteCenteringHole)  AND
                              ( nToolType == _TtTip  OR  GETPARENTHOLE())) then
                              ExecuteCentering( nDiam, nAffDrill, nAngle, nPriorityHole) ;
                        }
                        if ( NOT( bHoleComplete)) then {
                           sKit = C_vNomeForCorto[nCont] ;
                           CheckTypeTool( C_vNomeForCorto[nCont], $Np) ;
                           bIsOk = FALSE ;
                        }
                     }
                  }
               }
               elsif ( C_vNomeForLungo[nCont] != ""  AND
                  GETKITDATA( C_vNomeForLungo[nCont], _ToolMaxMat, 0, &nAffdrill)  AND
                  GETKITDATA( C_vNomeForLungo[nCont], _ToolDiam, 0, &nDiamUtensile)) {

                 // cerco tra le frese inserite per recuperare i parametri
                  GETKITDATA( C_vNomeForLungo[nCont], _ToolName, 1, &sToolName) ;
                  GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
                  if ( nToolType == _TtMilling) then
                     bMatCompatible = GetToolParam( sToolName) ;

                 // se materiale compatibile inserisco utensile
                  if ( bMatCompatible) then {
                     if ( ( STRSTR( C_vNomeForLungo[nCont], C_sPrefNoCentrino) == 0  OR  C_sPrefNoCentrino == "")  AND  nToolNumber < 2) then {
                        GETKITDATA( C_vNomeForLungo[nCont], _ToolType, 1, &nToolType) ;
                        if ( ( $ER < C_nMaxDepthFreCentrino OR nAffdrill > C_nLenLongHole)  AND  ( nToolType == _TtTip OR GETPARENTHOLE())) then
                           ExecuteCentering( nDiam, nAffdrill, nAngle, nPriorityHole) ;
                     }
                     if ( NOT( bHoleComplete)) then {
                        sKit = C_vNomeForLungo[nCont] ;
                        CheckTypeTool( sKit, $Np) ;
                        if ( ( nLen + CalculateAddLen( sKit, nAngle, nDiam, nDiamUtensile)) > nAffDrill) then
                           bIsOk = FALSE ;
                        bLongHole = TRUE ;
                       // dico che non posso lavorare da sopra perchè ho una punta lunghissima
                        if ( nAffDrill > C_nMaxLenLongHole) then
                           bVeryLongHole = TRUE ;
                     }
                  }
               }
            }
           // verifico se è possibile cambiare il diametro del foro restando nella tolleranza (solo per forature)
            elsif ( ( ( ABS( C_vDiamFor[nCont] - nDiam) < C_nToleranceHoleDrill  AND  nToolType == _TtTip)  OR  ( ABS( C_vDiamFor[nCont] - nDiam) < C_nToleranceHoleMill  AND  nToolType == _TtMilling))  AND
                  C_vNomeForCorto[nCont] != "") then {
               if ( GETKITTYPE( C_vNomeForCorto[nCont]) == _KitDrill) then {

                 // cerco tra le frese inserite per recuperare i parametri
                  GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
                  GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
                  if ( nToolType == _TtMilling) then
                     bMatCompatible = GetToolParam( sToolName) ;

                 // se materiale compatibile inserisco utensile
                  if ( bMatCompatible) then {
                     GETKITDATA( C_vNomeForCorto[nCont], _ToolMaxMat, 0, &nAffDrill) ;
                     GETKITDATA( C_vNomeForCorto[nCont], _ToolDiam, 0, &nDiamUtensile) ;
                     sNameHole = "AH99" ;
                     ADDAUXHOLE( "H01", sNameHole, FALSE, $ER, nDiamUtensile) ;

                    // se richiesto faccio preforo
                     if ( STRSTR( C_vNomeForCorto[nCont], C_sPrefNoCentrino) == 0  OR  C_sPrefNoCentrino == "") then {
                        GETKITDATA( C_vNomeForCorto[nCont], _ToolType, 1, &nToolType) ;
                        if ( ( $ER < C_nMaxDepthFreCentrino OR nAffDrill > C_nLenLongHole)  AND  ( nToolType == _TtTip OR GETPARENTHOLE())) then
                           ExecuteCentering( nDiam, nAffDrill, nAngle, nPriorityHole) ;
                     }

                     if ( ( nLen + CalculateAddLen( C_vNomeForCorto[nCont], nAngle, nDiam, nDiamUtensile)) <= nAffDrill) then {
                        sKit = C_vNomeForCorto[nCont] ;
                     }
                     else {
                        if ( C_vNomeForLungo[nCont] != ""  AND
                           GETKITDATA( C_vNomeForLungo[nCont], _ToolMaxMat, 0, &nAffdrill)  AND
                           GETKITDATA( C_vNomeForLungo[nCont], _ToolDiam, 0, &nDiamUtensile)) then {
                           GETKITDATA( C_vNomeForLungo[nCont], _ToolType, 1, &nToolType) ;
                           sKit = C_vNomeForLungo[nCont] ;
                        }
                        else {
                           sKit = C_vNomeForCorto[nCont] ;
                        }
                     }
                     if ( nToolType == _TtTip) then
                        nPri = CheckPriSmallPiece( nPriorityHole + ( 200 - ( nDiamUtensile * 1.5))) ;
                     CheckTypeTool( sKit, $Np) ;
                     if ( ( nLen + CalculateAddLen( sKit, nAngle, nDiam, nDiamUtensile)) > nAffDrill) then
                        bIsOk = FALSE ;
                  }
               }
            }
            if ( GETPARENTHOLE()  AND  bLongHole) then
               nPri = nPri - 1000 ;
         }
        // altrimenti svuotatura o contornatura
         elsif ( C_vDiamFor[nCont] < 0  AND  sKit == "") then {
            nPri = CheckPriSmallPiece( C_nPriFre) ;
            bHoleWithMill = TRUE ;
            if ( ABS( C_vDiamFor[nCont]) < nDiam) {

              // cerco tra le frese inserite per recuperare i parametri
               bToolFind = GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
               GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
               if ( nToolType == _TtMilling) then
                  bMatCompatible = GetToolParam( sToolName) ;

              // se materiale compatibile inserisco utensile
               if ( bMatCompatible) then {
                  bExecuteHole = FALSE ;

                  if ( GETKITDATA( C_vNomeForCorto[nCont], _ToolDiam, 0, &nDiamUtensile)) then {
                    // cerco tra le frese inserite per recuperare i parametri
                     nAffDrill = nToolLen ;

                     if ( ( nLen + CalculateAddLen( C_vNomeForCorto[nCont], nAngle, nDiam, nDiamUtensile)) < nAffDrill  AND  nDiamUtensile < nDiam) then {
                        ApplyInterpolatedHoleKit( nDiamUtensile, nDiam, C_vNomeForCorto[nCont]) ;
                        bExecuteHole = TRUE ;
                     }
                  }

                  if ( NOT( bExecuteHole)) then {
                     if ( GETKITDATA( C_vNomeForLungo[nCont], _ToolDiam, 0, &nDiamUtensile2)) then {
                       // cerco tra le frese inserite per recuperare i parametri
                        GETKITDATA( C_vNomeForLungo[nCont], _ToolName, 1, &sToolName) ;
                        GetToolParam( sToolName) ;
                        nAffDrill = nToolLen ;

                        if ( ( ( ( nLen + CalculateAddLen( C_vNomeForLungo[nCont], nAngle, nDiam, nDiamUtensile2)) < nAffDrill) OR  bCanDoubleHole)
                           AND  nDiamUtensile2 < nDiam) {
                           ApplyInterpolatedHoleKit( nDiamUtensile2, nDiam, C_vNomeForLungo[nCont]) ;
                           bExecuteHole = TRUE ;
                           if ( ( nLen + CalculateAddLen( C_vNomeForLungo[nCont], nAngle, nDiam, nDiamUtensile2)) > nAffDrill) then
                              bIsOk = FALSE ;
                        }
                     }
                  }

                  if ( NOT( bExecuteHole)) then {
                     if ( nDiamUtensile < nDiam) {
                       // cerco tra le frese inserite per recuperare i parametri
                        GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
                        GetToolParam( sToolName) ;
                        nAffDrill = nToolLen ;

                        ApplyInterpolatedHoleKit( nDiamUtensile, nDiam, C_vNomeForCorto[nCont]) ;
                        bExecuteHole = TRUE ;
                        if ( nLen + CalculateAddLen( C_vNomeForCorto[nCont], nAngle, nDiam, nDiamUtensile) > nAffDrill) then
                           bIsOk = FALSE ;
                     }
                  }
                 // se pareti setto lead-in/lead-out come da configurazione
                  SetLeadInOutCont( FALSE, C_nSheetLeadInType, C_nSheetLeadInType, &sKit) ;
               }
            }
           // verifico se è possibile cambiare il diametro del foro restando nella tolleranza (solo per forature)
            else {
               if ( GETKITTYPE( C_vNomeForLungo[nCont]) == _KitDrill) then {
                 // cerco tra le frese inserite per recuperare i parametri
                  bToolFind = GETKITDATA( C_vNomeForCorto[nCont], _ToolName, 1, &sToolName) ;
                  GETTOOLDATA( sToolName, _ToolType, &nToolType) ;
                  if ( nToolType == _TtMilling) then
                     bMatCompatible = GetToolParam( sToolName) ;

                 // se materiale compatibile inserisco utensile
                  if ( bMatCompatible) then {
                     GETKITDATA( C_vNomeForLungo[nCont], _ToolMaxMat, 0, &nAffDrill) ;
                     GETKITDATA( C_vNomeForLungo[nCont], _ToolDiam, 0, &nDiamUtensile) ;
                     if ( ABS( nDiamUtensile - nDiam) < C_nToleranceHoleMill  AND  C_vNomeForLungo[nCont] != "") then {
                        GETKITDATA( C_vNomeForLungo[nCont], _ToolType, 1, &nToolType) ;
                        if ( nToolType == _TtTip) then
                           nPri = CheckPriSmallPiece( nPriorityHole + ( 200 - ( nDiamUtensile * 1.5))) ;
                        sNameHole = "AH99" ;
                        ADDAUXHOLE( "H01", sNameHole, FALSE, $ER, nDiamUtensile) ;
                        sKit = C_vNomeForLungo[nCont] ;
                        CheckTypeTool( sKit, $Np) ;
                        if ( ( nLen + CalculateAddLen( sKit, nAngle, nDiam, nDiamUtensile)) > nAffDrill) then
                           bIsOk = FALSE ;
                     }
                  }
               }
            }
         }

         nCont = nCont + 1 ;
      }

     // se non ho trovato una punta che possa lavorare il foro provo con quelle per centrino
      if ( sKit == ""  AND  sKit2 == "") then {
         bNotFindAnotherKit = TRUE ;
         if ( NOT( ExecuteCentering( nDiam, nAffDrill, nAngle, nPriorityHole))) then
            bError = TRUE ;
         return 0 ;
      }

      nIngombro = CalculateAddLen( sKit, nAngle, nDiam, nDiamUtensile) ;
     // se l'ingombro è maggiore del massimo affondamento probabilmente il foro ha un' angolazione elevata
     // e quindi è praticamente impossibile lavorare

      if ( ( ABS( nIngombro) > ABS( $ER))  AND  ( ABS( nAffDrill) < ABS( $ER))) then {
         bError = TRUE ;
         return 0 ;
      }
      else {
         nIngombro = nAffDrill - CalculateAddLen( sKit, nAngle, nDiam, nDiamUtensile) ;
         if ( nLenFirstHole == 0) then {
            if ( nIngombro > ( $ER / 2) + 15 AND bCanDoubleHole AND nIngombro < $ER) then {
               nIngombroS = nAffDrill - CalculateAddLen( sKit, $HSO, nDiam, nDiamUtensile) ;
               if ( nIngombroS > ( $ER / 2) + 15) then {
                  nLenFirstHole = ( $ER / 2) + 10 ;
                  nLenSecondHole = ( $ER / 2) + 10 ;
                  nIngombro = nLenFirstHole ;
               }
               else
                  nLenFirstHole = nIngombro ;
            }
            else
               nLenFirstHole = nIngombro ;
         }
         else {
            if ( nLenSecondHole != 0) then
               nIngombro = nLenSecondHole ;
            else
               nLenSecondHole = nIngombro ;
         }
         nKitType = GETKITTYPE( sKit) ;
         if ( nKitType == _KitDrill) then
            SETKITMAXMAT( nIngombro) ;
         elsif ( ( nKitType == _KitCont OR nKitType == _KitPock)  AND  nIngombro < nLen) then
            SETKITDEPTH( nIngombro) ;
      }

     // imposto gli ultimi parametri per il kit
      if ( bCanInvert  AND  bHoleInvert) then
         bSuffInvert = TRUE ;
        
     // la priorità dei fori dipende dalla faccia e dal tipo di soluzione ( tanto tempo per cambiare soluzione (es. punte lunghe))
      if ( bHoleInvert) then
         nPri = nPri + SetPriorityHole( $HO) ;
      else
         nPri = nPri + SetPriorityHole( $HI) ;
      if ( bVeryLongHole  AND  bSuffSolOpp) then
         nPri = nPri - 10 ;

      if ( bIsOk) then
         return 1 ;
      else
         return -1 ;
   }


// ------------------- FUNZIONI PER TAGLI DI LAMA -----------------
   procedure SetPriorityBlade( vec3 vNormalFaceCut, string sNameFace)
   {
     // se non ho trovato la lama do errore
      if ( nBladeIndex == 0) then {
         OutputReport( _BcfWarnErr, "{sError} {$NaF}: {sErrParam}") ;
         nBladeIndex = 1 ;
      }

     // controllo tutte le feature dove voglio ridurre la priorità al massimo
      if ( ( $CL == 121  OR  $CaF == 1030) AND C_bExecRecessAsLastMach) then {
         nPri = CheckPriSmallPiece( 50 + C_vnAddPriMachBlade[nBladeIndex]) ;
         return ;
      }
      else
         nPri = CheckPriSmallPiece( C_nPriBla + C_vnAddPriMachBlade[nBladeIndex]) ;

     // se sono con taglio a cubetti non posso cambiare priorità ( a meno che non sia una feature lunga)
      if ( NOT( bCutCubetti)) then {
         GETFACEBOX( sNameFace, &ptMin, &ptMax) ;
        // se taglio ortogonale
         if ( $CL == 411  AND  ( nManagementFlag == _Hcut  OR  nManagementFlag == _Tcut)) then
            nPri = nPri + 5 + ( MAX( $HP, $MP) * C_nDeltaSquad) ;
        // se non ortogonali o altre feature
         if ( ( nPosXFeat >= ( $L - nReferenceDistance) AND $McLeftLoad) OR ( nPosXFeat < nReferenceDistance AND  NOT( $McLeftLoad))) then
            nPri = nPri + 10 ;

        // aggiusto priorità considerando fori passanti
         if (  NOT( bCubettiUsed)) then {
           // abbasso priorità lama per fare prima i fori che attraversano superfici (non su testa/coda)
            if ( $HP > 0  AND  ( nManagementFlag != _Hcut  AND  nManagementFlag != _Tcut)) then
               nPri = CheckPriSmallPiece( C_nPriFor - 1000 + C_vnAddPriMachBlade[nBladeIndex]) ;
         }
      }
      else {
        // se taglio ortogonale alzo priorità
         if ( $CL == 411  AND  ( nManagementFlag == _Hcut  OR  nManagementFlag == _Tcut)) then {
            nPri = nPri + 5 + ( MAX( $HP, $MP) * C_nDeltaSquad) ;
         }
        // se non ortogonali o altre feature
         if ( ( nPosXFeat >= ( $L - nReferenceDistance) AND $McLeftLoad) OR ( nPosXFeat < nReferenceDistance AND  NOT( $McLeftLoad))) then
            nPri = nPri + 10 ;
      }
   }


   procedure CheckBlade( num nTypeCut, vec3 vNormale, num nAltFaccia, num nLargFaccia, string sNameFaceCut)
   {

      if ( bCutCubetti  AND  NOT bFirstShell  AND  NOT bSplitRowPart) then {
        // se taglio normale passo valori come me li aspetto
         if ( nTypeCut == nNormal) then
            FindBlade( sNameFaceCut, TRUE, TRUE, nAltFaccia, nLargFaccia, 0, _bForceComplete) ;
        // altrimenti inverto altezza con larghezza
         else
            FindBlade( sNameFaceCut, TRUE, TRUE, nLargFaccia, nAltFaccia, 0, _bForceComplete) ;
      }
      elsif ( C_bHeadFromSide) then {
         if ( ( vNormale.y > 0  AND vNormale.z >= 0)  OR  ( vNormale.y < 0  AND vNormale.z < 0)) then
           // QQQ IN REALTA' BISOGNA FORZARE UTILIZZO LAMA PICCOLA
            FindBlade( sNameFaceCut, TRUE, TRUE, nAltFaccia, nLargFaccia, 0, _bForceComplete) ;
      }
      else {
        // cerco lama per tagliare da sopra
         FindBlade( sNameFaceCut, FALSE, TRUE, nAltFaccia, nLargFaccia, 0, _bForceComplete) ;
        // se non trovo provo a tagliare di fianco
         if ( nBladeIndex == 0) then {
            FindBlade( sNameFaceCut, FALSE, FALSE, nAltFaccia, nLargFaccia, 0, _bForceComplete) ;
            bBladeSide = TRUE ;
           // se non trovo nemmeno di fianco comunque forzo una lama anche se non completo
            if ( nBladeIndex == 0) then {
               FindBlade( sNameFaceCut, FALSE, TRUE, nAltFaccia, nLargFaccia, 0, _bForceNotComplete) ;
               bBladeSide = FALSE ;
            }
         }
      }
     // gestione speciale per favorire, dove possibile, il taglio corner speciale
      if ( C_nStrategyCut == 1) then {
         if ( nLargFaccia < ( nBladeMaxMat * 2)  AND  ( nPosXFeat < 5  OR  nPosXFeat > ($L - 5))  AND  vNormale.z == 0  AND  vNormale.y == 0) then
            bBladeSide  = TRUE ;
      }
      SetPriorityBlade( vNormale, sNameFaceCut) ;
   }

   procedure AddSpecialCut( string sFace, vec3 v3NormFaceCut, num nHor, num nAlt)
   {
      num    nAppDepth ;
      string sAppKit ;

      nAppDepth = 150 * SQRT( ( v3NormFaceCut.x * v3NormFaceCut.x) + ( v3NormFaceCut.y * v3NormFaceCut.y)) ;
     // deve prendere il punto minimo e massimo della faccia in lavorazione
      GETFACEBOX( sFace, &ptMin, &ptMax) ;
      sAppKit = C_vsNomeKitBlade[nBladeIndex] ;
      SETKITDEPTH( MIN( 5, nAppDepth - ( $T - ptMin.z))) ;
      SETKITZBENDING( MIN( 5, nAppDepth - ( $T - ptMin.z))) ;
      InsertKit( sAppKit, sFace, nPosXFeat, nPri) ;
   }


   procedure IncreaseFeedOnBlade( num nVEstension, string sKitTemp)
   {
      num nFeed ;

     // se non voglio aumentare esco subito
      if ( NOT( C_bIncreaseFeedBlade)) then
         return ;

      GETKITDATA( sKitTemp, _ToolFeed, 0, &nFeed) ;

      if ( nVEstension < nBladeMaxMat * 0.25) then
         nFeed = nFeed * 2 ;
      elsif ( nVEstension < nBladeMaxMat * 0.50) then
         nFeed = nFeed * 1.6 ;
      elsif ( nVEstension < nBladeMaxMat * 0.75) then
         nFeed = nFeed * 1.3 ;

      SETKITFEED( nFeed) ;
   }


   procedure SetParamBlade( num nType, num nHEstension, num nVEstension, vec3 v3NormFaceRif, bool bCorner, string sKitTemp, num nOverMat)
   {
      num nMaxMat = 0 ;
      num nDepth  = 0 ;
      num nZbend  = 0 ;
      num nDeltaL = 0 ;
      num nShell  = 0 ;

     // affondamento trasversale per taglio lama corner
      nDeltaL = -5 ;

     // CASO SPECIALE : se ho un taglio di separazione setto un affondamento minore perchè corro il rischio di toccare
     // la trave con la testa, infatti il motore si trova sopra il grezzo ( che in simulazione non è rappresentato)
      if ( nManagementFlag == _Tcut  AND  $T > 230  AND  NOT( bCorner)) then
         nDepth = 2 ;
      elsif ( nType == nNormal) then {
         nMaxMat = nBladeMaxMat ;
         if ( bCutCubetti) then {
            if ( bSplitRowPart  OR  bCutMore) then
               nDepth = 5 ;
            elsif ( bCutLess) then
               nDepth = OPT( ABS( v3NormFaceRif.z) < 0.707, -2, -0.1) ;
            else
               nDepth = 0 ;
         }
         elsif ( bCutNoDepth) then
            nDepth = 0 ;
         else {
           // se sono su tavola perpareti e non uso ventose posso scendere un po di più
            if ( C_bTableForWall  AND  NOT( C_bUseVacuum)) then
               nDepth = 0 ;
            else
               nDepth = 5 ;
            if ( bCorner) then
               SETKITDELTAL( nDeltaL) ;
         }
      }
      elsif ( nType == ( nNormal / 2)) then {
         nMaxMat = MIN( nBladeMaxMat, nHEstension/2 + 2) ;
         nDepth = 0 ;
      }
      elsif ( nType == nInvert) then {
         if ( /*bSplitRowPart AND*/ bCutMore AND bCorner) then
            SETKITDELTAL( nDeltaL) ;
         elsif ( bAcuteAngle AND bCorner) then {
            if ( ISSETVAR( $AS)) then {
               if ( $AS < 90) then
               SETKITDELTAL( nBladeThick / TAN( $AS) + 0.1) ;
            }
         }
         elsif ( bCutCubetti  AND  bCorner  AND  bCutLess) then
            SETKITDELTAL( 3) ;
         else {
            nMaxMat = nBladeMaxMat ;
            nDepth = 0 ;
         }
      }
      bCutNoDepth = FALSE ;
      nZbend = nDepth ;

     // se lama quasi orizzontale (oltre 85 deg da verticale) devo annullare l'affondamento
      if ( abs( v3NormFaceRif.z) >= 0.996) then {
         nDepth = 0 ;
         nZbend = 0 ;
      }

      SETKITMAXMAT( nMaxMat) ;
      SETKITDEPTH( nDepth) ;
      SETKITZBENDING( nZbend) ;

     // se non è zero setto il sovramateriale
      if ( nOverMat != 0) then
         SETKITOVERMAT( nOverMat) ;
     // se taglio dal sopra in una feature con taglio a cubetti
      if ( bCutCubetti  AND  NOT( bCorner)  AND  NOT( bSplitRowPart)) then {
        // recupero numero shell
         nShell = GetAdNumShell() ;
        // forzo elevazione. Se <30° dalla verticale passo la Z, altrimenti l'estensione della faccia
         if ( ABS( ASIN( v3NormFaceRif.z)) > 30) then
            SETKITRISE( nVEstension) ;
         else
            SETKITRISE( nVEstension*COS( ASIN( v3NormFaceRif.z))) ;
      }
     // se taglio convesso e sto lavorando seconda faccia, regolo elevazione
      elsif ( bSecondFaceCut  AND  ( $CL == 426 OR $CL == 425)) then {
         SETKITRISE( nVEstension) ;
      }

     // se la faccia è rivolta verso il basso devo cambiare soluzione
      if ( v3NormFaceRif.z < 0) then {
         if ( bCorner) then {
            if ( NOT( C_bNoDiffSolution)) then
               SETKITFLIPSOLUTION() ;
         }
         else
            SETKITFLIPSIDE( TRUE) ;
      }
     // verifico se devo aumentare la feed di lavoro
      if ( NOT( bCorner)) then
         IncreaseFeedOnBlade( nVEstension, sKitTemp) ;
   }

   function GetFirstFaceInList( string &sNew) : STRING
   {
      bool bOk ;
      string sFirst = "" ;

      bOk = GetFirstItemInList( &sNew, &sFirst) ;

      return sFirst ;
   }

  // controllo se ci sono sottofacce
   function VerifyMultipleFaces( num & nNFFace, string & sFaces) : BOOL
   {
      bool bMultF ;
      num nIndexF ;
      num nIndexSF ;
      string sFaceTemp ;

      nIndexF = 1 ;
      bMultF = FALSE ;
      sFaces = "" ;
      nNFFace = 0 ;
      while ( nIndexF <= MAX_FFACE) {
         nIndexSF = 1 ;
         while ( nIndexSF <= $Nsf[nIndexF]) {
            sFaceTemp = OPT( ( nIndexF < 10), Outstr( "F0{nIndexF}"), Outstr( "F{nIndexF}")) +
                        OPT( ( $Nsf[nIndexF] == 1), "", Outstr( "_{nIndexSF}")) ;
            sFaces = sFaces + OPT( sFaces == "", "", ",") + sFaceTemp ;
            if ( $Nsf[nIndexF] > 1) then
               bMultF = TRUE ;
            nIndexSF = nIndexSF + 1 ;
            nNFFace = nNFFace + 1 ;
         }
         nIndexF = nIndexF + 1 ;
      }
      return bMultF ;
   }

  // valori di ritorno:
  // 0: tutte le facce Z0, 1: tutte Z>0, 2: tutte Z<0, 3: facce 0 e Z>0, 4: facce 0 e Z<0, 5: Z>0 e Z<0, 6: Svuotatura, 7: impossibile
   function VerifyFaceAngle( string sFaces) : NUM
   {
      bool   bFind ;
      bool   bOk ;
      num    nTypeFeat = -1 ;
      string sFirstFaceInList ;
      vec3   v3FaceDir ;

      bFind = TRUE ;
      while ( bFind  AND  nTypeFeat < 5) {
         bOk = GetFirstItemInList( &sFaces, &sFirstFaceInList) ;
         if ( sFirstFaceInList != ""  AND  bOk) then {
            bFind = TRUE ;
            GETFACENORMAL( sFirstFaceInList, &v3FaceDir) ;
           // la prima volta
            if ( nTypeFeat < 0) then {
               nTypeFeat = OPT( v3FaceDir.z == 0, 0, OPT( v3FaceDir.z > 0, 1, 2)) ;
            }
           // calcolo tipologia feature
            if ( nTypeFeat == 0) then {
               if ( v3FaceDir.z > 0) then
                  nTypeFeat = 3 ;
               elsif ( v3FaceDir.z < 0) then
                  nTypeFeat = 4 ;
            }
            elsif ( nTypeFeat == 1) then {
               if ( v3FaceDir.z == 0) then
                  nTypeFeat = 3 ;
               elsif ( v3FaceDir.z < 0) then
                  nTypeFeat = 5 ;
            }
            elsif ( nTypeFeat == 2) then {
               if ( v3FaceDir.z == 0) then
                  nTypeFeat = 4 ;
               elsif ( v3FaceDir.z > 0) then
                  nTypeFeat = 5 ;
            }
            elsif ( nTypeFeat == 3) then {
               if ( v3FaceDir.z < 0) then
                  nTypeFeat = 5 ;
            }
            elsif ( nTypeFeat == 4) then {
               if ( v3FaceDir.z > 0) then
                  nTypeFeat = 5 ;
            }

           // devo fare la svuotatura
            if ( v3FaceDir.z > 0.766) then
               nTypeFeat = 6 ;

           // impossibile da lavorare
            if ( v3FaceDir.z < -0.866) then
               nTypeFeat = 7 ;
         }
         else
            bFind = FALSE ;
      }

      return nTypeFeat ;
   }

   function CheckToolPocket( num nDimVert, num nDimHoriz) : NUM
   {
      bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
      if ( bToolFind) then {
         sKit = C_sPrefSvuot + sToolKit ;
         return nToolLen ;
      }
      else
         return 0 ;
   }

   function GetOtherFaceOnSlot( num nNumFaceName) : STRING
   {
      num nFaces ;
      string sFace[6] = "" ;

      nFaces = GETCANONICFACES( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
      return sFace[nNumFaceName] ;
   }

   procedure InsertCornerHole( string sMainFace, string sSecondFace, string sNameHole)
   {
      bool bCanInsertHole = FALSE ;
      string sFace[6] = "" ;
      vec3   vec3NormalFace[6] ;
      vec3 v3DirHole ;


     // se non devo fare i fori di pulizia o su contorno libero esco
      if ( C_nSheetInsHoleOnCorner == _ForoNessuno  OR  ( $CL > 600  AND  $CL < 699)) then
         return ;

     // calcolo la direzione vettore cross tra le facce, casi in cui $Np fa riferimento alla faccia piana
      if ( NOT( ISSETVAR( $N2))  OR  $CL == 142  OR  $CL == 141  OR  $CL == 151) then
         v3DirHole = $Np ;
     // caso in cui $Np non si riferisce alla faccia piana
      elsif ( $CL == 131) then {
        // mi salvo le normali delle facce componenti la feature
         nI = 1 ;
         while ( nI <= 3) {
            sFace[nI] = GetOtherFaceOnSlot( nI) ;
            GETFACENORMAL( sFace[nI], &vec3NormalFace[nI]) ;
            nI = nI + 1 ;
         }
        // trovo la faccia principale e faccio cerco v3DirHole tra le rimanenti
         if ( vec3NormalFace[1].z == 1  OR  vec3NormalFace[1].z == -1) then {
            v3DirHole = CROSS( vec3NormalFace[2], vec3NormalFace[3]) ;
            sMainFace = sFace[2] ;
            sSecondFace = sFace[3] ;
         }
         elsif ( vec3NormalFace[2].z == 1  OR  vec3NormalFace[2].z == -1) then{
            v3DirHole = CROSS( vec3NormalFace[1], vec3NormalFace[3]) ;
            sMainFace = sFace[1] ;
            sSecondFace = sFace[3] ;
         }
         elsif ( vec3NormalFace[3].z == 1  OR  vec3NormalFace[3].z == -1) then{
            v3DirHole = CROSS( vec3NormalFace[1], vec3NormalFace[2]) ;
            sMainFace = sFace[1] ;
            sSecondFace = sFace[2] ;
         }
      }
     // caso speciale: se la normale calcolata ha versore x e y = 0, allora forzo la direzione z = 1
      elsif ( $CL == 221) then {
         v3DirHole = CROSS( $N1, $N2) ;
         if ( v3DirHole.x == 0 AND v3DirHole.y == 0) then
            v3DirHole.z = 1 ;
      }
      else
         v3DirHole = CROSS( $N1, $N2) ;

     // se corner perpendicolare alla base del pannello
      if ( ( v3DirHole.z == 1 OR v3DirHole.z == -1)  AND  C_nSheetInsHoleOnCorner == _Foro90) then
         bCanInsertHole = TRUE ;
     // se corner inclinato rispetto alla base del pannello
      elsif ( ( v3DirHole.z != 1 AND v3DirHole.z != -1)  AND  C_nSheetInsHoleOnCorner == _ForoIncl) then
         bCanInsertHole = TRUE ;
     // se corner qualsiasi
      elsif ( C_nSheetInsHoleOnCorner == _ForoTutti) then
         bCanInsertHole = TRUE ;

     // se posso inserire il foro di pulizia
      if ( bCanInsertHole) then {
        // setto i valori da utilizzare
         $HI = _Top ;
         $HO = _Bottom ;
         $HDI = $HI ;
         $HDO = $HO ;
         if ( AddCornerHole( sMainFace, sSecondFace, sNameHole, C_nSheetDiamCornerHole, C_nSheetOffHole)) then {
            FindKitHole( C_nSheetDiamCornerHole, $EL, 3, nNormal, C_nPriFor) ;

           // abilito minimizzazione dei rapidi
            if ( C_bDrillOptimize) then
               SETKITMOVEABLE( TRUE) ;

            InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
         }
         else
            OutputReport( _BcfWarn, "{sAttention} {sHole}: {$NaF} {sNotComplete}") ;
      }
   }


   function CountNumFaces( string sListFace) : NUM
   {
      num nTot = 0 ;
      string sFaceToCount ;

      while ( sListFace != "") {
         sFaceToCount = GetFirstFaceInList( &sListFace) ;
         if ( GETFACENORMAL( sFaceToCount, &v3Appo)) then
            nTot = nTot + 1 ;
      }

      return nTot ;
   }
   
   function SheetFindKitBlade( string sFaceCut, num nLenCut, num nAltCut, bool & bBladeUsed) : STRING
   {
      bool   bCalcCorner ;
      bool   bForceClosedPath = FALSE ;
      bool   bBladeFound ;
      bool   bInOtherFace ;
      bool   bMustToWork ;
      num    nMinDimFace ;
      num    nHExt ;
      num    nVExt ;
      num    nRExt ;
      num    nLenToKeep ;
      num    nTempLenToCut ;
      string sRealFaceCut ;
      string sNameFResult ;
      string sFaceResult ;

     // ordinamento lavorazioni
      nPri = CheckPriSmallPiece( C_nPriBla) ;
      GETFACENORMAL( sFaceCut, &v3Appo) ;
      bBladeFound = FindBlade( sFaceCut, FALSE, TRUE, nAltCut, nLenCut, 0, _bForceComplete) ;

     // se trovo la lama faccio i calcoli
      if ( bBladeFound) then {
        // setto la priorità
         nPri = CheckPriSmallPiece( C_nPriBla + C_vnAddPriMachBlade[nBladeIndex]) ;
        // se faccia contenuta in un'altra più grande, la salto
         bInOtherFace = VERIFYFACEINOTHERFACE( sFaceCut, nBladeThick, &sNameFResult, &sFaceResult) ;
         bMustToWork = STRSTR( sFacesMustToWork, $NaF + "\" + sFaceCut + ",") > 0 ;
         if ( NOT( bInOtherFace)  OR  bMustToWork) then {
           // ricalcolo la posizione
            GETFACEBOX( sFaceCut, &ptMin, &ptMax) ;
            nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
           // se prima i tagli in X
            if ( C_nPriBlaDir < 0  AND  ABS( v3Appo.y) >= ABS( v3Appo.x)) then
               nPri = CheckPriSmallPiece( C_nPriFre) - 500 ;
           // se prima quelli in Y
            elsif ( C_nPriBlaDir > 0  AND  ABS( v3Appo.x) >= ABS( v3Appo.y)) then
               nPri = CheckPriSmallPiece( C_nPriFre) - 500 ;

           // se non devo rispettare gli spigoli
            if ( C_nSheetBladeCut == 1) then {
               sKit = C_vsNomeKitBlade[nBladeIndex] ;
               SETKITDEPTH( C_nSheetAddDepth) ;
               nVotoFeature = 5 ;
               nMaxDiamUsedTool[$RotCurr + 1] = MAX( nMaxDiamUsedTool[$RotCurr + 1], nBladeThick) ;
               IncreaseFeedOnBlade( nAltCut, sKit) ;
               GETFACENORMAL( sFaceCut, &v3Appo) ;
               if ( v3Appo.z < 0) then
                  SETKITFLIPSIDE() ;
               InsertKit( sKit, sFaceCut, nPosXAppo, nPri) ;
               bBladeUsed = TRUE ;
            }
           // se devo fare solo con fresa
            elsif ( C_nSheetBladeCut == 5) then {
               sCornerMill = sFaceCut ;
            }
            else {
               if ( ( C_nSheetBladeCut == 3  OR  C_nSheetBladeCut == 4)  AND  $BcfStatus == _BcfFeaRot) then
                  bForceClosedPath = TRUE ;

               bCalcCorner = SheetCalcFaceToCut( sFaceCut, CalcCornerBlade( FALSE, nBladeDiam), bForceClosedPath,
                                                &sRealFaceCut, &sCornerMill, &bCenterCut) ;
               GETFACEHVREXT( sFaceCut, &nHExt, &nVExt, &nRExt) ;
              // se l'estensione della faccia è più piccola dell'impronta lama (da calcolare doppia sui due lati) faccio direttamente con fresa. Solo per tagli completamente interni
               if ( nHExt < ( ( CalcCornerBlade( FALSE, nBladeDiam) + 30) * OPT( CountNumFaces( sRealFaceCut) == 1, 2, 1))  AND  sCornerMill != "") then {
                 // se voglio lavorare con motosega
                  if ( C_nSheetBladeCut == 4) then {
                     nPri = CheckPriSmallPiece( 3000 + ( $MP * C_nDeltaSquad)) ;
                    // ricalcolo la posizione
                     GETFACEBOX( sFaceCut, &ptMin, &ptMax) ;
                     nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                    // controllo dimensione della faccia
                     GETFACEHVREXT( sFaceCut, &nHExt, &nVExt, &nRExt) ;

                    // controllo se riesco a lavorare con motosega
                     if ( nHExt > nLargMort) then {
                        nVotoFeature = 5 ;
                        InsertKit( C_sNameKitMortaise, sFaceCut, nPosXAppo, nPri) ;
                        sCornerMill = "" ;
                     }
                    // lavorarò con fresa
                     else
                        sCornerMill = sFaceCut ;
                  }
                 // lavorarò con fresa
                  else
                     sCornerMill = sFaceCut ;
               }
               elsif ( bCalcCorner) then {
                 // se la lavorazione parte in mezzo alla trave non posso lavorare
                  if ( $Pmax.z < ( $T - 10)) then {
                     sCornerMill = "" ;
                     OutputReport( _BcfWarnErr, "{sError} {$NaF}: {sNotExecute}") ;
                  }
                  else {
                     nMaxDiamUsedTool[$RotCurr + 1] = MAX( nMaxDiamUsedTool[$RotCurr + 1], nBladeThick) ;
                    // se non posso tagliare in centro lama ( quindi se non ci sono ostacoli)
                     if ( bCenterCut) then {
                        sKit = C_vsNomeKitBlade[nBladeIndex] ;
                        SETKITDEPTH( C_nSheetAddDepth) ;
                       // abilito minimizzazione dei rapidi
                        if ( C_bSheetEnableCutMoveable) then
                           SETKITMOVEABLE( TRUE) ;
                        nVotoFeature = 5 ;
                        IncreaseFeedOnBlade( nAltCut, sKit) ;
                        GETFACENORMAL( sRealFaceCut, &v3Appo) ;
                        if ( v3Appo.z < 0) then
                           SETKITFLIPSIDE() ;
                        InsertKit( sKit, sRealFaceCut, nPosXFeat, nPri) ;
                        bBladeUsed = TRUE ;
                     }
                     else {
                       // QQQ in futuro si può ottimizzare se riesco a sapere se l'automatismo ha inserito delle facce di prolungamento.
                       //  In questo caso la lunghezza da controllare è la faccia principale + il prolungamento.
                       // se ci sono 2 facce vuol dire che devo tener conto solo di un lato, altrimenti 2
                        if ( STRLEN( sRealFaceCut) > 4) then
                           nTempLenToCut = ( CalcCornerBlade( TRUE, nBladeDiam)) ;
                        else
                           nTempLenToCut = ( CalcCornerBlade( TRUE, nBladeDiam)) * 2 ;
                        if ( nTempLenToCut > nLenCut) then {
                           sCornerMill = sFaceCut ;
                        }
                        else {
                           sKit = C_vsNomeKitBlade[nBladeIndex] + C_sSuffBladeWind ;
                           SETKITDEPTH( C_nSheetAddDepth) ;
                          // abilito minimizzazione dei rapidi
                           if ( C_bSheetEnableCutMoveable) then
                              SETKITMOVEABLE( TRUE) ;
                           nVotoFeature = 5 ;
                           IncreaseFeedOnBlade( nAltCut, sKit) ;
                           GETFACENORMAL( sRealFaceCut, &v3Appo) ;
                           SETKITFLIPSIDE() ;
                           InsertKit( sKit, sRealFaceCut, nPosXFeat, nPri) ;
                           bBladeUsed = TRUE ;
                        }

                       // se devo fare angoli con la mortasatrice faccio subito
                        if ( C_nSheetBladeCut == 4  AND  sCornerMill != "") then {
                           nPri = CheckPriSmallPiece( 3000 + ( $MP * C_nDeltaSquad)) ;
                           while ( sCornerMill != "") {
                              GetFirstItemInList( &sCornerMill, &sAppo) ;
                             // ricalcolo la posizione
                              GETFACEBOX( sAppo, &ptMin, &ptMax) ;
                              nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;

                             // controllo dimensione della faccia
                              GETFACEHVREXT( sAppo, &nHExt, &nVExt, &nRExt) ;
                             // se troppo piccola provo a creare facce ausiliarie di prolungamento
                              if ( nHExt <= nLargMort) then {
                                // calcolo di quanto voglio prolungare la faccia
                                 nMinDimFace = nLargMort - nHExt + 5 ;

                                 SheetCalcFaceToCut( sAppo, nMinDimFace, bForceClosedPath, &sRealFaceCut, &sCornerMill, &bCenterCut) ;

                                 nLenToKeep = STRLEN(sRealFaceCut) - 1 ;
                                 sRealFaceCut = STRMID( sRealFaceCut, 1, nLenToKeep) ;
                                // se non ci sono vincoli
                                 if ( bCenterCut) then {
                                   // la faccia è piccola, quindi devo prolungare l'attacco e l'uscita
                                    SETKITLEADINTANG( nMinDimFace) ;
                                    SETKITLEADOUTTANG( nMinDimFace) ;
                                 }
                                 else {
                                   // se non riesco a prolungare do errore
                                    if ( sAppo == sRealFaceCut) then
                                       sAppo = "" ;
                                    else
                                       sAppo = sRealFaceCut ;
                                 }

                                 sCornerMill = "" ;
                              }

                             // setto lati lavorazione tutti nella stessa direzione
                             // se lato lavoro nel kit è destro setto la lavorazione dall'altro lato a sinistra.
                             // se lato lavoro nel kit è sinistro setto la lavorazione dall'altro lato a destra.
                              if ( C_bMortInvertSide) then {
                                 SETKITFLIPSIDE( TRUE) ;
                              }

                             // flag per lavorare sempre concorde o discorde in ogni taglio
                              if ( sCornerMill == ""  AND  C_bMortSameDir) then {
                                    SETKITGEOINVERT( TRUE) ;
                              }
                              
                             // inserisco lavorazione
                              if ( sAppo != "") then
                                 InsertKit( C_sNameKitMortaise, sAppo, nPosXAppo, nPri) ;
                              else
                                 OutputReport( _BcfWarn, "{sAttention} {$Naf}: {sNotComplete}") ;
                           }
                        }
                     }
                  }
               }
               else
                  OutputReport( _BcfWarnErr, "{sError} {$NaF}: {sErrParam}") ;
            }
         }
        // aggiungo faccia ad elenco facce da lavorare per forza
         if ( sNameFResult != ""  AND  sFaceResult != "") then
            sFacesMustToWork = sFacesMustToWork + sNameFResult + "\" + sFaceResult + "," ;
      }
      else
         sCornerMill = sFaceCut ;

     // ritorno eventuali facce da lavorare
      return sCornerMill ;
   }

   function FindMillIndexFromKit( string sKitToSearch) : NUM
   {
      num nIndexMill ;

      nIndexMill = 0 ;
      nI = 1 ;
      while( nI <= 15) {
         if ( STRSTR( sKitToSearch, C_vsNomeKit[nI]) > 0) then {
            nIndexMill = nI ;
           // esco dal ciclo
            nI = 16 ;
         }
         nI = nI + 1 ;
      }
      return nIndexMill ;
   }

   function ExecAngledCont( string sList) : BOOL
   {
      bool   bFirstAngledFace = FALSE ;
      bool   bVertFace = FALSE ;
      num    nBAngle ;
      num    nCAngle ;
      num    nTotFaces = 0 ;
      string sFace ;
      string sAppoList ;
      vec3   v3AppoDir ;
      vec3   v3AppoDirPrec ;

     // se non abilitato (o se la macchina non lo permette) esco subito
      if ( NOT( C_bAngledContEnb)) then
         return FALSE ;

      sAppoList = sList ;

      GetFirstItemInList( &sAppoList, &sFace) ;

     // cerco faccia inclinata e calcolo tutto su quella (se ho due facce inclinate do errore)
      while ( sFace != "") {
         nTotFaces = nTotFaces + 1 ;
         GETFACENORMAL( sFace, &v3AppoDir) ;
        // controllo direzione normale della faccia
         if ( v3AppoDir.z != 0) then {
           // se ne ho già trovata una esco subito e faccio lavorazione a 5 assi
            if ( bFirstAngledFace  AND  ABS( ABS( v3AppoDirPrec.z) - ABS(v3AppoDir.z)) > 0.01) then
               return FALSE ;

            bFirstAngledFace = TRUE ;
            v3AppoDirPrec = v3AppoDir ;
            nBAngle = - ASIN( v3AppoDir.z) ;
            nCAngle = ATAN2( v3AppoDir.y, v3AppoDir.x) ;
         }
         else
            bVertFace = TRUE ;

         GetFirstItemInList( &sAppoList, &sFace) ;
      }

     // devo controllare che la prima faccia sia verticale (altrimenti la contornatura prende l'inclinazione della faccia, ma la lavorazione sarebbe sbagliata)
      if ( bVertFace  OR  nTotFaces == 1) then {
         GetFirstItemInList( &sList, &sFace) ;
         GETFACENORMAL( sFace, &v3AppoDir) ;
         if ( v3AppoDir.z != 0) then
            sList = sList + "," + sFace ;
         else
            sList = sFace + "," + sList ;
      }
     // se non ci sono facce verticali provo a mettere direzione nessuna e do il messaggio
      else {
         OutputReport( _BcfWarn, "{sAttention} : {$NaF} {sNotComplete}") ;
      }

     // setto direzione Z+ globale
      SETKITDIR( 15) ;

     // setto altro lato della superficie
      SETKITOTHERSIDE( TRUE) ;
      SETKITDEPTH( ( $T - $Pmin.z) + C_nSheetAddDepth) ;

      SETKITPARAM( 1, nCAngle) ;
      SETKITPARAM( 2, nBAngle) ;

      InsertKit( C_sPrefCont + sToolKit + C_sSuffAngledCont, sList, nPosXFeat, nPri) ;

     // dico che ho lavorato come contornatura di fianco, quindi non è necessaria la lavorazione a 5 assi.
      return TRUE ;
   }

   procedure InsertEdgeFinish( string sFacesToFinish)
   {
      bool   bOk ;
      num    nLenSideUp ;
      num    nLenSideDown ;
      num    nNumFaces = 0 ;
      string sNewFaceName ;
      string sNewListTemp ;
      string sFirstFaceInList ;

     // se non ci sono facce o non voglio pulizia esco subito. La pulizia si fa solo sui ribassi
      if ( sFacesToFinish == ""  OR  NOT( C_bSheetEdgeFinish) OR  ( $CL < 100  OR  $CL > 200)) then
         return ;

      sNewListTemp = sFacesToFinish ;
     // fino a che ci sono facce accodate in lista
      while ( sNewListTemp != "") {
         nNumFaces = nNumFaces + 1 ;
         GetFirstItemInList( &sNewListTemp, &sFirstFaceInList) ;
        // trasformo in rigata
         bOk = FACETORULED( sFirstFaceInList, _NearZp, &sNewFaceName, &nLenSideUp, &nLenSideDown) ;
         if ( bOk) then {
           // se la faccia ha lato inferiore o superiore nulli non è da considerare nella lav5a
            if ( nLenSideUp < 2  OR  nLenSideDown < 2) then
               sNewFaceName = "" ;
            sFacesToFinish = STRGSUB( sFacesToFinish, sFirstFaceInList, sNewFaceName) ;
         }
      }
     // faccio pulizia solo se ho più di una faccia e se la sfinestratura è grande oppure ha solo 2 facce
      if ( nNumFaces > 1  AND  ( $EW > 500 OR  $CL == 121)) then {
        // prima della pulizia devo mettere una pausa per la rimozione dell'eventuale sfrido. Devo controllare per mettere la pausa solo una volta!
         if ( NOT( bGlobPause)) then {
            InsertKit( C_sNamePause, sFacesToFinish, nPosXFeat, 2) ;
            bGlobPause = TRUE ;
         }
        // la lavorazione deve essere fatta alla fine
         InsertKit( C_sSheetKitEdgeFinish, sFacesToFinish, nPosXFeat, 1) ;
      }
   }

   function IsThereSmallFace( string sFacesToCheck, num nDiamTool) : BOOL
   {
      num nHExt ;
      num nVExt ;
      num nRExt ;

      while ( sFacesToCheck != "") {
         GetFirstItemInList( &sFacesToCheck, &sAppo) ;
         GETFACEHVREXT( sAppo, &nHExt, &nVExt, &nRExt) ;
         if ( nHExt < nDiamTool) then
            return TRUE ;
      }
      return FALSE ;
   }

   procedure SheetExecContMill( string sFaceCut, bool bBladeUsed, num nForceOverMat)
   {
      bool   bFind ;
      bool   bAdjacent = TRUE ;
      bool   b5AOk = TRUE ;
      bool   bOk ;
      num    nCont ;
      num    nJ ;
      num    nDiam ;
      num    nLenSideUp ;
      num    nLenSideDown ;
      num    nDiamTool5a ;
      num    nIndexTool5A ;
      num    nNumTotFace ;
      num    nNumTotAdjacency ;
      num    nNumTotAdjacencyTemp ;
      num    nNumFace ;
      string sFace1 ;
      string sFace2 ;
      string sFaceList ;
      string sFaceListTemp ;
      string sFirstFaceInList ;
      string sNewFaceName ;
      string sNewList ;
      string sNewListTemp ;
      string sFaceCutTemp ;
      string sSlotFaces[100] ;
      string sNewListTemp ;
      string sFirstFaceInList ;

     // se lavoro solo con la lama non serve processare gli spigoli, oppure non ho trovato utensile
      if ( sFaceCut == ""  OR  sFaceCut == ","  OR  C_nSheetBladeCut <= 2  OR  nToolIndex == 0) then
         return ;

      GETTOOLDATA( C_vsNomeUte[nToolIndex], _ToolDiam, &nDiam) ;
      nMaxDiamUsedTool[$RotCurr + 1] = MAX( nMaxDiamUsedTool[$RotCurr + 1], nDiam) ;

      // controllo solo se sto lavorando: Contorni liberi, Tagli di lama, Tagli longitudinali
      if ( C_bCheckMillDiam) then {
         if ( ( $Cl >= 600  AND  $Cl <= 699)  OR  ( $Cl >= 400  AND  $Cl <= 499)  OR  ( $CL >= 300  AND  $CL <= 399)) then {
           // tolgo dalla lista le facce che vanno in collisione
            sNewListTemp = sFaceCut ;
            sFaceCut = "" ;
            while( sNewListTemp != "") {
               GetFirstItemInList( &sNewListTemp, &sNewList) ;
               if ( VERIFYFACEFREEDISTANCE( sNewList, nDiam)) then
                  sFaceCut = sFaceCut + OPT( sFaceCut == "", "", ",") + sNewList ;
            }
         }
      }

     // se non ancora calcolata, ricalcolo
      if ( g_nFeatFaceDir < 0) then
         g_nFeatFaceDir = VerifyFaceAngle( sFaceCut) ;

     // se le facce sono tutte verticali lavoro tutte assieme come contornatura
      if ( g_nFeatFaceDir == 0) then {
        // fino a che ho facce da lavorare
         while ( sFaceCut != "") {
            bAdjacent =FALSE ;
            sFeatureFaces = "" ;
           // prendo prima faccia
            sFaceList = GetFirstFaceInList( &sFaceCut) ;
            while ( sFaceCut != "") {
              // prendo la prima delle facce restanti
               sFaceListTemp = GetFirstFaceInList( &sFaceCut) ;
              // controllo se la faccia esiste
               if ( NOT( GETFACENORMAL( sFaceListTemp, &v3Appo))) then
                  sFaceListTemp = "" ;

              // salvo in una stringa le facce adiacenti da lavorare
               sFace2 = sFaceList ;
               while ( sFace2 != ""  AND  sFaceListTemp != "") {
                 // confronto la prima faccia della lista delle restanti e la confronto con tutte le facce adiacenti da lavorare
                  sFace1 = GetFirstFaceInList( &sFace2) ;
                  if ( VERIFYFACESADJACENCY( sFaceListTemp, sFace1)) then {
                     bAdjacent = TRUE ;
                    // se ho trovato una nuova adiacenza devo ricontrollare ancora tutte quelle che ho già scartato, perchè potrebbero essere adiacenti alla nuova appena controllata
                     if ( sFaceCut != "") then
                        sFaceCut = sFaceCut + OPT( STRSTR( STRMID( sFaceCut, STRLEN(sFaceCut), STRLEN(sFaceCut)+1), ",") > 0, "", ",") + sFeatureFaces ;
                     else
                        sFaceCut = sFeatureFaces ;
                     sFeatureFaces = "" ;
                     sFace2 = "" ;
                  }
               }

              // metto la faccia nella stringa in base all'adiacenza
               if ( bAdjacent) then
                  sFaceList = sFaceList + OPT( sFaceList == "", "", ",") + sFaceListTemp ;
               else
                  sFeatureFaces = sFeatureFaces + OPT( sFeatureFaces == "", "", ",") + sFaceListTemp ;

               bAdjacent = FALSE ;
            }
            sFaceCut = sFeatureFaces ;
            nPri = CheckPriSmallPiece( C_nPriFre) ;
            if ( nToolIndex > 0) then
               nPri = nPri + C_vnAddPriMach[nToolIndex] ;

            nVotoFeature = 3 ;

           // se percorso chiuso l'attacco deve essere perpendicolare
            if ( $CL == 142  AND  NOT( bBladeUsed)) then {
              // controllo se con due passate riesco a svuotarlo ( da preferire alle tab)
               if ( ( ( nToolDiam-4) * 2) <= $EW  AND  ( ( nToolDiam-4) * 2) <= $ER) then {
                 // verifico se fare doppi apassata
                  if ( ( ( nToolDiam-4) * 4) >= $EW  OR  ( (nToolDiam-4) * 4) >= $ER) then {
                    // ricalcolo la posizione delle facce che sto lavorando
                     sNewListTemp = sFaceList ;
                     GetFirstItemInList( &sNewListTemp, &sFirstFaceInList) ;
                     GETFACEBOX( sFirstFaceInList, &ptMin, &ptMax) ;
                     nPosXAppo = ( ptMin.x + ptMax.x) / 2 ;
                     nPosYAppo = ( ptMin.y + ptMax.y) / 2 ;
                     SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                     SETKITDEPTH( C_nSheetAddDepth) ;
                     SETKITOVERMAT( MIN( nToolDiam-3, MAX( ( MIN( $EW, $ER) - ( nToolDiam * 2)) / 1.5, 5))) ;
                    // abilito minimizzazione dei rapidi
                     if ( C_bSheetEnableCutMoveable) then
                        SETKITMOVEABLE( TRUE) ;
                     InsertKit( C_sPrefCont + sToolKit, sFaceList, nPosXAppo, nPri) ;
                  }
                 // altrimenti faccio le TAB
                  elsif ( ( ( nToolDiam-4) * 4) < $EW  AND  ( (nToolDiam-4) * 4) < $ER  AND  C_bUseTabs) then {
                    // METTERE PARAMETRI IN CONFIGURAZIONE
                     SETKITTAB( 1, 350, 0, 0, 10, 150, 45) ;
                     SETKITSMOOTHPATH( 1) ;
                  }
               }
            }
           // se contorno libero controllo verso di percorrenza
            elsif ( $CL == 611  OR  $CL == 612  OR  $CL == 619) then {
              // se il lato di lavoro è destra o centro devo invertire
               if ( $P02 == 0  OR  $P02 == 2) then
                  SETKITFLIPSIDE( TRUE) ;
            }

            nPri = CheckPriSmallPiece( C_nPriFre) ;
            if ( nToolIndex > 0) then
               nPri = nPri + C_vnAddPriMach[nToolIndex] ;

            nVotoFeature = 3 ;
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
            if ( nForceOverMat != 0) then
               SETKITOVERMAT( nForceOverMat) ;
           // ricalcolo la posizione delle facce che sto lavorando
            sNewListTemp = sFaceList ;
            GetFirstItemInList( &sNewListTemp, &sFirstFaceInList) ;
            GETFACEBOX( sFirstFaceInList, &ptMin, &ptMax) ;
            nPosXAppo = ( ptMin.x + ptMax.x) / 2 ;
            nPosYAppo = ( ptMin.y + ptMax.y) / 2 ;

           // se c'è una faccia piccola devo per forza mettere flag "arrotonda percorso"
            if ( IsThereSmallFace( sFaceList, nToolDiam)) then
               SETKITSMOOTHPATH( 1) ;

           // se l'utensile non riesce a lavorare completamente limito affondamento (prendo solo la prima faccia, sono tutte alla stessa profondità)
            nAppo = STRSTR( sFaceList, ",") ;
            sAppo = STRMID( sFaceList, 1, OPT( nAppo == 0, STRLEN( sFaceList), nAppo - 1)) ;
            if ( NOT( GETFACEHVREXT( sAppo, &nEaH, &nEaV, &nEaR))) then {
               nEaH = 0 ;
               nEaV = 0 ;
               nEaR = 0 ;
               SetLeadInOutCont( FALSE, _Clg_Nessuno, _Clg_Nessuno, &sKit) ;
            }
            if ( nEaV > ( nToolLen - C_nSheetAddDepth)) then
               SETKITDEPTH( nToolLen - nEaV) ;
            else {
              // se passante posso aggiungere un eventuale affondamento ulteriore
               if ( ( $Pmax.z - $Pmin.z) == $T) then
                  SETKITDEPTH( C_nSheetAddDepth) ;
            }
            InsertKit( C_sPrefCont + sToolKit, sFaceList, nPosXAppo, nPri) ;
            InsertEdgeFinish( sFaceList) ;
         }
      }
     // altrimenti lavoro a 5 assi solo a gruppi di facce adiacenti
      else {
        // fino a che ci sono facce da lavorare
         while( sFaceCut != "") {
           // gestione speciale per classe 142 non multifaccia
            if ( $CL == 142  AND NOT( bMultFace)  AND  STRSTR( sFaceCut, "F01") > 0) then {
               sFaceList = sFaceCut ;
               sFaceCut = "" ;
            }
           // casi standard
            else {
              // recupero nome facce : metto la stringa in un array
               sFeatureFaces = sFaceCut ;
               nNumTotFace = 0 ;
               while ( sFeatureFaces != "") {
                  nNumTotFace = nNumTotFace + 1 ;
                  sSlotFaces[nNumTotFace] = GetFirstFaceInList( &sFeatureFaces) ;
               }

               if ( nNumTotFace == 1) then {
                  sFaceList = sFaceCut ;
                  GETFACENORMAL( sFaceList, &v3Appo) ;
                 // se la faccia è più inclinata di 80° allora faccio svuotatura con la fresa di testa
                  if ( v3Appo.z > 0.984) then {
                     ExecPockOnFace( sFaceList, nOpenFeat) ;
                     sFaceList = "" ;
                     sFaceCut = "" ;
                  }
               }

              // testo l'adiacenza faccia con faccia
               if ( $CL > 600  AND  $CL < 699) then {
                  sFaceCut = "" ;
                  nCont = 1 ;
                 // testo l'adiacenza con tutte le facce
                  sFaceList = sSlotFaces[nCont] ;
                  bAdjacent = TRUE ;
                  while ( nCont < nNumTotFace  AND  bAdjacent) {
                    // se le facce sono concatenate le lavoro tutte assieme
                     if ( VERIFYFACESADJACENCY( sSlotFaces[nCont], sSlotFaces[nCont+1])) then
                        sFaceList = sFaceList + "," + sSlotFaces[nCont+1] ;
                     elsif ( nCont <= (100 - 2)) then {
                        if ( sSlotFaces[nCont+2] != ""  AND VERIFYFACESADJACENCY( sSlotFaces[nCont], sSlotFaces[nCont+2])) then {
                           sFaceList = sFaceList + "," + sSlotFaces[nCont+2] ;
                          // scambio le facce
                           sAppo = sSlotFaces[nCont+1] ;
                           sSlotFaces[nCont+1] = sSlotFaces[nCont+2] ;
                           sSlotFaces[nCont+2] = sAppo ;
                        }
                        else
                           bAdjacent = FALSE ;
                     }
                    // esco dal ciclo
                     else
                        bAdjacent = FALSE ;
                     nCont = nCont + 1 ;
                  }
                 // se uscito dal ciclo perchè le facce non sono adiacenti torno indietro con il contatore faccia
                  if ( NOT( bAdjacent)) then
                     nCont = nCont - 1 ;
                 // tutte le altre facce le salvo nell'altro array
                  sFaceCut = "" ;
                  while ( nCont < nNumTotFace) {
                     sFaceCut = sFaceCut + OPT( sFaceCut == "", "", ",") + sSlotFaces[nCont+1] ;
                     nCont = nCont + 1 ;
                  }
               }
               else {
                  sFaceCut = "" ;
                  nNumTotAdjacency = -1 ;
                  nCont = 1 ;
                 // testo l'adiacenza con tutte le facce
                  while ( nCont <= nNumTotFace) {
                     sFaceListTemp = sSlotFaces[nCont] ;
                     sFaceCutTemp = "" ;
                     nJ = 1 ;
                     while ( nJ <= nNumTotFace) {
                        if ( sSlotFaces[nCont] != sSlotFaces[nJ]) then {
                           if ( VERIFYFACESADJACENCY( sSlotFaces[nCont], sSlotFaces[nJ])) then {
                              nNumTotAdjacencyTemp = nNumTotAdjacencyTemp + 1 ;
                              sFaceListTemp = sFaceListTemp + "," + sSlotFaces[nJ] ;
                           }
                           else {
                              sFaceCutTemp = sFaceCutTemp + OPT( sFaceCutTemp == "", "", ",") + sSlotFaces[nJ] ;
                           }
                        }
                        nJ = nJ + 1 ;
                     }
                    // prendo la faccia con più adiacenze
                     if ( nNumTotAdjacencyTemp > nNumTotAdjacency) then {
                        nNumTotAdjacency = nNumTotAdjacencyTemp ;
                        nNumTotAdjacencyTemp = 0 ;
                        sFaceList = sFaceListTemp ;
                        sFaceCut = sFaceCutTemp ;
                     }
                     nCont = nCont + 1 ;
                  }
               }
            }

           // trasformo le facce adiacenti in superfici
            bAdjacent = TRUE ;
            bFind = TRUE ;
            sNewListTemp = sFaceList ;
           // fino a che ci sono facce accodate in lista
            while ( bFind) {
               bOk = GetFirstItemInList( &sNewListTemp, &sFirstFaceInList) ;
               if ( sFirstFaceInList != ""  AND  bOk) then {
                  bFind = TRUE ;
                 // trasformo in rigata
                  bOk = FACETORULED( sFirstFaceInList, _NearZp, &sNewFaceName, &nLenSideUp, &nLenSideDown) ;
                  if ( bOk) then {
                    // se la faccia ha lato inferiore o superiore nulli non è da considerare nella lav5a
                     if ( nLenSideUp < 2  OR  nLenSideDown < 2) then
                        sNewFaceName = "" ;
                     sFaceList = STRGSUB( sFaceList, sFirstFaceInList, sNewFaceName) ;
                  }
                  else
                     bFind = FALSE ;
               }
               else
                  bFind = FALSE ;
            }

           // se non posso fare con contornatura con angolo di fianco, faccio con 5 assi
            if ( NOT( ExecAngledCont( sFaceList))) then {
              // controllo se esiste fresa a 5 assi
               if ( ( C_sPref5a + sToolKit) != "") then {
                  nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                  nVotoFeature = 3 ;
                 // applico lavorazioni a 5 assi
                  InsertKit( C_sPref5a + sToolKit, sFaceList, nPosXFeat, nPri) ;
                 // recupero diametro fresa
                  bFind = GETKITDATA( C_sPref5a + sToolKit, _ToolDiam, 1, &nDiamTool5a) ;
                  if ( bFind) then
                     nMaxDiamUsedTool[$RotCurr + 1] = nDiamTool5a ;
                  else
                     b5AOk = FALSE ;
               }
               else {
                 // se è solo una faccia posso lavorarlo come contornatura 3 assi
                  sFaceCutTemp = sFaceList ;
                  nCont = 0 ;
                  while ( sFaceList != "") {
                     GetFirstItemInList( &sFaceList,  &sAppo) ;
                     nCont = nCont + 1 ;
                  }
                  if ( nCont == 1) then {
                    // se contorno libero controllo verso di percorrenza
                     if ( $CL == 611  OR  $CL == 612  OR  $CL == 619) then {
                       // se il lato di lavoro è destra o centro devo invertire
                        if ( $P02 == 0  OR  $P02 == 2) then
                           SETKITFLIPSIDE( TRUE) ;
                     }

                     nPri = CheckPriSmallPiece( C_nPriFre) ;
                     if ( nToolIndex > 0) then
                        nPri = nPri + C_vnAddPriMach[nToolIndex] ;

                     nVotoFeature = 3 ;
                     SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                     InsertKit( C_sPrefCont + sToolKit, sFaceCutTemp, nPosXFeat, nPri) ;
                  }
                  else
                     b5AOk = FALSE ;
               }
            }
         }
        // se 5 assi non andato a buon fine, errore
         if ( NOT( b5AOk)) then
            OutputReport( _BcfWarn, "{sAttention} {sFreeContour}: {$Naf} {sNotComplete}") ;
      }
   }

   procedure ExecContMultFace()
   {
      bool   bFlatFace ;
      bool   bToWork ;
      bool   bBladeUsed = FALSE ;
      num    nHExt ;
      num    nVExt ;
      num    nRExt ;
      num    nIndexF ;
      num    nIndexSF ;
      num    nTypeSide ;
      string sFaces ;
      string sFaceToCalc ;
      string sTotFromFaces ;
      string sTotFaces ;
      string sFaceFromFace ;
      vec3   ptMin ;
      vec3   ptMax ;

      sTotFromFaces = "" ;
      nIndexF = 1 ;
      bBladeUsed = FALSE ;

      while ( nIndexF <= MAX_FFACE) {
         nIndexSF = OPT( C_bCutCWDir, 1, $Nsf[nIndexF]) ;
         while ( ( nIndexSF <= $Nsf[nIndexF] AND  C_bCutCWDir)  OR ( nIndexSF > 0 AND  NOT( C_bCutCWDir))) {
            bFlatFace = TRUE ;
            sFaces = OPT( ( nIndexF < 10), Outstr( "F0{nIndexF}"), Outstr( "F{nIndexF}")) +
                     OPT( ( $Nsf[nIndexF] == 1), "", Outstr( "_{nIndexSF}")) ;
           // salvo la prima faccia per trovare la fresa
            if ( sFaceToCalc == "") then
               sFaceToCalc = sFaces ;

           // se sono sul fianco non lavoro
            bToWork = TRUE ;
            if ( $IsSheet  AND  C_bSheetSideNotToWork) then {
              // se non riesco a recuperare i dati, devo lavorare
               if ( GETFACEBOX( sFaces, &ptMin, &ptMax)) then {
                  if ( ptMax.y < 0.5  OR  ptMin.y > ( $W - 0.5)  OR  ptMax.x < 0.5  OR  ptMin.x > ( $L - 0.5)) then
                     bToWork = FALSE ;
               }
            }

           // se devo lavorare decido se con lama o con fresa
            if ( bToWork) then {
              // se devo lavorare con la fresa salto controlli impronta lama
               if ( C_nSheetBladeCut == 5) then {
                  sFaceFromFace = sFaces ;
               }
               else {
                 // controllo se faccia piatta o non piatta (solo se profilo libero)
                  if ( $CL > 600  AND  $CL < 699) then
                     bFlatFace = OPT( $FcTy[nIndexSF] == 1, TRUE , FALSE) ;

                  GETFACEHVREXT( sFaces, &nHExt, &nVExt, &nRExt) ;
                 // se la faccia è piana e sono su sheet controllo se posso lavorare con lama
                  if ( bFlatFace /* AND  ( CalcCornerBlade( TRUE, nBladeDiam) + 30 < nHExt  OR  C_nSheetBladeCut == 4)*/) then
                     sFaceFromFace = SheetFindKitBlade( sFaces, nHExt, nVExt, &bBladeUsed) ;
                  else
                     sFaceFromFace = sFaces ;
               }
            }
            nIndexSF = OPT( C_bCutCWDir, nIndexSF+1, nIndexSF-1) ;
           // se ho delle facce da lavorare le accodo
            if ( sFaceFromFace != "") then {
               sTotFromFaces = sTotFromFaces + sFaceFromFace + "," ;
               sFaceFromFace = "" ;
            }
         }
        // se ho delle facce da lavorare le accodo
         if ( sTotFromFaces != "") then {
            sTotFaces = sTotFaces + sTotFromFaces ;
            sTotFromFaces = "" ;
         }
         nIndexF = nIndexF + 1 ;
      }

     // verifico tipologia feature
      if ( $CL > 130  AND  $CL < 160) then
         nTypeSide = nRadiusFeat ;
      else
         nTypeSide = nOpenFeat ;

     // lavoro gli spigoli tutti assieme
      bToolFind = FindTool( nTypeSide, nProfil, 1, sFaceToCalc, sFaceToCalc, _TypeTMach_Rib, _nForceToolToUse) ;
      SheetExecContMill( sTotFaces, bBladeUsed, 0) ;

   }

   procedure ExecCornerHoleSheet( num nNumTotFace, bool bOpenHole)
   {
      num nCont ;
      num nJ ;
      num nIndexHole = 1 ;
      string sSlotFaces[100] ;

     // se foro passante ma devo lavorare SOLO quelli chiusi, esco
      if ( bOpenHole AND C_nSheetTypeHole == 3) then
         return ;
     // se foro chiuso ma devo lavorare SOLO quelli passanti, esco
      elsif ( NOT( bOpenHole) AND C_nSheetTypeHole == 2) then
         return ;

     // recupero nome facce : metto la stringa in un array
      nCont = 1 ;
      while ( nCont <= nNumFeatureFace) {
         sSlotFaces[nCont] = GetFirstFaceInList( &sFeatureFaces) ;
         nCont = nCont + 1 ;
      }
     // le facce da controllare sono tutte le facce della feature
      if ( bMultFace) then
         nNumTotFace = nNumFeatureFace ;

     // gestione speciali : parto dalla seconda faccia
      if ( $CL == 131  OR  $CL == 141  OR  $CL == 151) then
         nCont = 2 ;
      else
         nCont = 1 ;
     // testo l'adiacenza con tutte le facce
      while ( nCont < nNumTotFace) {
         nJ = nCont + 1 ;
         while ( nJ <= nNumTotFace) {
            if ( VERIFYFACESADJACENCY( sSlotFaces[nCont], sSlotFaces[nJ])) then {
               InsertCornerHole( sSlotFaces[nCont], sSlotFaces[nJ], OUTSTR( "P0{nIndexHole}")) ;
               nIndexHole = nIndexHole + 1 ;
            }
            nJ = nJ + 1 ;
         }
         nCont = nCont + 1 ;
      }
   }

   procedure ExecSurfHole()
   {
      num nIndexTool5A ;
      num nVersZ = 0 ;
      bool bHolePerp = FALSE ;

     // la priorità è bassa
      bToolFind = FindTool( OPT( $CL == 511, nOpenFeat, nCheckDiamFeat), nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;

     // controllo nota su feature che indica direzione foro (3 note: DVX,DVY,DVZ). Se non c'è allora guardo la normale
      if ( GETCUSTOMNOTE( "DVZ=") != "") then {
         nVersZ = STRINGTONUM( GETCUSTOMNOTE( "DVZ=")) ;
         if ( ABS( nVersZ) == 0  OR  ABS( nVersZ) == 1) then
            bHolePerp = TRUE ;
      }
      else {
         if ( ABS( $Np.z) == 0  OR  ABS( $Np.z) == 1) then
            bHolePerp = TRUE ;
      }

     // se trovato utensile
      if ( bToolFind) {
        // se foro con un angolo devo farlo 5 assi
         if ( NOT( bHolePerp)) then {
            if ( ( C_sPref5a + sToolKit) != "") then {
               nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
              // applico lavorazioni a 5 assi
               InsertKit( C_sPref5a + sToolKit, "F01,F02,F03,F04", nPosXFeat, nPri) ;
            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sHole}: {$NaF} {sNotExecute}") ;
         }
        // altrimenti se foro perpendicolare
         else {
            if ( $CL == 511  OR  ( $CL == 512  AND  ( NOT( C_vbWorkByHead[nToolIndex])  OR  $EW > ( nToolDiam * 4)))) then {
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_Nessuno, _Clg_Nessuno, &sKit) ;
            }
            else {
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_Nessuno, _Clg_Nessuno, &sKit) ;
            }
            CalculateHeadSolution( $Np) ;
            if ( $ER > nToolLen) then {
               if ( $Np.z == 0  OR  C_bHeadFromSide) then {
                 // aggiungo 5 perchè quando foro devo essere sicuro di passare
                  nLenFirstHole = MIN( ($ER / 2 + 5), nToolLen) ;
                  SETKITDEPTH( nLenFirstHole - $ER) ;
                  VerifyAndSetStep( sKit, 40, FALSE) ;
                  InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                  nLenSecondHole = nLenFirstHole ;
                  SETKITDEPTH( nLenSecondHole - $ER) ;
                  SETKITDIR( _Sud) ;
                  nVotoFeature = OPT( bVeryShortBeam, 0, 3) ;
               }
               else {
                  nVotoFeature = 1 ;
                  nAppo = nToolLen - $ER ;
                  SETKITDEPTH( nAppo) ;
               }
               VerifyAndSetStep( sKit, 40, FALSE) ;
               InsertKit( sKit, "F01", nPosXFeat, nPri) ;
               CheckDepthHole( $ER) ;
            }
            else {
              // faccio doppia passata
               if ( ( ( ( nToolDiam + 1) * 4) >= $EW)  AND  ( $EW > nToolDiam * 2)) then {
                  VerifyAndSetStep( sKit, 40, FALSE) ;
                  SETKITOVERMAT( MIN( nToolDiam - 5, ( $EW - nToolDiam*2)/2 + 5)) ;
                  InsertKit( sKit, "F01", nPosXFeat, nPri) ;
               }
              // se troppo grande allora faccio con le TAB
               elsif ( $EW > ( nToolDiam-5) * 4  AND  $EW < 1000  AND  C_bUseTabs) then {
                 // QQQ METTERE PARAMETRI IN CONFIGURAZIONE
                  SETKITTAB( 1, 350, 0, 0, 10, 150, 45) ;
               }

               nVotoFeature = 3 ;
               VerifyAndSetStep( sKit, 40, FALSE) ;
               InsertKit( sKit, "F01", nPosXFeat, nPri) ;
            }
         }
      }
   }

   procedure ExecTenon()
   {
      bool bFlip ;
      num nDistAtt ;

     // il sovramateriale non piò essere più grande della lunghezza del tenone
      if ( ABS( C_nOverMatLenTenon) < $P11) then {
        // inserisco il taglio solo se effettivamente tenone troncante. La feature "House" non necessita del taglio.
         if ( $CaF == 1050) then {
            ADDOFFSETFACE( "F01", "A01", $P11 + C_nOverMatLenTenon, FALSE) ;
           // non eseguo se esiste un altro taglio complanare
            if ( NOT( GETCOPLANARCUT( "A01"))) then {
               if ( GETFACEHVREXT( "A01", &nEaH, &nEaV, &nEaR)) then
                  FindKitBlade( nNormal, nEaV, nEaH, "A01", $N1, "A01", 0, TRUE) ;
               else {
/*
                 // CUTL E R NON SEMPRE VENGONO CONTROLLATI CORRETTAMENTE
                  if ( ( $S == 2 AND $CutL == 1) OR ( $S == 1 AND $CutR == 1))
                     bError = FALSE ;
                  else
                     bError = TRUE ;
*/
                  OutputReport( _BcfWarn, "{sAttention} {sTenon}: {$Naf} {sNotComplete}") ;
               }
            }
         }

        // se non ha creato la faccia potrebbe voler dire che il tenone è inclinato ed esce dalle facce canoniche ma non destra o sinistra
         if ( ( $Np.z >= -0.1 OR  C_bHeadFromSide) AND ( NOT( bError)  OR  ( $Pmin.x >= 0  AND  $Pmax.x <= $L))) then {
            if ( ( bVeryShortBeam  AND  ( ABS( $Np.y) > 0.1  OR  ABS( $Np.z) > 0.1))  OR
               ( bShortBeam  AND  ( ABS( $Np.y) > 0.707  OR  ABS( $Np.z) > 0.707))) then {
               if ( ABS( $Np.y) > ABS( $Np.z)) then
                  nVotoFeature = 0 ;
            }
            elsif ( ABS( $Np.z) > ABS( $Np.y)) then
               nVotoFeature = 5 ;
            elsif ( ABS( $Np.x) >= ABS( $Np.y)) then
               nVotoFeature = 4 ;
            elsif ( $Np.z < 0  AND  C_bHeadFromSide) then
               nVotoFeature = 1 ;
            else
               nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, 2, 3)) ;

            if ( bVeryShortBeam OR ( ( ( $S == _BtlRight AND $McLeftLoad) OR ( $S == _BtlRight AND $McLeftLoad)) AND C_bExecuteMeasure)) then
               nManagementFlag = _Last ;

           // Calcolo se opportuno flip
            bFlip = FALSE ;
            if ( $Np.z < 0.5) {
               if ( $Np.x > 0  AND  $Np.y < 0) then
                  bFlip = TRUE ;
               if ( $Np.x < 0  AND  $Np.y > 0) then
                  bFlip = TRUE ;
            }

           // Eseguo svuotatura se necessario
            if ( bFlip) then
               SETKITFLIPSOLUTION() ;
            bPock = ExecutePocket() ;

           // la contornatura viene sempre eseguita
            SETKITOVERMAT( C_nOverMatTenon) ;
            if ( bFlip) then
               SETKITFLIPSOLUTION() ;
            bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Ten, _nForceToolToUse) ;
            sKit = C_sPrefCont + sToolKit ;
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;

           // se è stata fatta la svuotatura, faccio in una passata
            if ( bPock) then
               nAppo = $P11 ;
            else {
               nAppo2 = $Dt * $P11 * C_nCoeffMachTenon ;
               if ( nAppo2 > 15000) then
                  nAppo = $P11 / 6 ;
               elsif ( nAppo2 > 11000) then
                  nAppo = $P11 / 5 ;
               elsif ( nAppo2 > 8000) then
                  nAppo = $P11 / 4 ;
               elsif ( nAppo2 > 4500) then
                  nAppo = $P11 / 3 ;
               elsif ( nAppo2 > 2500) then
                  nAppo = $P11 / 2 ;
               else
                  nAppo = $P11 ;
            }

            VerifyAndSetStep( sKit, nAppo, bPock) ;

            if ( $F == 1 OR $F == 3) then
               nDistAtt = MIN( $Dt, MAX( $P14, $P15)) + 5 ;
            elsif ( $F == 2 OR $F == 4) then
               nDistAtt = $Dt + 5 ;

            if ( $P11 > nToolLen  AND  nToolDiam < ( C_nDiamMotore + C_nSicurezza)) then {
               SETKITDEPTH( nToolLen - $P11) ;
               OutputReport( _BcfWarn, "{sAttention} {sTenon}: {$Naf} {sNotComplete}") ;
            }
            else
               SETKITDEPTH( 0) ;
            SETKITRISE( $P11) ;
            SETKITLEADINLENC( nDistAtt) ;
            SETKITLEADOUTLENC( nDistAtt) ;
            SETKITDIR( _None) ;
           // il tenone in testa ha priorità più alta
            if ( $McLeftLoad AND nPosXFeat > $L/2  OR  NOT( $McLeftLoad) AND nPosXFeat < $L/2) then {
               nPri = nPri + 2 ;
              // se il tenone non arriva in fondo alla trave potrebbe essere ci sia un doppio tenone. Quindi devo abbassarne la priorità. Prima si lavora quello esterno e poi quello più interno.
               if ( $Pmin.x > 5  AND  $Pmax.x < $L - 5) then
                  nPri = nPri - 1 ;
            }
            else {
              // se il tenone non arriva in fondo alla trave potrebbe essere ci sia un doppio tenone. Quindi devo abbassarne la priorità. Prima si lavora quello esterno e poi quello più interno.
               if ( $Pmin.x > 5  AND  $Pmax.x < $L - 5) then
                  nPri = nPri - 1 ;
            }

            InsertKit( sKit, "F02", nPosXFeat, nPri) ;
         }
         else
            OutputReport( _BcfWarnErr, "{sError} {sTenon}: {$Naf} {sNotExecute} {sNotWork2}") ;
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sTenon}: {$Naf} {sNotExecute} {sErrParam}") ;
   }

   procedure ExecTenonCR()
   {
      bool bOk ;
      num nDiam ;

     // il sovramateriale non può essere più grande della lunghezza del tenone
      if ( ABS( C_nOverMatLenTenonCR) < $P11) then {
         if ( $P11 > C_nMaxMatDoveTail) then
            bOk = ADDOFFSETFACE( "F03", "A01", C_nMaxMatDoveTail + C_nOverMatLenTenonCR, FALSE) ;
         else
            bOk = ADDOFFSETFACE( "F01", "A01", C_nOverMatLenTenonCR, FALSE) ;

        // se non crea la faccia vuol dire che non è presente e quindi alcune variabili non sono calcolate e darebbe errore
         if ( NOT( bOk)) then
            OutputReport( _BcfWarnErr, "{sError} {sTenon}: {$Naf} {sNotExecute} {sErrParam}") ;
         else {
           // non eseguo se esiste un altro taglio complanare
            if ( NOT( GETCOPLANARCUT( "A01"))) then {
               nPri = CheckPriSmallPiece( C_nPriBla) ;
               FindKitBlade( nNormal, $EV, $EH, "A01", $N1, "A01", 0, TRUE) ;
            }

            if ( $Np.z >= -0.2  OR  C_bHeadFromSide) then {
               if ( ABS( $Np.x) >= ABS( $Np.y)) then
                  nVotoFeature = 4 ;
               elsif ( $Np.z < 0  AND  C_bHeadFromSide) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, 2, 3)) ;

               if ( bVeryShortBeam OR ( ( ( $S == _BtlRight AND $McLeftLoad) OR ( $S == _BtlRight AND $McLeftLoad)) AND C_bExecuteMeasure)) then
                  nManagementFlag = _Last ;

               if ( ( nPosXFeat > nReferenceDistance AND $McLeftLoad) OR ( nPosXFeat < ( $L - nReferenceDistance) AND NOT( $McLeftLoad))) then
                  nPri = CheckPriSmallPiece( 101) ;
               else
                  nPri = CheckPriSmallPiece( 100) ;

               bOk = GETKITDATA( C_sPrefCont + C_sNameBaseFreCR, _ToolDiam, 0, &nDiam) ;

               if ( $Dt > nDiam * 2  OR  C_bExecRoughCR) then {
                  bToolFind = FindTool( nOpenFeat, nStandard, 1, "F02", "F01", _TypeTMach_Rib, _nForceToolToUse) ;
                  SETKITRISE( $P11) ;
                  CalculateHeadSolution( $Np) ;
                  if ( $Dt < ( ( nDiam / 2) + nToolDiam)  OR  C_bExecRoughCR) then {
                     SETKITOVERMAT( MAX( OPT( bOk, nDiam / 2, C_nOverMatCR_NoTool), 10)) ;
                     SETKITDIR( _None) ;
                     sKit = C_sPrefCont + sToolKit ;
                     SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                     SETKITDIR( _None) ;
                     InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                  }
                  else {
                     sKit = C_sPrefSvuot + sToolKit ;
                     SETKITCONTOURDIST( MAX( OPT( bOk, nDiam / 3, C_nOverMatCR_NoTool), 10)) ;
                     InsertKit( sKit, "F03", nPosXFeat, nPri) ;
                  }
               }
               elsif ( $Dt > nDiam - 5) then {
                  SETKITOVERMAT( $Dt / 2) ;
                  SETKITRISE( $P11) ;
                  CalculateHeadSolution( $Np) ;
                  SETKITDIR( _None) ;
                  InsertKit( C_sPrefCont + C_sNameBaseFreCR, "F02", nPosXFeat, nPri) ;
               }

               if ( C_sPrefCont + C_sNameBaseFreCR != "") then {
                  if ( ( nPosXFeat > nReferenceDistance AND $McLeftLoad) OR ( nPosXFeat < ( $L - nReferenceDistance) AND NOT( $McLeftLoad))) then
                     nPri = CheckPriSmallPiece( 101) ;
                  else
                     nPri = CheckPriSmallPiece( 100) ;

                  SETKITOVERMAT( C_nOverMatTenonCR) ;
                  SETKITRISE( $P11) ;
                  CalculateHeadSolution( $Np) ;
                  SETKITDIR( _None) ;
                  InsertKit( C_sPrefCont + C_sNameBaseFreCR, "F02", nPosXFeat, nPri) ;
               }
               else {
                  if ( NOT( bError)) then
                     OutputReport( _BcfWarn, "{sAttention} {sTenon}: {$Naf} {sNotComplete} (Err. Name Kit)") ;
               }
               if ( $P14 != 0) then {
                  nPri = CheckPriSmallPiece( C_nPriFre) ;
                  SETKITDIR( _None) ;
                  bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
                  sKit = C_sPrefCont + sToolKit ;
                  SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                  GETKITDATA( sKit, _ToolDiam, 0, &nDiam) ;
                  SETKITLEADINTANG( MIN( nDiam + 5, $Dt + nDiam / 4)) ;
                  SETKITLEADOUTTANG( nDiam / 2) ;
                  CalculateHeadSolution( $Np) ;
                  SETKITRISE( $P11) ;
                  InsertKit( sKit, "F04", nPosXFeat, nPri) ;
               }

            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sTenon}: {$Naf} {sNotExecute} {sNotWork2}") ;
         }
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sTenon}: {$Naf} {sNotExecute} {sErrParam}") ;
   }

   procedure ExecDartJoint()
   {
      string sKitPock ;

      nPri = CheckPriSmallPiece( C_nPriBla) ;

      GETFACEFACEANGLW( "F02", "F01", &nAng, &nLen, &nWid) ;

      bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, "F04", "F05,F03,F02,F01", _TypeTMach_Rib, _nForceToolToUse) ;
      if ( bToolFind) then
         sKitPock = C_sPrefSvuot + sToolKit ;
      else
         bError = TRUE ;

      if ( NOT( bError)) then {
         if ( $NF == 1) then {
            if ( NOT( GETCOPLANARCUT( "F02"))) then {
               GETFACENORMAL( "F02", &v3Appo) ;
               GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F02", v3Appo, "F02", 0, TRUE) ;
            }
         }
         else {
           // lavorazione faccia 1
            if ( NOT( GETCOPLANARCUT( "F01"))) then {
               ADDOFFSETFACE( "F01", "A01", 0, FALSE) ;
               GETFACENORMAL( "A01", &v3Appo) ;
               GETFACEHVREXT( "A01", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "A01", v3Appo, "A01", 0, TRUE) ;
            }

           // lavorazione faccia 2 e 4
            ADDOFFSETFACE( "F02", "A02", 0, FALSE) ;
            GETFACENORMAL( "A02", &v3Appo) ;
            GETFACEHVREXT( "A02", &nEaH, &nEaV, &nEaR) ;

           // se devo togliere tanto materiale faccio prima un taglio di sgrezzo
          //  if ( nEaR > 150) then {
          //     FindKitBlade( nNormal, nEaV, nEaH, "A02", v3Appo, "A02", 50, TRUE) ;
          //  }
            FindKitBlade( nNormal, nEaV, nEaH, "A02", v3Appo, "A02", 0, TRUE) ;

           // lavorazione faccia 5 con fresa
            GETFACENORMAL( "F05", &v3Appo) ;
            GETFACEHVREXT( "F05", &nEaH, &nEaV, &nEaR) ;
            bCutNoDepth = TRUE ;
           // taglio di fianco
            if ( $N2.z == 0) then
               FindKitBlade( nInvert, nEaH, nEaV, "F05", v3Appo, "F04", 0, FALSE) ;
           // taglio da sopra
            elsif ( $N2.z > 0) then
               FindKitBlade( nNormal, nEaV, nEaH, "F05", v3Appo, "F04", 0, FALSE) ;

           // lavorazione faccia 3 con fresa
            GETFACENORMAL( "F03", &v3Appo) ;
            GETFACEHVREXT( "F03", &nEaH, &nEaV, &nEaR) ;
            bCutNoDepth = TRUE ;
           // taglio di fianco
            if ( $N2.z == 0) then
               FindKitBlade( nInvert, nEaH, nEaV, "F03", v3Appo, "F04", 0, FALSE) ;
           // taglio da sopra
            elsif ( $N2.z > 0) then
               FindKitBlade( nNormal, nEaV, nEaH, "F03", v3Appo, "F04", 0, FALSE) ;

           // svuotatura sulla faccia 4
            nPri = CheckPriSmallPiece( C_nPriFre - 100) ;
            GETFACENORMAL( "F04", &v3ToolDir) ;
            CalculateHeadSolution( v3ToolDir) ;
            SETKITRISE( $P11) ;
            InsertKit( sKitPock, "F04", nPosXFeat, nPri) ;
         }
         if ( $F == 1) then
            nVotoFeature = 4 ;
         elsif ( $F == 2  OR  $F == 4) then
            nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 2), 3)) ;
         else {
           // se è solo una faccia allora posso lavorare anche se da sotto, altrimenti devo lavorare in altre rotazioni
            if ( $NF == 1) then
               nVotoFeature = 1 ;
            else
               nVotoFeature = 0 ;
         }
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sJoint}: {$Naf} {sNotExecute}") ;
   }

   procedure ExecArc()
   {
     // se richiesto faccio passata di sgrossatura
      if ( C_bExecuteSgroProfil) then
         FindKitProf2( "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12,F13,F14,F15,F16", 15) ;

      FindKitProf( "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12,F13,F14,F15,F16") ;
     // se CONCAVO o CONVESSO devo fare le passate di pulitura
      if ( $CaF == 3101  OR  $CaF == 3102) then
         ExecuteContConcConv() ;
   }

   procedure ExecBowProf()
   {
      bool bBladeCut ;

     // contornatura da fare sempre
      if ( $Np.z >= 0  OR  C_bHeadFromSide) then {
         bBladeCut = FALSE ;
         if ( $N1.z >= 0) then {
            if ( $Np.x == 0  AND ( $F == 3  OR  C_bUseBladeOnProfil)) then {
              // se trovo la lama con la quale lavorare
               GETFACEHVREXT( "F01", &nEaH, &nEaV, &nEaR) ;
              // QQQ difficilmente il profilo arcuato ha uno smusso che la lama non riesce a fare. Ci sono dei casi dove il profilo è molto profondo ma c'è uno scasso.
              // Calcolando la posizione reale rispetto alla trave non ce la farebbe a fare con la lama, quindi forzo dicendo che al massimo è 100mm
               nEaV = 100 ;
               nEaR = 100 ;
               if ( FindBlade( "F01", FALSE, TRUE, nEaR, nEaV, 0, _bForceComplete)  AND  FindBlade( "F03", FALSE, TRUE, nEaV, nEaR, 0, _bForceComplete))then {
                  FindBlade( "F01", FALSE, TRUE, nEaR, nEaV, 0, _bForceComplete) ;
                  SetPriorityBlade( $Np, "F01") ;
                  SETKITDEPTH( C_nOverMatProfil) ;
                  CalculateToolDir( "F01", "F03") ;
                  SETKITLEADINTANG( 1) ;
                  SETKITLEADOUTTANG( 1) ;
                  SETKITLEADINPERP( 0) ;
                  SETKITLEADOUTPERP( 0) ;
                  SETKITLEADINLENC( nEaR + 30) ;
                  SETKITLEADOUTLENC( nEaR + 30) ;
                  SETKITRISE( 0) ;
                  InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], "F01", nPosXFeat, nPri) ;
                 // seconda faccia
                  FindBlade( "F03", FALSE, TRUE, nEaV, nEaR, 0, _bForceComplete) ;
                  SETKITLEADINTANG( 1) ;
                  SETKITLEADOUTTANG( 1) ;
                  SETKITLEADINPERP( 0) ;
                  SETKITLEADOUTPERP( 0) ;
                  SETKITLEADINLENC( nEaV + 10) ;
                  SETKITLEADOUTLENC( nEaV + 10) ;
                  SETKITDEPTH( C_nOverMatProfil) ;
                  SETKITOVERMAT( - C_nOverMatProfil) ;
                  CalculateToolDir( "F03", "F01") ;
                  SETKITRISE( 0) ;
                  InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], "F03", nPosXFeat, nPri) ;
                  bBladeCut= TRUE ;
               }
            }
         }
        // se non ho fatto il taglio di lama
         if ( NOT( bBladeCut)) then {
            bToolFind = FindTool( nRadiusFeat, nProfil, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Prof, _nForceToolToUse) ;
            if ( bToolFind) then {
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
               CalculateToolDir( "F03", "F01") ;
               SETKITDEPTH( C_nOverMatProfil) ;
               SETKITOVERMAT( - C_nOverMatProfil) ;
               SETKITSTEP( nToolLen) ;
               InsertKit( sKit, "F03", nPosXFeat, nPri) ;
            }
         }
      }
      else
         OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$Naf} {sNotComplete}") ;

     // se richiesto faccio passata di sgrossatura
      if ( C_bExecuteSgroProfil) then
         FindKitProf2( "F01,F02", 15) ;

     // lavoro il profilo
      FindKitProf( "F01,F02") ;
   }

   procedure ExecDTMortaise()
   {
      bool bExistPock ;
      vec3 v3NormPock ;

      if ( $Np.z >= -0.1  OR  C_bHeadFromSide) then {
        // verifico se c'è già un taglio ( solo su mortasa a coda di rondine frontale)
         if ( $CaF == 3056  AND  NOT( GETCOPLANARCUT( "G01"))) then {
            if ( GETFACEHVREXT( "G01", &nEaH, &nEaV, &nEaR)) then {
               FindKitBlade( nNormal, nEaV, nEaH, "G01", $Np, "G01", 0, TRUE) ;
               nVotoFeature = 1 ;
            }
            else
               OutputReport( _BcfWarn, "{sAttention} {sFMortiseDT}: {$NaF} {sErrParam}") ;
         }

        // se c'è una tasca per ingresso
         bExistPock = GETFACENORMAL( "P01", &v3NormPock) ;
         if ( bExistPock) then {
            if ( v3NormPock.z >= 0) then {
               bToolFind = FindTool( nRadiusFeat, nNormal, 1, "P01", "P02,P03,P04,P05", _TypeTMach_Rib) ;
               if ( bToolfind) then {
                 // se il pezzo è stato allungato, allora in coda abbasso priorità
                  if ( bPieceEnlarged  AND  ( ( $Pmin.x < 5 AND $McLeftLoad)  OR  ( $Pmax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                     bIsTail = TRUE ;
                     nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                     bIsTail = FALSE ;
                  }
                  else
                     nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                 // se non riesco a lavorarlo completo
                  if ( $ER > nToolLen) then {
                     SETKITDEPTH( nToolLen - $ER) ;
                     VerifyAndSetStep( C_sPrefSvuot + sToolKit, 0, FALSE) ;
                  }
                  CalculateHeadSolution( $N1) ;
                  InsertKit(  C_sPrefSvuot + sToolKit, "P01", nPos, nPri) ;
               }
            }
         }

         nPri = CheckPriSmallPiece( 100) ;
         bToolFind = GETKITDATA( C_sPrefCont + C_sNameBaseFreCR, _ToolDiam, 0, &nAppo) ;

         if ( bToolFind) then {
           // solo se mortasa a coda di rondine NON frontale
            if ( $CaF == 3055) then {
               if ( $F == 3) then
                  nVotoFeature = 3 ;
               elsif ( $F == 2  OR  $F == 4) then
                  nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, OPT( ( nPosXFeat > C_nDistHeadFeat AND nPosXFeat < $L - C_nDistHeadFeat), 0, 1), 2)) ;
               elsif ( $Np.z < 0  AND  C_bHeadFromSide) then
                  nVotoFeature = 1 ;
            }
            else
               nVotoFeature = 1 ;
           // la priorità dipende dalla faccia
            nPri = nPri + $F ;

            sKit = C_sPrefCont + C_sNameBaseFreCR ;
            CheckInOut( sKit) ;
            SETKITRISE( 0) ;
            SETKITDEPTH( C_nOverMatLenMortCR) ;
            CalculateHeadSolution( $N1) ;
            if ( ABS( $P06) > 85  AND  ABS( $P06) < 95) then
               SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Lineare, &sKit) ;
            InsertKit( sKit, "F02", nPosXFeat, nPri) ;

           // passata per completare se feature molto grande
            if ( $Dt > 2 * nAppo) then {
               CheckInOut( sKit) ;
               SETKITRISE( 0) ;
               if ( $Dt > nAppo * 3) then {
                  SETKITCONTOURDIST( 10) ;
                  SETKITDEPTH( C_nOverMatLenMortCR) ;
                  sKit = C_sPrefSvuot + C_sNameBaseFreCR ;
                  CalculateHeadSolution( $N1) ;
                  InsertKit( sKit, "F01", nPosXFeat, nPri) ;
               }
               else {
                  SETKITOVERMAT( $Dt / 2 - ( nAppo - 5)) ;
                  sKit = C_sPrefCont + C_sNameBaseFreCR ;
                  SETKITDEPTH( C_nOverMatLenMortCR) ;
                  SETKITSMOOTHPATH( 1) ;
                  CalculateHeadSolution( $N1) ;
                  if ( ABS( $P06) > 85  AND  ABS( $P06) < 95) then
                     SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Lineare, &sKit) ;
                  InsertKit( sKit, "F02", nPosXFeat, nPri) ;
               }
            }
         }
         else
            OutputReport( _BcfWarnErr, "{sError} {sMDoveTail}: {$Naf} {sErrMissKit}") ;
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sMDoveTail}: {$NaF} {sNotExecute}") ;
   }

   procedure ExecDoubleJoint()
   {
      nPri = CheckPriSmallPiece( C_nPriBla) ;

     // se normale verso il basso allora la feature guarda verso l'alto
      if ( $Np.z <= 0) then {
         if ( $P14 == 0  OR  $P15 == 0) then {
            if ( $P12 > 0) then {
               GETFACENORMAL( "F01", &v3Appo) ;
               GETFACEHVREXT( "F01", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F01", v3Appo, "F01", 0, TRUE) ;
              // Faccio finta che è un doppio taglio
               $CL = 421 ;
               if ( $Np.z < 0) then {
                  ExecuteCubetti( "F02", "F10") ;
                  GETFACENORMAL( "F10", &v3Appo) ;
                  GETFACEHVREXT( "F10", &nEaH, &nEaV, &nEaR) ;
                  bCutNoDepth = TRUE ;
                  FindKitBlade( nNormal, nEaV, nEaH, "F10", v3Appo, "F02", 0, TRUE) ;
               }
               else {
                  GETFACENORMAL( "F02", &v3Appo) ;
                  GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
                  FindKitBlade( nInvert, nEaV, nEaH, "F02", v3Appo, "F10", 0, TRUE) ;
                  nVotoFeatureTemp = nVotoFeature ;
                  GETFACENORMAL( "F10", &v3Appo) ;
                  GETFACEHVREXT( "F10", &nEaH, &nEaV, &nEaR) ;
                  FindKitBlade( nInvert, nEaV, nEaH, "F10", v3Appo, "F02", 0, TRUE) ;
                  nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
               }
            }
            else {
               GETFACENORMAL( "F01", &v3Appo) ;
               GETFACEHVREXT( "F01", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F01", v3Appo, "F01", 0, TRUE) ;
               nVotoFeatureTemp = nVotoFeature ;
               GETFACENORMAL( "F02", &v3Appo) ;
               GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F02", v3Appo, "F02", 0, TRUE) ;
               nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
            }
         }
         else {
           // se c'è il tenone
            if ( $P12 == 0) then {
               ADDOFFSETFACE( "F06", "A01", 0, FALSE) ;
               GETFACEHVREXT( "A01", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "A01", $N1, "F09", 0, TRUE) ;
               ADDOFFSETFACE( "F09", "A02", 0, FALSE) ;
               GETFACEHVREXT( "A02", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "A02", $N2, "F06", 0, TRUE) ;
               bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, "F02,F04", "F01,F03,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
               SETKITRISE( $P14) ;
               InsertKit( C_sPrefSvuot + sToolKit, "F02", nPosXFeat, nPri) ;
               SETKITRISE( $P14) ;
               InsertKit( C_sPrefSvuot + sToolKit, "F04", nPosXFeat, nPri) ;
               nVotoFeature = 1 ;
            }
            else {
               GETFACEHVREXT( "F01", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F01", $N1, "F02", 0, TRUE) ;
               GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
               FindKitBlade( nNormal, nEaV, nEaH, "F02", $N2, "F01", 0, TRUE) ;
            }
         }
      }
      else
         nVotoFeature = 0 ;
   }

   procedure ExecGerberJoint()
   {
      nPri = CheckPriSmallPiece( C_nPriBla) ;

      if ( $NF == 1) then {
         if ( NOT( GETCOPLANARCUT( "F02"))) then {
            GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
            FindKitBlade( nNormal, nEaV, nEaH, "F02", v3Appo, "F02", 0, TRUE) ;
         }
      }
      else {
        // lavorazione faccia 1
         if ( NOT( GETCOPLANARCUT( "F01"))) then {
            ADDOFFSETFACE( "F01", "A01", 0, FALSE) ;
            GETFACENORMAL( "A01", &v3Appo) ;
            GETFACEHVREXT( "A01", &nEaH, &nEaV, &nEaR) ;
            FindKitBlade( nNormal, nEaV, nEaH, "A01", v3Appo, "A01", 0, TRUE) ;
         }

         GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
         GETFACENORMAL( "F02", &v3Appo) ;
         if ( $P12 == 0) then
            FindKitBlade( nNormal, nEaV, nEaH, "F02", v3Appo, "F02", 0, TRUE) ;
         else {
            if ( C_nExecuteCubetti != 1) then {
               FindKitBlade( nInvert, nEaV, nEaH, "F02", v3Appo, "F03", 0, TRUE) ;
               if ( $P12 < nBladeMaxMat) then {
                  bCutNoDepth = TRUE ;
                  GETFACEHVREXT( "F03", &nEaH, &nEaV, &nEaR) ;
                  GETFACENORMAL( "F03", &v3Appo) ;
                  FindKitBlade( OPT( $F == 1, nNormal, nInvert), nEaV, nEaH, "F03", v3Appo, "F02", 0, TRUE) ;
               }
               else
                  OutputReport( _BcfWarn, "{sError} {sJoint}: {$Naf} {sNotComplete}") ;
            }
            else {
               bToolFind = FindTool( nOpenFeat, nNormal, 1, "F02", "F01,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
              // lavorazione faccia 3
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
               CalculateToolDir( "F03", "F02") ;
               InsertKit( sKit, "F03", nPosXFeat, nPri) ;

              // lavorazione faccia 2
               sKit = C_sPrefSvuot + sToolKit ;
               InsertKit( sKit, "F02", nPosXFeat, nPri) ;
            }
         }
      }
      if ( $F == 1) then
         nVotoFeature = 4 ;
      elsif ( $F == 2  OR  $F == 4) then
         nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 2), 3)) ;
      else
         nVotoFeature = 1 ;
   }

   procedure ExecLapJoint()
   {
      bool bSideBlade ;
      num nI ;
      string sFace ;

     // faccio taglio iniziale
      if ( NOT( GETCOPLANARCUT( "F01"))) then {
         GETFACENORMAL( "F01", &v3Appo) ;
         GETFACEHVREXT( "F01", &nEaH, &nEaV, &nEaR) ;
         FindKitBlade( nNormal, nEaV, nEaH, "F01", v3Appo, "F01", 0, TRUE) ;
      }

      nPri = CheckPriSmallPiece( C_nPriBla) ;
      if ( $P11 == 0 AND ( $F == 2 OR $F == 4)) then {
         if ( NOT( GETCOPLANARCUT( "F02"))) then {
            GETFACENORMAL( "F02", &v3Appo) ;
            GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
            FindKitBlade( nNormal, nEaV, nEaH, "F02", v3Appo, "F02", 0, TRUE) ;
         }
      }
      elsif ( $P11 == $T AND ( $F == 1 OR $F == 3)) then {
         if ( NOT( GETCOPLANARCUT( "F03"))) then {
            GETFACENORMAL( "F03", &v3Appo) ;
            GETFACEHVREXT( "F03", &nEaH, &nEaV, &nEaR) ;
            FindKitBlade( nNormal, nEaV, nEaH, "F03", v3Appo, "F03", 0, TRUE) ;
         }
      }

      if ( C_bTableForWall) then {
         if ( $Np.z < 0) then 
            nVotoFeature = 0 ;
         else
            ExecContMultFace() ;
      }
      else {
         bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
         GETFACENORMAL( "F02", &v3Appo) ;
         GETFACEFACEANGLW( "F02", "F03", &nAng, &nLen, &nWid) ;

         if ( v3Appo.z >= 0  OR  C_bHeadFromSide) then {
            FindBlade( "F02", FALSE, TRUE, nRise, nWid, 0, _bForceComplete) ;
            VerifyExecutionCubetti( TRUE, "F02", v3Appo, TRUE) ;
            GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
            if ( nEaR <= nBladeMaxMat  AND  nEaH <= nBladeMaxMat  AND  C_nExecuteCubetti != 1) then {
               sAppo = "F03" ;
               sAppo2 = "F02" ;
               nRise = $P11 ;
               nWid = $P12 ;

               SetPriorityBlade( $Np, "F02") ;
               SETKITLEADINTANG( 1) ;
               SETKITLEADOUTTANG( 1) ;
               SETKITLEADINPERP( 0) ;
               SETKITLEADOUTPERP( 0) ;
               SETKITLEADINLENC( nRise + 30) ;
               SETKITLEADOUTLENC( nRise + 30) ;
               bSuffWorkPerp = TRUE ;
               SETKITPERPENDICULAR( bSuffWorkPerp) ;
               CalculateToolDir( sAppo, sAppo2) ;
               InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
               SETKITLEADINTANG( 1) ;
               SETKITLEADOUTTANG( 1) ;
               SETKITLEADINPERP( 0) ;
               SETKITLEADOUTPERP( 0) ;
               SETKITLEADINLENC( nWid + 30) ;
               SETKITLEADOUTLENC( nWid + 30) ;
               bSuffWorkPerp = TRUE ;
               SETKITPERPENDICULAR( bSuffWorkPerp) ;
               CalculateToolDir( sAppo2, sAppo) ;
               InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo2, nPosXFeat, nPri) ;
               nVotoFeature = 3 ;
            }
            elsif ( /*( v3Appo.z == 0  OR  C_nExecuteCubetti == 5)  AND */ bExecuteCubetti) then {
              // tagli a cubetti
               bSecondFaceCubetti = FALSE ;
               ExecuteCubetti( "F02", "F03") ;
               if ( bError) then
                  OutputReport( _BcfWarn, "{sAttention} {sJoint}: {$NaF} {sNotComplete}") ;
               GETFACENORMAL( "F03", &v3Appo) ;
               if ( v3Appo.z > -0.1) then
                  nVotoFeature = 1 ;
               else
                  nVotoFeature = 0 ;
            }
            else {
               if ( ( ( nLengthFeat > 2000  OR  nLengthFeat > $L/1.25) AND ( $Pmin.y == 0  OR  $Pmax.y == $W))  OR  ( bPieceEnlarged AND nLengthFeat > 400)) then {
                  bSplit = TRUE ;
                  nRest = $L ;
                  nSplit = 0 ;
                  sSplit = "" ;
                  // se pezzo piccolo
                  if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                     // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                     nRest = MAX( 0, nLengthFeat - 400) ;
                     if ( $McLeftLoad) then {
                        if ( nRest > 600) then
                           nSplit = nRest/2 ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        sSplit = sSplit + OUTSTR( "{nRest},") ;
                     }
                     else {
                        nSplit = 400 ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        if ( nRest > 600) then
                           nSplit = nRest/2 + 400 ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ; 
                     }
                  }
                  // se sono in centro alla trave
                  elsif ( $Pmin.x > 500  AND  $Pmax.x < $L-500 AND nLengthFeat > 1500) then {
                     nAppo = FLOOR( nLengthFeat / 1500) ;
                     nAppoSplitLen = nLengthFeat / (nAppo + 1) ;

                     nI = 1 ;
                     while ( nI <= nAppo) {
                        nSplit = nSplit + nAppoSplitLen ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        nI = nI + 1 ;
                     }
                  }
                  // se sono all'inizio della trave
                  elsif ( $Pmin.x < 500  AND  $Pmax.x < $L-500  AND nLengthFeat > 400) then {
                     nSplit = 350 - $Pmin.x ;
                     if ( nSplit < nLengthFeat) then
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = 700 - $Pmin.x ;
                     if ( nSplit < nLengthFeat) then
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;

                     nRest = nLengthFeat - nSplit ;
                     nAppo = FLOOR( nRest / 1500) ;
                     nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                     nI = 1 ;
                     while ( nI <= nAppo  AND  nAppoSplitLen > 0) {
                        nSplit = nSplit + nAppoSplitLen ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        nI = nI + 1 ;
                     }
                  }
                  // se sono alla fine della trave
                  elsif ( $Pmin.x > 500  AND  $Pmax.x > $L-500  AND nLengthFeat > 350) then {
                     nRest = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                     nAppo = FLOOR( nRest / 1500) ;
                     nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                     nI = 1 ;
                     while ( nI <= nAppo  AND  nAppoSplitLen > 0) {
                        nSplit = nSplit + nAppoSplitLen ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        nI = nI + 1 ;
                     }

                     nSplit = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                     if ( nSplit > 0  AND  nSplit < nLengthFeat) then
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = nLengthFeat - ( 350 - ( $L - $Pmax.x)) ;
                     if (  nSplit > 0  AND  nSplit < nLengthFeat) then
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                  }
                  // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                  elsif ( nRest <= 1400) then {
                     nSplit = 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                  }
                  // in tutti gli altri casi
                  else {
                     nSplit = 350 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;

                     nRest = nLengthFeat - nSplit - nSplit ;
                     nAppo = FLOOR( nRest / 1500) ;

                     // devo comunque spezzare la parte centrale almeno una volta
                     if ( nAppo == 0) then {
                        nAppoSplitLen = nRest / 2 ;
                        nAppo = 1 ;
                     }
                     else
                        nAppoSplitLen = nRest / (nAppo + 1) ;

                     nI = 1 ;
                     while ( nI <= nAppo) {
                        nSplit = nSplit + nAppoSplitLen ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        nI = nI + 1 ;
                     }

                     nSplit = nLengthFeat - 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = nLengthFeat - 350 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                  }
                  // trimmo la faccia nelle parti calcolate
                  nAppo = AddTrimmedFacesByDistance( "F02", sSplit, &sFacesCutLong) ;

                  // lavorazione di fianco
                  if ( $N2.z >= 0) then {
                     // se richiesto faccio finitura
                     if ( C_nExecuteRecessFinish == 3  AND  C_bMakeRecessWithBlade  AND  $P12 > 40) then {
                        FindBlade( "F01", FALSE, TRUE, $ER, $EL, 0, _bForceComplete) ;
                        SetPriorityBlade( $N2, "F02") ;

                        sKit = "" ;
                        // taglio il primo lato
                        bSuffWorkPerp = TRUE ;
                        CalculateToolDir( "F03", "F02") ;
                        bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                        ExecuteBladeCont( "F03", nInvert, nToolDir, bSideBlade, FALSE, FALSE, "F02") ;
                     }
                     bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, "F02", "F01,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                     if ( bToolfind) then {
                        nI = 1 ;
                        while ( nI <= nAppo) {
                           sFace = GetFirstFaceInList( &sFacesCutLong) ;
                           GETFACEBOX( sFace, &ptMin, &ptMax) ;
                           nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                           // se il pezzo è stato allungato, allora in coda abbasso priorità
                           if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                              bIsTail = TRUE ;
                              nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                              bIsTail = FALSE ;
                           }
                           else
                              nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                           // se non riesco a lavorarlo completo
                           if ( $P11 > nToolLen) then {
                              SETKITDEPTH( nToolLen - $P11) ;
                              VerifyAndSetStep( 0) ;
                           }
                           CalculateHeadSolution( $N2) ;
                           InsertKit(  C_sPrefSvuot + sToolKit, sFace, nPosXAppo, nPri) ;
                           nI = nI + 1 ;
                        }
                        // setto il voto
                        if ( $F == 4) then
                           nVotoFeature = 5 ;
                        elsif ( $F == 3) then
                           nVotoFeature = 3 ;
                        else
                           nVotoFeature = 0 ;
                     }
                  }
                  else
                     bToolFind = FALSE ;
               }
               // altrimenti gestione standard
               else {
                 // se richiesto faccio finitura
                  if ( C_nExecuteRecessFinish == 3  AND  C_bMakeRecessWithBlade  AND  $P12 > 40) then {
                     FindBlade( "F01", FALSE, TRUE, $ER, $EL, 0, _bForceComplete) ;
                     SetPriorityBlade( $N2, "F02") ;

                     sKit = "" ;
                    // taglio il primo lato
                     bSuffWorkPerp = TRUE ;
                     CalculateToolDir( "F03", "F02") ;
                     bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                     ExecuteBladeCont( "F03", nInvert, nToolDir, bSideBlade, FALSE, FALSE, "F02") ;
                  }
                  
                  GETFACENORMAL( "F03", &v3Appo) ;
                  if ( bToolFind) then {
                     nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                     if ( nWid > $E2R  OR  v3Appo.z < 0) then {
                        sFace = "F02" ;
                        SETKITRISE( $P11) ;
                        if ( $E2R < nToolDiam  AND  v3Appo.z >= 0) then {
                           if ( nWid > nToolLen) then {
                              sKit = C_sPrefSvuot + sToolKit ;
                              CalculateHeadSolution( $N2) ;
                           }
                           else {
                              sKit = C_sPrefCont + sToolKit ;
                              SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                              CalculateToolDir( sFace, "F03") ;
                           }
                        }
                        else {
                           sKit = C_sPrefSvuot + sToolKit ;
                           CalculateHeadSolution( $N2) ;
                           if ( $E2R > nToolLen) then {
                              SETKITDEPTH( nToolLen - $E2R) ;
                              OutputReport( _BcfWarn, "{sAttention} {sJoint}: {$NaF} {sNotComplete}") ;
                           }
                        }
                     }
                     else {
                        sFace = "F03" ;
                        SETKITRISE( $P12) ;
                        if ( nWid < nToolDiam) then {
                           if ( $E2R > nToolLen) then
                              sKit = C_sPrefSvuot + sToolKit ;
                           else {
                              sKit = C_sPrefCont + sToolKit ;
                              SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                              CalculateToolDir( sFace, "F02") ;
                           }
                        }
                        else {
                           sKit = C_sPrefSvuot + sToolKit ;
                           if ( nWid > nToolLen) then {
                              SETKITDEPTH( nToolLen - nWid) ;
                              OutputReport( _BcfWarn, "{sAttention} {sJoint}: {$NaF} {sNotComplete}") ;
                           }
                        }
                     }
                     InsertKit( sKit, sFace, nPosXFeat, nPri) ;
                     nVotoFeature = 3 ;
                  }
               }
            }

            if ( NOT( bSplit)) then {
              // non posso avere facce rivolte verso il basso
               if ( $P06 != 90) then {
                  if ( ISSETVAR( $N1)  AND  ISSETVAR( $N2)) then {
                     if ( $N1.z < 0 OR $N2.z < 0) then
                        nVotoFeature = 0 ;
                  }
                  elsif ( ISSETVAR( $Np)  AND  ISSETVAR( $N2)) then {
                     if ( $Np.z < 0 OR $N2.z < 0) then
                        nVotoFeature = 0 ;
                  }
                  else
                     nVotoFeature = 0 ;
               }
              // se ho trovato la lavorazione, controllo comunque che sia fattibile
               elsif ( nVotoFeature > 0) then {
                 // setto voto su feature
                  if ( $F == 3) then
                     nVotoFeature = 4 ;
                  elsif ( $F == 2  OR  $F == 4) then {
                     nVotoFeature = OPT( bVeryShortBeam, 0, OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 2), OPT( bLongFeat AND $F == 2, 0 , 3))) ;
                  }
                  elsif ( C_bHeadFromSide) then
                     nVotoFeature = 1 ;
               }
            }
         }
         else {
            if ( ( v3Appo.x >= 0 AND nPosXFeat > $L / 2) OR ( v3Appo.x <= 0 AND nPosXFeat < $L / 2)) then {
              // se sono su faccia sotto, prima di fare svuotatura faccio taglio di lama
               if ( $F == 1) then {
                  FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
                  if ( $P12 <= nBladeMaxMat) then {
                     sAppo = "F03" ;
                     sAppo2 = "F02" ;
                     nRise = $P11 ;
                     nWid = $P12 ;
                     SetPriorityBlade( $Np, "F03") ;
                     // lavoro faccia verticale
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     SETKITLEADINTANG( 1) ;
                     SETKITLEADOUTTANG( 1) ;
                     SETKITLEADINLENC( $P12 + 30) ;
                     SETKITLEADOUTLENC( $P12+ 30) ;
                     SETKITDIR( _Nord) ;
                     SETKITDEPTH( nBladeThick - $P11) ;
                     InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
                  }
               }
               nVotoFeature = 1 ;
               if ( $E2R > nToolDiam) then {
                  sKit = C_sPrefSvuot + sToolKit ;
                  sFace = "F03" ;
               }
               else {
                  sKit = C_sPrefCont + sToolKit ;
                  SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                  sFace = "F02" ;
                  CalculateToolDir( sFace, "F03") ;
               }
               if ( nWid > nToolLen) then {
                  SETKITDEPTH( nToolLen - nWid) ;
                  OutputReport( _BcfWarn, "{sAttention} {sJoint}: {$NaF} {sNotComplete}") ;
               }
               nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
               SETKITRISE( $P12) ;
               InsertKit( sKit, sFace, nPosXFeat, nPri) ;
            }
            else
               OutputReport( _BcfWarn, "{sAttention} {sJoint}: {$NaF} {sNotComplete}") ;
         }
      }
   }

   procedure ExecStdHole()
   {
     // se fori con priorità più alta dei tagli di lama, prima devo comunque squadrare il pezzo
      if ( C_nPriFor > ( C_nPriBla + C_nDeltaSquad)) then {
        // se foratura da sopra posso farla prima della squadratura
         if ( $HI == 1 OR $HO == 1) then
            nTempPriFor = C_nPriFor ;
        // se foro sul fianco devo abbassare la priorità
         else
            nTempPriFor = C_nPriBla - 500 ;
      }
      else
         nTempPriFor = C_nPriFor ;

     // GESTIONE SPECIALE PER SHEET
     // devo controlalre se la normale del foro sia congruente con le info $HO e $HI, altrimenti devo scambiarli tra di loro. Infatti su sheet non vengono ricalcolati.
      if ( $IsSheet) then {
         if ( ( $Np.z > 0  AND  $HI < 0)  OR  ( $Np.z > 0  AND  $HO > 0)  OR  ( $Np.z < 0  AND  $HI > 0)  OR  ( $Np.z < 0  AND  $HO < 0)) then {
            if ( $HI != 0  AND  $HO != 0) then {
               nAppo = $HI ;
               $HI = $HO ;
               $HO = nAppo ;
            }
            else {
               if ( $HO == 1) then
                  $HO = -6 ;
               if ( $HO == -6) then
                  $HO = 1 ;
               if ( $HI == 1) then
                  $HI = -6 ;
               if ( $HI == -6) then
                  $HI = 1 ;
            }
         }
      }

     // se ottimizzazione foratura, priorità dipende dalla faccia
     // if ( C_bDrillOptimize) then
       //  nTempPriFor = nTempPriFor + $F ;
      if ( $Np.z > -0.01  OR  C_bHeadFromSide) then {
         if ( ( $HI > 0  AND  $HO > 0)  OR  ( ABS( $HI) > 0  AND  ABS( $HO) > 0  AND C_bHeadFromSide)) then
            bCanDoubleHole = TRUE ;
        // tento di privilegiare le forature sulle teste o sulla faccia preferita
         if ( $HO == _Left OR $HO == _Right OR $HO == C_nPreferedSideHole OR ( $HI == 0 AND $HO > 0)  OR  ( $HI < 0 AND $HO > 0)) then {
            nTypeHole = FindKitHole( $EW, $ER, $HSO, nInvert, nTempPriFor) ;
            if ( nTypeHole != 0 AND NOT( bHoleComplete)) then
               InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
            if ( nTypeHole <= 0  AND  bCanDoubleHole) then {
               nTypeHole = FindKitHole( $P12, $ER, $HSI, nNormal, nTempPriFor) ;
               if ( nTypeHole != 0 AND NOT( bHoleComplete)) then {
                  InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
                  bDoubleHoleDone = TRUE ;
               }
            }
         }
         else {
            if ( $HI >= 0) then {
               nTypeHole = FindKitHole( $P12, $ER, $HSI, nNormal, nTempPriFor) ;
               if ( nTypeHole != 0 AND NOT( bHoleComplete)) then
                  InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
               if ( nTypeHole <= 0  AND  bCanDoubleHole) then {
                  nTypeHole = FindKitHole( $P12, $ER, $HSO, nInvert, nTempPriFor) ;
                  if ( nTypeHole != 0 AND NOT( bHoleComplete)) then {
                     InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
                     bDoubleHoleDone = TRUE ;
                  }
               }
            }
            else {
               if ( ( $HI < 0  AND  ( $Np.z > -0.01  OR  C_bHeadFromSide)) OR ( $HI < 0 AND $P07 >= 89.5)) then {
                  nTypeHole = FindKitHole( $P12, $ER, $HSI, nNormal, nTempPriFor) ;
                  if ( nTypeHole != 0 AND NOT( bHoleComplete)) then
                     InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
                  if ( nTypeHole <= 0  AND  bCanDoubleHole) then {
                     nTypeHole = FindKitHole( $P12, $ER, $HSO, nInvert, nTempPriFor) ;
                     if ( nTypeHole != 0 AND NOT( bHoleComplete)) then {
                        InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
                        bDoubleHoleDone = TRUE ;
                     }
                  }
               }
               else
                  bError = TRUE ;

            }
         }
         if ( ( $HI != 4  AND  $HO != 4)  AND  ( $HI != 5  AND  $HO != 5)) then
            nVotoFeature = OPT( ( bHoleToTop AND NOT( bDoubleHoleDone)) OR bVeryShortBeam, 0, OPT( bShortBeam, OPT( nPosXFeat < C_nDistHeadFeat OR nPosXFeat > $L - C_nDistHeadFeat, 2, 0), 3)) ;
         else
            nVotoFeature = 3 ;
      }
      elsif ( $Np.z < 0) then {
         if ( $HO > 0) then {
            nTypeHole = FindKitHole( $EW, $ER, $HSO, nInvert, nTempPriFor) ;
            if ( nTypeHole != 0 AND NOT( bHoleComplete)) then
               InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
            if ( $HO == _Top) then
               nVotoFeature = OPT( C_nMaxLenLongHole > $ER, 4, 1) ;
            else
               nVotoFeature = OPT( bHoleToTop OR bVeryShortBeam, 0, OPT( bShortBeam, OPT( nPosXFeat < C_nDistHeadFeat OR nPosXFeat > $L - C_nDistHeadFeat, 2, 0), 3)) ;
         }
         else {
            bToolFind = FindTool( nOpenFeat, nStandard, 2, "H01", "H01", _TypeTMach_Rib, _nForceToolToUse) ;
            if ( C_bUseAngularTransmission  AND  bToolFind) then {
               SpecialWorkWithRR( 1, "H01", $EW) ;
               nVotoFeature = 1 ;
            }
            else {
               bError = TRUE ;
               nVotoFeature = 0 ;
            }
         }
      }
      elsif ( $Np.z > 0) then {
         if ( $HI > 0) then {
            nTypeHole = FindKitHole( $EW, $ER, $HSI, nNormal, nTempPriFor) ;
            if ( nTypeHole != 0 AND NOT( bHoleComplete)) then
               InsertKit( sKit, sNameHole, nPosXFeat, nPri) ;
            if ( $HI == _Top) then
               nVotoFeature = OPT( C_nMaxLenLongHole > $ER, 4, 1) ;
            else
               nVotoFeature = OPT( bHoleToTop OR bVeryShortBeam, 0, OPT( bShortBeam, OPT( nPosXFeat < C_nDistHeadFeat OR nPosXFeat > $L - C_nDistHeadFeat, 2, 0), 3)) ;
         }
         else {
            bToolFind = FindTool( nOpenFeat, nStandard, 2, "H01", "H01", _TypeTMach_Rib, _nForceToolToUse) ;
            if ( C_bUseAngularTransmission  AND  bToolFind) then {
               SpecialWorkWithRR( 2, "H01", $EW) ;
               nVotoFeature = 1 ;
            }
            else {
               bError = TRUE ;
               nVotoFeature = 0 ;
            }
         }
      }
      else {
         bError = TRUE ;
         nVotoFeature = 0 ;
      }

      CheckDepthHole( $ER) ;
   }

   procedure FindKitBlade( num nType, num nVertEst, num nHorizEst, string sFaceCut, vec3 v3NormCut, string sSecFaceCut, num nAddOverMat, bool bAllowCubetti)
   {
      num    nAppMat = 0 ;
      num    nRiseCut = 0 ;
      num    nMaxDepth = 0 ;
      string sTempKit = "" ;
      string sSolSpeCut = "" ;
      bool   bCornerCut = FALSE ;
      vec3   v3SecNormCut ;

      GETFACENORMAL( sSecFaceCut, &v3SecNormCut) ;
      bBladeSide = FALSE ;
      bSpecialCut = FALSE ;
      nPri = C_nPriBla ;
      CheckBlade( nType, v3NormCut, nVertEst, nHorizEst, sFaceCut) ;
     // Nel caso sia convesso
      if ( nType == nNormal) then {
        // FindBlade( sFaceCut, FALSE, TRUE, nVertEst, nHorizEst, 0, _bForceComplete) ;
         sTempKit = C_vsNomeKitBlade[nBladeIndex] ;
        // taglio da sopra lama da 800 ( lama più grande)
         if ( NOT( bBladeSide) AND nVertEst <= nBladeMaxMat AND (( v3NormCut.z >= 0 OR ( $T < nBladeMaxMat + 20 AND v3NormCut.z < -0.9)
            OR ( $T <= nBladeMaxMat - 20 AND v3NormCut.z < 0) OR ( $T <= nBladeMaxMat AND nVertEst < nBladeMaxMat / 3)) OR bSplitRowPart
            OR bCutCubetti OR ( nVertEst <= nBladeMaxMat AND v3NormCut.z < 0))) then {
            VerifyExecutionCubetti( TRUE, sFaceCut, v3NormCut, bAllowCubetti) ;
            if ( bExecuteCubetti  AND  NOT( bCutCubetti) AND NOT( bSplitRowPart)) then {
               ExecuteCubetti( sFaceCut, sSecFaceCut) ;
               SetVotoFeatureTaglioLama( _TaglioCubetti, v3NormCut) ;
            }
            if ( bError  OR  NOT( bExecuteCubetti)  OR  bSplitRowPart  OR  bCutCubetti) then {
              // se devo fare taglio antischeggia ( solo per tagli di lama)
               if ( C_nStrategyCut == 2  AND  ( $CL > 400  AND  $CL < 500)) then {
                  bSuffWorkPerp = TRUE ;
                  SETKITFLIPSIDE( TRUE) ;
                  SETKITOVERMAT( nVertEst / 2) ;
                  ExecuteBladeCont( sFaceCut, nNormal, _Nord, TRUE, FALSE, TRUE, sFaceCut) ;
               }
               SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
               InsertKit( sTempKit, sFaceCut, nPosXFeat, nPri) ;
               SetVotoFeatureTaglioLama( _TaglioSopra, v3NormCut) ;
               bError = FALSE ;
            }
         }
        // taglio corner dal basso all'alto
         else {
            VerifyExecutionCubetti( TRUE, sFaceCut, v3NormCut, bAllowCubetti) ;
            if ( bExecuteCubetti  AND  v3NormCut.z >= 0  AND  NOT( bCutCubetti) AND NOT( bSplitRowPart)) then {
               ExecuteCubetti( sFaceCut, sSecFaceCut) ;
               SetVotoFeatureTaglioLama( _TaglioCubetti, v3NormCut) ;
            }
            if ( bError  OR  NOT( bExecuteCubetti)  OR  bSplitRowPart  OR  bCutCubetti) then {
               if ( ( ABS( v3NormCut.y) < 0.1 OR v3NormCut.z >= 0 OR nHorizEst < nBladeMaxMat)  AND  nHorizEst <= nBladeMaxMat * 2) then {
                  bCornerCut = TRUE ;
                  if ( nHorizEst < ( nBladeMaxMat * ( 1 - ABS( v3NormCut.y)))) then {
                     if ( v3NormCut.z < -0.1 OR ( $Caf == 1050 AND ABS( v3NormCut.z) > 0.1)) then {
                        if ( nPosXFeat > ( $L / 2)) then {
                           if ( v3NormCut.y < 0) then
                              sTempKit = sTempKit + C_sSuffLeftLeft ;
                           else
                              sTempKit = sTempKit + C_sSuffRightRight ;
                        }
                        else {
                           if ( v3NormCut.y < 0) then
                              sTempKit = sTempKit + C_sSuffRightRight ;
                           else
                              sTempKit = sTempKit + C_sSuffLeftLeft ;
                        }
                     }
                     else {
                       // se taglio di separazione uso Kit "Left-Right" per tenere il rinvio all'interno del pezzo
                        if ( ( ( nPosXFeat == 0 AND $McLeftLoad) OR ( nPosXFeat == $L AND NOT( $McLeftLoad))) AND ( $Np.y == 0 AND  $Np.z == 0) AND
                           ( nBeamType != BEAM_SMALL_BIG  AND  nBeamType != BEAM_SMALL) AND bMachineWithCarr  AND  C_bRawMgmtInMachine) then {
                           sTempKit = sTempKit + C_sSuffLeftRight + C_sSuffSolSpeBlade ;
                           bSpecialCut = TRUE ;
                        }
                        else {
                          // se si asporta poco materiale e la normale in Z è negativa
                           if ( ( nPosXFeat < 50  OR  nPosXFeat > ( $L - 50))  OR  ( v3NormCut.z < 0  OR  v3NormCut.z > 0.95)) then {
                              if ( ( nPosXFeat < 5  OR  nPosXFeat > ($L - 5))  AND  v3NormCut.z == 0  AND  v3NormCut.y == 0) then {
                                 sSolSpeCut = C_sSuffSolSpeBlade ;
                                 bSpecialCut = TRUE ;
                              }
                              else {
                                 sSolSpeCut = "" ;
                                 bSpecialCut = FALSE ;
                              }
                           }
                           else {
                              sSolSpeCut = C_sSuffSolSpeBlade ;
                              bSpecialCut = TRUE ;
                           }
                           if ( v3NormCut.y <= 0) then {
                              if ( v3NormCut.x > 0) then
                                 sTempKit = sTempKit + C_sSuffRightRight + sSolSpeCut ;
                              else
                                 sTempKit = sTempKit + C_sSuffLeftLeft + sSolSpeCut ;
                           }
                           else {
                              if ( v3NormCut.x > 0) then
                                 sTempKit = sTempKit + C_sSuffLeftLeft + sSolSpeCut ;
                              else
                                 sTempKit = sTempKit + C_sSuffRightRight + sSolSpeCut ;
                           }
                        }
                     }
                     SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                     InsertKit( sTempKit, sFaceCut, nPosXFeat, nPri) ;
                    // aggiungo taglio da sopra speciale
                     bCornerCut = FALSE ;
                     if ( bSpecialCut) then {
                        SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                        AddSpecialCut( sFaceCut, v3NormCut, nHorizEst, nVertEst) ;
                     }
                  }
                  else {
                    // provo a lavorare tagliando metà dal sotto e metà dal sopra
                     if ( nVertEst < ( ( nBladeMaxMat * 2) - 15)  AND  C_bHeadFromSide) then {
                        nRise = $EW ;
                        nI = 1 ;
                        while ( nI <= 2) {
                           SETKITLEADINPERP( 0) ;
                           SETKITLEADOUTPERP( 0) ;
                           SETKITLEADINTANG( 1) ;
                           SETKITLEADOUTTANG( 1) ;
                           SETKITLEADINLENC( nRise + 30) ;
                           SETKITLEADOUTLENC( nRise + 30) ;
                           SETKITOVERMAT( ( nRise / 2) - 5) ;
                           SETKITRISE( 0) ;
                           if ( nI == 1) then
                              SETKITDIR( _Sud) ;
                           else
                              SETKITDIR( _Nord) ;
                           bSuffWorkPerp = TRUE ;
                           SETKITPERPENDICULAR( TRUE) ;
                           InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sFaceCut, nPosXFeat, nPri) ;
                           nI = nI + 1 ;
                        }

                        SetVotoFeatureTaglioLama( _TaglioSopra, v3NormCut) ;
                     }
                     else {
                        if ( ( ( nPosXFeat == 0 AND $McLeftLoad) OR ( nPosXFeat == $L AND NOT( $McLeftLoad))) AND ( $Np.y == 0 AND $Np.z == 0)
                           AND ( nBeamType != BEAM_SMALL_BIG  AND  nBeamType != BEAM_SMALL) AND bMachineWithCarr  AND  C_bRawMgmtInMachine) then {
                           sSolSpeCut = C_sSuffSolSpeBlade ;
                           bSpecialCut = TRUE ;
                          // taglio corner dal basso all'alto doppio (solo per separazione)
                           SetParamBlade( nNormal/2, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                           InsertKit( sTempKit + C_sSuffRightLeft + sSolSpeCut, sFaceCut, nPosXFeat, nPri) ;
                          // tenendo il rinvio all'interno del finito
                           SetParamBlade( nNormal/2, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                           InsertKit( sTempKit + C_sSuffLeftRight + sSolSpeCut, sFaceCut, nPosXFeat, nPri) ;
                          // Aggiungo taglio da sopra speciale
                           bCornerCut = FALSE ;
                           if ( bSpecialCut) then {
                              SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                              AddSpecialCut( sFaceCut, v3NormCut, nHorizEst, nVertEst) ;
                           }
                        }
                        else {
                           if ( ( v3NormCut.z < 0  OR  v3NormCut.z > 0.95) OR ( $Caf == 1050 AND ABS( v3NormCut.z) > 0.10)) then {
                              sSolSpeCut = "" ;
                              bSpecialCut = FALSE ;
                           }
                           else {
                              sSolSpeCut = C_sSuffSolSpeBlade ;
                              bSpecialCut = TRUE ;
                           }
                          // taglio corner dal basso all'alto doppio
                           SetParamBlade( nNormal/2, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                           InsertKit( sTempKit + C_sSuffRightRight + sSolSpeCut, sFaceCut, nPosXFeat, nPri) ;
                           SetParamBlade( nNormal/2, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                           InsertKit( sTempKit + C_sSuffLeftLeft + sSolSpeCut, sFaceCut, nPosXFeat, nPri) ;
                          // Aggiungo taglio da sopra speciale
                           bCornerCut = FALSE ;
                           if ( bSpecialCut) then {
                              SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                              AddSpecialCut( sFaceCut, v3NormCut, nHorizEst, nVertEst) ;
                           }
                        }
                     }
                  }
                  SetVotoFeatureTaglioLama( _TaglioFianco, v3NormCut) ;
                  bError = FALSE ;
               }
               elsif ( v3NormCut.z >= 0) then {
                 // provo a lavorare tagliando metà dal sotto e metà dal sopra
                  if ( nVertEst < ( ( nBladeMaxMat * 2) - 15)  AND  C_bHeadFromSide) then {
                     nRise = $EW ;
                     nI = 1 ;
                     while ( nI <= 2) {
                        SETKITLEADINPERP( 0) ;
                        SETKITLEADOUTPERP( 0) ;
                        SETKITLEADINTANG( 1) ;
                        SETKITLEADOUTTANG( 1) ;
                        SETKITLEADINLENC( nRise + 30) ;
                        SETKITLEADOUTLENC( nRise + 30) ;
                        SETKITOVERMAT( ( nRise / 2) - 5) ;
                        SETKITRISE( 0) ;
                        if ( nI == 1) then
                           SETKITDIR( _Sud) ;
                        else
                           SETKITDIR( _Nord) ;
                        bSuffWorkPerp = TRUE ;
                        SETKITPERPENDICULAR( TRUE) ;
                        InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sFaceCut, nPosXFeat, nPri) ;
                        nI = nI + 1 ;
                     }

                     SetVotoFeatureTaglioLama( _TaglioSopra, v3NormCut) ;
                  }
                  else {
                     nMaxDepth = CheckToolPocket( nVertEst, nHorizEst) ;
                     nPri = CheckPriSmallPiece( C_nPriFre) ;
                     GETFACEHVREXT( sFaceCut, &nHorizEst, &nVertEst, &nRiseCut) ;
                     if ( nRiseCut > nMaxDepth AND $CL != 411) then {
                        SETKITDEPTH( nMaxDepth - nRiseCut) ;
                        OutputReport( _BcfWarn, "{sAttention} {sCut}: {$Naf} {sNotComplete}") ;
                     }
                     InsertKit( sKit, sFaceCut, nPosXFeat, nPri) ;
                     SetVotoFeatureTaglioLama( _TaglioSvuota, v3NormCut) ;
                  }
               }
               else {
                  if ( NOT( bError)) then
                     OutputReport( _BcfWarnErr, "{sError} {sCut}:4 {$NaF} {sNotExecute}") ;
                  bError = TRUE ;
               }
            }
         }
      }
     // nel caso sia concavo
      elsif ( nType == nInvert) then {
         bBlade800 = TRUE ;
        // FindBlade( sFaceCut, FALSE, TRUE, nVertEst, nHorizEst, 0, _bForceComplete) ;
         sTempKit = C_vsNomeKitBlade[nBladeIndex] ;
         v3Appo = CROSS( v3SecNormCut, v3NormCut) ;
         if ( nHorizEst < nBladeMaxMat  AND  ( ABS( v3Appo.z) >= 0.707  OR  v3SecNormCut == v3NormCut)) then {
            bCornerCut = TRUE ;
            SetParamBlade( nInvert, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
            if ( v3NormCut.z >= 0) then {
               if ( v3Appo.z < 0) then
                  sTempKit = sTempKit + C_sSuffLeftLeft ;
               else
                  sTempKit = sTempKit + C_sSuffRightRight ;
            }
            elsif ( v3Appo.z > 0) then
               sTempKit = sTempKit + C_sSuffRightRight ;   // OLD: C_sSuffLeftLeft
            else
               sTempKit = sTempKit + C_sSuffLeftLeft ;     // OLD: C_sSuffRightRight
            InsertKit( sTempKit, sFaceCut, nPosXFeat, nPri) ;
            SetVotoFeatureTaglioLama( _TaglioFianco, v3NormCut) ;
         }
         elsif ( ( nHorizEst > nBladeMaxMat  OR  ABS( v3Appo.z) < 0.707)  AND  NOT( bCutCubetti)) then {
            bCornerCut = FALSE ;
            if ( v3NormCut.z >= 0) then {
               VerifyExecutionCubetti( TRUE, sFaceCut, v3NormCut, bAllowCubetti) ;
               if ( bExecuteCubetti  AND  NOT( bCutCubetti)) then {
                  ExecuteCubetti( sFaceCut, sSecFaceCut) ;
                  SetVotoFeatureTaglioLama( _TaglioCubetti, v3NormCut) ;
               }
               if ( bError  OR  NOT( bExecuteCubetti)) then {
                  if ( v3NormCut.z >= 0  AND  ABS( v3SecNormCut.z) >= 0.707  AND  v3Appo.z >= 0) then {
                     SetParamBlade( nNormal, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
                     InsertKit( sTempKit, sFaceCut, nPosXFeat, nPri) ;
                     SetVotoFeatureTaglioLama( _TaglioSopra, v3NormCut) ;
                  }
                  else {
                     nMaxDepth = CheckToolPocket( nVertEst, nHorizEst) ;
                     nPri = CheckPriSmallPiece( C_nPriFre) ;
                     GETFACEHVREXT( sFaceCut, &nHorizEst, &nVertEst, &nRiseCut) ;
                     if ( nRiseCut > nMaxDepth AND $CL != 411) then {
                        SETKITDEPTH( nMaxDepth - nRiseCut) ;
                        OutputReport( _BcfWarn, "{sAttention} {sCut}: {$Naf} {sNotComplete}") ;
                     }
                     InsertKit( sKit, sFaceCut, nPosXFeat, nPri) ;
                     SetVotoFeatureTaglioLama( _TaglioSvuota, v3NormCut) ;
                  }
                  bError = FALSE ;
               }
            }
            else
               OutputReport( _BcfWarn, "{sAttention} {sCut}: {$Naf} {sNotComplete}") ;
         }
         else {
            bCornerCut = TRUE ;
           // gestione speciale se giunto a dardo
            if ( $CaF == 1071  OR  $CaF == 1070) then {
               SetParamBlade( nInvert, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
               if ( $N2.y < 0) then {
                  if ( $N2.x < 0) then
                     InsertKit( sTempKit + C_sSuffLeftLeft, sFaceCut, nPosXFeat, nPri) ;
                  else
                     InsertKit( sTempKit + C_sSuffRightRight, sFaceCut, nPosXFeat, nPri) ;
               }
               else {
                  if ( $N2.x < 0) then
                     InsertKit( sTempKit + C_sSuffRightRight, sFaceCut, nPosXFeat, nPri) ;
                  else
                     InsertKit( sTempKit + C_sSuffLeftLeft, sFaceCut, nPosXFeat, nPri) ;
               }
            }
            elsif ( ( ( $CL == 421 OR $CL == 422 OR bCutCubetti) AND ( v3SecNormCut != v3NormCut)) OR  bSplitRowPart) then {
               SetParamBlade( nInvert, nHorizEst, nVertEst, v3NormCut, bCornerCut, sTempKit, nAddOverMat) ;
               v3Appo = CROSS( v3SecNormCut, v3NormCut) ;
               if ( v3Appo.z < 0) then
                  sTempKit = sTempKit + C_sSuffLeftLeft ;
               else
                  sTempKit = sTempKit + C_sSuffRightRight ;
               InsertKit( sTempKit, sFaceCut, nPosXFeat, nPri) ;
               if ( NOT( bCutCubetti)) then
                  SetVotoFeatureTaglioLama( _TaglioFianco, v3NormCut) ;
            }
            else {
               if ( v3NormCut.z >= 0) then {
                  nMaxDepth = CheckToolPocket( nVertEst, nHorizEst) ;
                  nPri = CheckPriSmallPiece( C_nPriFre) ;
                  GETFACEHVREXT( sFaceCut, &nHorizEst, &nVertEst, &nRiseCut) ;
                  if ( nRiseCut > nMaxDepth) then {
                     SETKITDEPTH( nMaxDepth - nRiseCut) ;
                     OutputReport( _BcfWarn, "{sAttention} {sCut}: {$Naf} {sNotComplete}") ;
                  }
                  InsertKit( sKit, sFaceCut, nPosXFeat, nPri) ;
                  SetVotoFeatureTaglioLama( _TaglioSvuota, v3NormCut) ;
               }
               else
                  OutputReport( _BcfWarn, "{sAttention} {sCut}: {$Naf} {sNotComplete}") ;
            }
         }
      }
      else {
         OutputReport( _BcfWarnErr, "{sError} {sCut}:5 {$NaF} {sNotExecute}") ;
         bError = TRUE ;
      }
   }

   procedure ExecuteCutPocket()
   {
      num nMaxDepth ;

      nPri = CheckPriSmallPiece( C_nPriFre) ;
      bError = FALSE ;

      if ( $CL > 420) then {
         if ( $AS >= 89) then {
            if ( $N1.z >= 0  OR  C_bHeadFromSide) then {
               nVotoFeature = 1 ;
               nMaxDepth = CheckToolPocket( $E1V, $E1H) ;
               CalculateHeadSolution( $N1) ;
               if ( $E1R > nMaxDepth) then
                  SETKITDEPTH( nMaxDepth - $E1R) ;
               InsertKit( sKit, "F01", nPosXFeat, nPri) ;
            }
            if ( $N2.z >= 0  AND  ( ( $N1.z < 0  AND  NOT C_bHeadFromSide)  OR  $AS >= 92)) then {
               nVotoFeature = 1 ;
               nMaxDepth = CheckToolPocket( $E2V, $E2H) ;
               CalculateHeadSolution( $N2) ;
               if ( $E2R > nMaxDepth) then
                  SETKITDEPTH( nMaxDepth - $E2R) ;
               InsertKit( sKit, "F02", nPosXFeat, nPri) ;
            }
            if ( ( ( $E1R > nMaxDepth OR $E2R > nMaxDepth) OR ( $AS > 91 AND ( $N1.z < 0 OR $N2.z < 0))) AND NOT( bError)) then
               OutputReport( _BcfWarn, "{sAttention} {sDouble} {sCut}: {$NaF} {sNotComplete}") ;
         }
         else {
            OutputReport( _BcfWarnErr, "{sError} {sDouble} {sCut}:6 {$NaF} {sNotExecute}") ;
            bError = TRUE ;
         }
      }
      else {
         if ( $N1.z >= 0) then {
            nVotoFeature = 1 ;
            nMaxDepth = CheckToolPocket( $E1V, $E1H) ;
            CalculateHeadSolution( $N1) ;
            if ( $E1R > nMaxDepth) then
               SETKITDEPTH( nMaxDepth - $E1R) ;
            InsertKit( sKit, "F01", nPosXFeat, nPri) ;
         }
         else {
            OutputReport( _BcfWarnErr, "{sError} {sCut}:7 {$NaF} {sNotExecute}") ;
            bError = TRUE ;
         }
         if ( $E1R > nMaxDepth AND NOT( bError)) then
            OutputReport( _BcfWarn, "{sAttention} {ssDouble} {sCut}: {$NaF} {sNotComplete}") ;
      }
   }


// ------------------- FUNZIONI PER RIBASSO E SIMILI --------------

   function VerExecNegativeBH() : BOOL
   {
      /* GETKITDATA( C_sNameTBlockHaus, _ToolLen, 0, &nToolLen) ;
      GETKITDATA( C_sNameTBlockHaus, _ToolDiam, 0, &nToolDiam) ;

      if ( nPosXFeat > $L / 2) then {
         if ( $L - $Pmin.x < nToolLen) then
            return TRUE ;
      }
      else {
         if ( $Pmax.x < nToolLen) then
            return TRUE ;
      }

      return FALSE ; */

     // su suprema e PMT non è possibile lavorare da sotto.
     // ( il massimo è circa 90mm tra filo tavola e naso mandrino. Con un utensile da 150mm di raggio si è in extra-corsa)
      return FALSE ;
   }


   function NotUseMillOnRecess() : BOOL
   {
      bool   bBladeFound ;
      num    nSpessLama ;
      num    nDiamLama ;
      num    nRaggioLama ;
      num    nSpessoreH ;
      num    nSpessoreL ;

      if ( C_bForceMortDiffThick) then {
         nSpessoreH = nSpessMort * 2 ;
         nSpessoreL = nSpessMort / 2 ;
      }
      else {
         nSpessoreH = nSpessMort + 0.2 ;
         nSpessoreL = nSpessMort - 0.2 ;
      }

      bCanUseMort = FALSE ;
     // per classi inferiori di sicuro uso la fresa
      if ( $CL < 132) then
         return FALSE ;
     // se ho trovato un utensile per poter lavorare e la feature è poco profonda o molto larga (farebbe troppi passaggi lama) allora faccio con fresa
      elsif ( bToolFind  AND  $CL == 141) then {
         GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid) ;
         nEaR = $ER ;
         if ( MIN( nEaR, nWid) < 50  OR  nLen > 30) then
            return FALSE ;
         else
            return TRUE ;
      }
     // se non trovo la lama cerco di applicare la mortasa
      else {
         bBladeFound = FindBlade( "F01", FALSE, TRUE, $ER, $EL, $EW, _bForceNotComplete) ;
         if ( NOT bBladeFound) then {
            if ( $CL == 142  AND ( $ER > nSpessoreL  AND  $ER < nSpessoreH)) then {
               bCanUseMort = TRUE ;
               return TRUE ;
            }
            elsif ( ( $EW > nSpessoreL  AND  $EW < nSpessoreH) AND $EL >= nLargMort) then {
               bCanUseMort = TRUE ;
               return TRUE ;
            }
            else
               return FALSE ;
         }
         else {
            sKit = C_sPrefCont + C_vsNomeKitBlade[nBladeIndex] ;

           // lettura spessore lama
            GETKITDATA( sKit, _ToolThick, 0, &nSpessLama) ;
            GETKITDATA( sKit, _ToolDiam, 0, &nDiamLama) ;
            GETKITDATA( sKit, _ToolMaxMat, 0, &nRaggioLama) ;

            if ( nRaggioLama == 0) then
               nRaggioLama = ( nDiamLama / 2) - C_nRaggioFlangiaLama ;

           // sempre mortasatrice
            if ( C_nStrategyBladeWork == 1) then {
                  if ( $CL == 142  AND ( $ER > nSpessoreL  AND  $ER < nSpessoreH)) then {
                     bCanUseMort = TRUE ;
                     return TRUE ;
                  }
                  elsif ( ( $EW > nSpessoreL  AND  $EW < nSpessoreH) AND $EL >= nLargMort) then {
                     bCanUseMort = TRUE ;
                     return TRUE ;
                  }
                  return FALSE ;
            }
           // sempre lama
            elsif ( C_nStrategyBladeWork == 2) then {
               if ( $CL == 132  AND  $EW >= nSpessLama) then {
                  if ( $EW < nSpessLama * 10) then
                     return TRUE ;
                  else
                     return FALSE ;
               }
               elsif ( $CL == 142  AND ( $ER > nSpessoreL  AND  $ER < nSpessoreH)) then {
                  bCanUseMort = TRUE ;
                  return TRUE ;
               }
               elsif ( $CL != 142) then {
                  if ( $EW >= nSpessLama) then {
                     if ( C_bForceContWithBlade) then
                        return TRUE ;
                     else {
                        if ( $CL == 132 OR ( $CL == 141 AND $EL > ( nDiamLama / 4)) OR ( $CL > 141 AND $EL > ( nDiamLama / 3.5)  AND  $EW < nSpessLama * 10)) then
                           return TRUE ;
                        else
                           return FALSE ;
                     }
                  }
               }
               else
                  return FALSE ;
            }
           // scelta automatica
            elsif ( C_nStrategyBladeWork == 3) then {
               if ( $CL == 142  AND ( $ER > nSpessoreL  AND  $ER < nSpessoreH)) then {
                  bCanUseMort = TRUE ;
                  return TRUE ;
               }
               elsif ( ( $EW > nSpessoreL  AND  $EW < nSpessoreH) AND $EL >= nLargMort) then {
                  bCanUseMort = TRUE ;
                  return TRUE ;
               }
               else {
                  if ( $EW >= nSpessLama  AND  ( $EW < nToolDiam  OR  NOT( bToolFind))) then {
                     if ( $EW >= nSpessLama  AND  $EW < nSpessLama * 5) then {
                        if ( C_bForceContWithBlade) then
                           return TRUE ;
                        else {
                           if ( $CL == 132 OR ( $CL == 141 AND $EL > ( nDiamLama / 4)) OR ( $CL > 141 AND $EL > ( nDiamLama / 3.5)  AND  $EW < nSpessLama * 10)) then
                              return TRUE ;
                           else
                              return FALSE ;
                        }
                     }
                     else
                        return FALSE ;
                  }
                  else
                     return FALSE ;
               }
            }
           // scelta automatica ottimizzata
            elsif ( C_nStrategyBladeWork == 4) then {
               if ( $CL == 132  AND  $EW >= nSpessLama  AND  $Np.z >= 0) then {
                  if ( $EW < nSpessLama * 5) then {
                    // se sheet non posso lavorare   meno che non sia sul bordo
                     if ( $IsSheet) then {
                        if ( $Pmax.z < $T) then
                           return FALSE ;
                     }
                     else {
                        if ( $ER > nRaggioLama AND ( $EW > nSpessoreL  AND  $EW < nSpessoreH)) then {
                           bCanUseMort = TRUE ;
                        }
                        return TRUE ;
                     }
                  }
                  else
                     return FALSE ;
               }
               elsif ( $EW > nSpessoreL  AND  $EW < nSpessoreH) then {
                  bCanUseMort = TRUE ;
                  return TRUE ;
               }
               elsif ( $CL == 142  AND ( $ER > nSpessoreL  AND  $ER < nSpessoreH)) then {
                  bCanUseMort = TRUE ;
                  return TRUE ;
               }
               elsif ( $CL != 142) then {
                  if ( $EW >= nSpessLama  AND  ( $EW < nToolDiam  OR  NOT( bToolFind))) then {
                     if ( C_bForceContWithBlade) then
                        return TRUE ;
                     else {
                        if ( $CL == 132 OR ( $CL == 141 AND $EL > ( nDiamLama / 4)) OR ( $CL > 141 AND $EL > ( nDiamLama / 3.5)  AND  $EW < nSpessLama * 10)) then
                           return TRUE ;
                        else
                           return FALSE ;
                     }
                  }
                  else
                     return FALSE ;
               }
               else
                  return FALSE ;
            } 
         }
      }
   }


   function VerifyMortaise() : BOOL
   {
      bool bIsPossible = FALSE ;
      string sRefFace ;
      vec3 v3Norm ;

      if ( $CL == 142) then
         v3Norm = $Np ;
      else
         v3Norm = $N1 ;

      if ( $EL > nLargMort  OR  ( $EW > nLargMort AND $CL == 142)) then {
        // se la mortasatrice è diretta come l'asse B, cioè non può lavorare da sopra
         if ( C_bUseMortBySide) then {
            if ( COMPARE( ABS( v3Norm.z), 0, 5e-2) == 0) then
               bIsPossible = TRUE ;
            elsif ( $CL == 141) then {
               if ( COMPARE( ABS( $N2.z), 0, 5e-2) == 0) then
                  bIsPossible = TRUE ;
            }
         }
         else {
            if ( COMPARE( ABS( v3Norm.z), 1, 1e-6) == 0) then {
               bIsPossible = TRUE ;
            }
            elsif ( COMPARE( ABS( v3Norm.z), 0, 1e-6) == 0) then {
               if ( $CL == 142) then
                  bIsPossible = TRUE ;
               else {
                  sRefFace = GetReferenceFace( "F01", v3Norm.z) ;
                  GETFACENORMAL( sRefFace, &v3Appo) ;
                  if ( COMPARE( ABS( v3Appo.z), 1, 1e-6) == 0) then
                     bIsPossible = TRUE ;
                 // provo a lavorare la faccia 2 se classe 141
                  else {
                     if ( $CL == 141) then {
                        v3Norm = $N2 ;
                        if ( COMPARE( ABS( v3Norm.z), 1, 1e-6) == 0) then {
                           bIsPossible = TRUE ;
                        }
                     }
                  }
               }
            }
         }
      }

      return bIsPossible ;
   }

   procedure ExecuteRecessWithOtherTool( bool bEcecuteAllFeat, string sFacetoMach)
   {
      bool   bMortOK ;
      num    nSpessoreH ;
      num    nSpessoreL ;
      num    nSpessoreFes ;
      num    nPassate ;
      num    nNumMortStep ;
      num    nContStep ;
      num    nOverMat ;
      num    nVerticalMortStep ;
      num    nDepthMort ;
      num    nTemp ;
      num    nContLoc ;
      string sNameFaceAppo ;
      string sRefFace ;

      if ( C_bForceMortDiffThick) then {
         nSpessoreH = nSpessMort * 2 ;
         nSpessoreL = nSpessMort / 2 ;
      }
      else {
         nSpessoreH = nSpessMort + 0.2 ;
         nSpessoreL = nSpessMort - 0.2 ;
      }

     // faccio finta di aver trovato l'utensile
      bToolFind = TRUE ;
      if ( bCanUseMort) then {
         if ( bExistMort) then {
            sKit = C_sNameKitMortaise ;
            nMaxDepthFreAtt = nMaxMatMortaise ;
           // se è di coda devo prestare attenzione nel caso la trave sia un pezzo piccolo
            if ( ( ( $Np.x < -0.707 AND $McLeftLoad) OR ( $Np.x > 0.707 AND NOT( $McLeftLoad)))  AND  $Np.z == 0) then
               bIsTail = TRUE ;

           // se devo eseguire completamente la tasca allora calcolo lavorazione, altrimenti lascio quella già settata 
            if ( bEcecuteAllFeat) then
               nPri = CheckPriSmallPiece( 3000 + ( $MP * C_nDeltaSquad)) ;
            else
               nPri = nPri - 10 ;

            bMortOK = VerifyMortaise() ;
            if ( bMortOK) then {
               nSpessoreFes = ABS( MIN( $EW, $EL)) ;
               nSpessoreFes = ABS( MIN( nSpessoreFes, $ER)) ;
               if ( nSpessoreFes < nSpessMort) then {
                  nSpessoreH = nSpessMort + 0.2 ;
                  nSpessoreL = nSpessMort - 0.2 ;
                  nDepthMort = 0 ;
               }
               elsif ( nSpessoreFes == nSpessMort) then {
                  nDepthMort = 0 ;
               }
               else {
                  if ( FLOOR( nSpessoreFes / nSpessMort) > 2 ) then {
                     OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                  }
                  nDepthMort = - ( nSpessoreFes - nSpessMort) ; 
               }
               if ( $CL == 142) then {
                  if ( ( $ER > nSpessoreL  AND  $ER < nSpessoreH)  AND  $EW > nLargMort  AND
                     ( ABS( $Np.z) == 1 OR ( $Np.z == 0 AND ( ABS( $Np.x) < 0.175  OR  ABS( $Np.y) > 0.985)))) then {

                     if ( $EL > C_nMaxMortStep  AND  NOT( bMachConf24)) then
                        nNumMortStep = CEIL( $EL / C_nMaxMortStep) ;
                     else
                        nNumMortStep = 1 ;

                    // se la faccia principale guarda verso il basso devo provare a partire dalla 3
                     if ( $N1.z >= 0) then
                        sRefFace = "F01,F02,F03,F04,F05,F06" ;
                     else
                        sRefFace = "F03,F04,F05,F06,F02,F01" ;

                    // lavorazione da due parti
                     if ( $Np.z == 0  AND  $EL > nMaxDepthFreAtt) then {
                        if ( NOT( bMachConf24)) then
                           nNumMortStep = CEIL( nNumMortStep / 2) ;
                        else
                           nNumMortStep = 1 ;
                       // creo le facce ausiliarie
                        ADDAUXFACE( "A01", $Np, TRUE, $EL / 2, TRUE) ;
                        v3Appo = VEC3( 0, 0, 0) - $Np ;
                        ADDAUXFACE( "A02", v3Appo, TRUE, $EL / 2, TRUE) ;
                       // calcolo gli step
                        nContStep = 0 ;
                        while ( nContStep < nNumMortStep) {
                           nOverMat = ( ( $EL / ( nNumMortStep * 2)) * ( ( nNumMortStep * 2) - nContStep - 1)) - ( $EL / 2) ;
                           CalculateToolDir( "A01", sRefFace) ;
                           bSuffSolOpp = FALSE ;
                           SETKITDIR( _Nord) ;
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           }

                          // se ultimo step devo uscire
                           if ( nNumMortStep == nContStep + 1) then {
                              nOverMat = MAX( -( nLargMort / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                           }
                           CalculateToolDir( "A02", sRefFace) ;
                           bSuffSolOpp = FALSE ;
                           SETKITDIR( _Nord) ;
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "A02", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A02", nPosXFeat, nPri) ;
                           }
                           nContStep = nContStep + 1 ;
                        }
                        if ( $EL > nMaxDepthFreAtt * 2   OR   ABS( $ER - nSpessMort) > 1) then
                           OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                        nVotoFeature = 3 ;
                        SetVotoFeatureRibasso( $Np) ;
                     }
                    // lavorazione da un lato
                     else {
                        if ( $Np.z >= 0) then
                           v3Appo = $Np ;
                        else
                           v3Appo = VEC3( 0, 0, 0) - $Np ;
                        ADDAUXFACE( "A01", v3Appo, TRUE, $EL / 2, TRUE) ;
                        nContStep = 0 ;
                        while ( nContStep < nNumMortStep) {
                           nOverMat = ( ( $EL / nNumMortStep) * ( nNumMortStep - nContStep - 1)) - ( $EL / 2) ;
                          // se ultimo step devo uscire
                           if ( nNumMortStep == nContStep + 1) then {
                              if ( ( NOT( bShortBeam) OR  ABS( $Np.z) != 1)  AND  NOT( C_bTableForWall)) then
                                 nOverMat = MAX( -( nLargMort / 2 + 5) -( $EL / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                              else
                                 nOverMat = MAX( -( $EL / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                           }
                           CalculateToolDir( "A01", sRefFace) ;
                           bSuffSolOpp = FALSE ;
                           SETKITDIR( _Nord) ;
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           }
                           nContStep = nContStep + 1 ;
                        }
                        nVotoFeature = 5 ;
                        SetVotoFeatureRibasso( v3Appo) ;
                        if ( $EL > nMaxDepthFreAtt  OR  ABS( $ER - nSpessMort) > 1) then
                           OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                     }
                  }
                  else
                     OutputReport( _BcfWarnErr, "{sError} {sLap}:10 {$NaF} {sNotExecute} {sWrongDim}") ;
               }
               elsif ( $CL == 132) then {
                  nVotoFeature = 3 ;
                  SetVotoFeatureRibasso( $N1) ;
                  v3Appo = CROSS( $N1, $N2) ;
                 // lavoro di fianco
                  if ( $ER > nMaxDepthFreAtt) then {
                    // calcolo numero step
                     if ( $EL > C_nMaxMortStep  AND  NOT( bMachConf24)) then
                        nNumMortStep = CEIL( $EL / C_nMaxMortStep) ;
                     else
                        nNumMortStep = 1 ;

                    // lavorazione da due parti
                     if ( $Np.z == 0  AND  $EL > nMaxDepthFreAtt) then {
                        if ( NOT( bMachConf24)) then
                           nNumMortStep = CEIL( nNumMortStep / 2) ;
                        else
                           nNumMortStep = 1 ;
                       // creo le facce ausiliarie
                        ADDAUXFACE( "A01", v3Appo, TRUE, $EL / 2, TRUE) ;
                        v3Appo = VEC3( 0, 0, 0) - v3Appo ;
                        ADDAUXFACE( "A02", v3Appo, TRUE, $EL / 2, TRUE) ;
                       // calcolo gli step
                        while ( nContStep < nNumMortStep) {
                           nOverMat = ( ( $EL / ( nNumMortStep * 2)) * ( ( nNumMortStep * 2) - nContStep - 1)) - ( $EL / 2) ;
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A02", nPosXFeat, nPri) ;
                           }

                          // se ultimo step devo uscire
                           if ( nNumMortStep == nContStep + 1) then {
                              nOverMat = MAX( -( $EL / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                           }
                           SETKITOVERMAT( nOverMat) ; 
                           InsertKit( sKit, "A02", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A02", nPosXFeat, nPri) ;
                           }
                           nContStep = nContStep + 1 ;
                        }
                        if ( $EL > nMaxDepthFreAtt * 2   OR   ABS( $ER - nSpessMort) > 1) then
                           OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                     }
                    // lavorazione da un lato
                     else {
                        if ( v3Appo.z < 0) then
                           v3Appo = VEC3( 0, 0, 0) - v3Appo ;

                        ADDAUXFACE( "A01", v3Appo, TRUE, $EL / 2, TRUE) ;
                        while ( nContStep < nNumMortStep) {
                           nOverMat = ( ( $EL / nNumMortStep) * ( nNumMortStep - nContStep - 1)) - ( $EL / 2) ;
                          // se ultimo step devo uscire
                           if ( nNumMortStep == nContStep + 1) then {
                              if ( NOT( bShortBeam) OR  ABS( $Np.z) != 1) then
                                 nOverMat = MAX( -( nLargMort / 2 + 5) -( $EL / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                              else
                                 nOverMat = MAX( -( $EL / 2) , ( $EL / 2) - nMaxDepthFreAtt) ;
                           }
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "A01", nPosXFeat, nPri) ;
                           }
                           nContStep = nContStep + 1 ;
                        }
                        if ( $EL > nMaxDepthFreAtt  OR  ABS( $EW - nSpessMort) > 1) then
                           OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                     }
                  }
                 // lavoro perpendicolare alla faccia
                  else {
                     if ( $Np.z == 0  OR  ( $Np.z == 1 AND NOT( C_bUseMortBySide))) then {
                        if ( $ER > C_nMaxMortStep  AND  NOT( bMachConf24)) then
                           nNumMortStep = CEIL( $ER / C_nMaxMortStep) ;
                        else
                           nNumMortStep = 1 ;

                        sAppo = "F01" ;
                        GETFACENORMAL( "F01", &v3Appo) ;
                        while ( nContStep < nNumMortStep) {
                           SetLeadInOutMort( sAppo, v3Appo) ;
                           nOverMat = ( ( $ER / nNumMortStep) * ( nNumMortStep - nContStep - 1)) ;
                          // se ultimo step devo uscire
                           if ( nNumMortStep == nContStep + 1) then {
                              nOverMat = MAX( 0 , $ER - nMaxDepthFreAtt) ;
                           }
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                           SetLeadInOutMort( sAppo, v3Appo) ;
                           if ( nNumMortStep == 1 AND nSpessoreFes > nSpessMort) then {
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                           }
                           nContStep = nContStep + 1 ;
                        }
                     }
                     else
                        nVotoFeature = 0 ;
                  }
               }
               else {
                  nVotoFeature = 4 ;
                  if ( nSpessoreFes - nSpessMort > 1 AND nSpessoreFes - ( nSpessMort * 2) > 1) then
                     OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                  if ( $CL == 151) then {
                     sAppo = "F01" ;
                     GETFACENORMAL( "F01", &v3Appo) ;
                     SetVotoFeatureRibasso( v3Appo) ;
                     nRise = $ER ;
                     if ( $N1.z < 0) then {
                        bError = TRUE ;
                        nVotoFeature = 0 ;
                     }
                  }
                  elsif ( $CL == 141) then {
                    // se la tasca è piatta lavoro la faccia più grande
                     if ( $N1.z == 0 AND $N2.z == 0) then {
                        sAppo = "F01" ;
                        GETFACENORMAL( "F01", &v3Appo) ;
                        nRise = $ER ;
                     }
                     elsif ( $N1.z == 0 AND $N2.z > 0) then {
                        if ( C_bUseMortBySide) then {
                           sAppo = "F01" ;
                           GETFACENORMAL( "F01", &v3Appo) ;
                           nRise = $ER ;
                        }
                        else {
                           sAppo = "F02" ;
                           GETFACENORMAL( "F02", &v3Appo) ;
                           nRise = $EW ;
                           nVotoFeature = 2 ;
                        }
                     }
                     elsif ( $N2.z == 0 AND $N1.z > 0) then {
                        if ( C_bUseMortBySide) then {
                           sAppo = "F02" ;
                           GETFACENORMAL( "F02", &v3Appo) ;
                           nRise = $EW ;
                           nVotoFeature = 2 ;
                        }
                        else {
                           sAppo = "F01" ;
                           GETFACENORMAL( "F01", &v3Appo) ;
                           nRise = $ER ;
                        }
                     }
                     elsif ( $N1.z == 0 OR $N2.z < 0  AND  C_bUseMortBySide) then {
                        sAppo = "F01" ;
                        GETFACENORMAL( "F01", &v3Appo) ;
                        nRise = $ER ;
                        nVotoFeature = 2 ;
                     }
                     elsif ( $N2.z == 0 OR $N1.z < 0  AND  C_bUseMortBySide) then {
                        sAppo = "F02" ;
                        GETFACENORMAL( "F02", &v3Appo) ;
                        nRise = $EW ;
                        nVotoFeature = 1 ;
                     }
                     else {
                        sAppo = "F01" ;
                        GETFACENORMAL( "F01", &v3Appo) ;
                        nRise = $ER ;
                     }
                     SetVotoFeatureRibasso( v3Appo) ;
                  }
                  if ( NOT( bError)) then {
                        if ( nRise > C_nMaxMortStep  AND  NOT( bMachConf24)) then
                           nNumMortStep = CEIL( nRise / C_nMaxMortStep) ;
                        else
                           nNumMortStep = 1 ;
                        while ( nContStep < nNumMortStep) {
                           SetLeadInOutMort( sAppo, v3Appo) ;
                           nOverMat = ( ( nRise / nNumMortStep) * ( nNumMortStep - nContStep - 1)) ;
                          // se non posso scendere di più esco comunque dal ciclo
                           if ( nOverMat < ( nRise - nMaxDepthFreAtt)) then {
                              nOverMat =  nRise - nMaxDepthFreAtt ;
                              nContStep = nNumMortStep + 1 ;
                              OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                           }
                           SETKITOVERMAT( nOverMat) ;
                           InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                           nContStep = nContStep + 1 ;
                           if ( nSpessoreFes > nSpessMort) then {
                              SetLeadInOutMort( sAppo, v3Appo) ;
                              SETKITDEPTH( nDepthMort) ;
                              SETKITOVERMAT( nOverMat) ;
                              InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                           }
                        }
                  }
                  else {
                    // se non obbligato con mortasatrice, provo a eseguire con la lama
                     if ( C_nStrategyBladeWork != 1) then {
                        bCanUseMort = FALSE ;
                        ExecuteRecessWithOtherTool( TRUE, "") ;
                     }
                     else
                        OutputReport( _BcfWarnErr, "{sError} {sLap}:12 {$NaF} {sNotExecute} {sErrMort}") ;
                  }
               }
            }
            else {
              // se non obbligato con mortasatrice, provo a eseguire con la lama
               if ( C_nStrategyBladeWork != 1) then {
                  bCanUseMort = FALSE ;
                  ExecuteRecessWithOtherTool( TRUE, "") ;
               }
               else
                  OutputReport( _BcfWarnErr, "BB{sError} {sLap}:13 {$NaF} {sNotExecute} {sErrMort}") ;
            }
            if ( $Mp > 0) then
               nManagementFlag = _First ;
            bIsTail = FALSE ;
         }
         else
            OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF}. {sMortNotExist}") ;
      }
      elsif ( ( $Pmin.x == 0 OR $Pmax.x == $L) OR ( $Pmin.x != 0 AND $Pmax.x != $L AND $N1.z >= -0.1)) then {
         if ( C_sNameTBlockHaus != "") then {
            sKit = C_sNameTBlockHaus ;
           // lettura spessore utensile per BlockHaus
            GETKITDATA( sKit, _ToolThick, 0, &nRise) ;
            if ( $EW < nRise) then {
               FindBlade( sAppo, FALSE, TRUE, $ER, $EL, $EW, _bForceNotComplete) ;
               if ( nBladeIndex > 0) then {
                  sKit = C_sPrefCont + C_vsNomeKitBlade[nBladeIndex] ;
                 // lettura spessore lama
                  GETKITDATA( sKit, _ToolThick, 0, &nRise) ;
                  nMaxDepthBladeAtt = nBladeMaxMat - C_nSicurezza ;
                  nDiamBladeAtt = nBladeDiam ;
               }
            }
           // lettura diametro lama
            GETKITDATA( sKit, _ToolDiam, 0, &nDiamBladeAtt) ;
           // lettura massimo materiale lama
            GETKITDATA( sKit, _ToolMaxMat, 0, &nMaxDepthBladeAtt) ;
           // se non è settato il massimo materiale si setta un valore fisso per sicurezza
            if ( nMaxDepthBladeAtt == 0) then
               nMaxDepthBladeAtt = ( nDiamBladeAtt / 2) - C_nRaggioFlangiaLama - C_nSicurezza ;
         }
         else {
            FindBlade( sAppo, FALSE, TRUE, $ER, $EL, $EW, _bForceNotComplete) ;

            if ( nBladeIndex > 0) then {
               sKit = C_sPrefCont + C_vsNomeKitBlade[nBladeIndex] ;
              // lettura spessore lama
               GETKITDATA( sKit, _ToolThick, 0, &nRise) ;
               nMaxDepthBladeAtt = nBladeMaxMat - C_nSicurezza ;
               nDiamBladeAtt = nBladeDiam ;
            }
         }
         if ( ( $EW >= nRise  AND ( nRise > 0  AND nMaxDepthBladeAtt > 0  AND nDiamBladeAtt > 0) AND $CL != 142  AND  $CL != 141)  OR ( $CL == 141  AND  $Pmin.z > 0)) then {
            bError = FALSE ;
            if ( sFacetoMach == "") then
               sAppo = SearchFaceToWork() ;
            else
               sAppo = sFacetoMach ;
            if ( NOT( bError)  AND  sAppo != "") then {
               nPassate = $EW / nRise ;
               nContLoc = 0 ;
               nPri = CheckPriSmallPiece( 500) ;
               while ( nContLoc + 1 < nPassate) {
                 // setto entrata/uscita tangente
                  SETKITLEADINTYPE( _LioTangent) ;
                  SETKITLEADOUTTYPE( _LioTangent) ;
                  if ( $N1.z >= -0.2) then {
                     if ( bMore2FaceBladeCont) then {
                        SETKITLEADINTANG( $ER + 30) ;
                        SETKITLEADOUTTANG( $ER + 30) ;
                     }
                     else {
                        SETKITLEADINTANG( 1) ;
                        SETKITLEADOUTTANG( 1) ;
                     }
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     SETKITLEADINLENC( $ER + 30) ;
                     SETKITLEADOUTLENC( $ER + 30) ;
                  }
                  else {
                     SETKITLEADINTANG( ( nDiamBladeAtt / 2) + 10) ;
                     SETKITLEADOUTTANG( ( nDiamBladeAtt / 2) + 10) ;
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     SETKITLEADINLENC( 5) ;
                     SETKITLEADOUTLENC( 5) ;
                  }
                  if ( $ER > nMaxDepthBladeAtt) then
                     SETKITOVERMAT( $ER - nMaxDepthBladeAtt) ;
                  else
                     SETKITOVERMAT( 0) ;

                  SETKITDEPTH( -( nContLoc * nRise)) ;
                  SETKITRISE( ( nContLoc * nRise)) ;
                  sNameFaceAppo = GetReferenceFace( sAppo, $N1.z) ;
                  CalculateToolDir( sAppo, sNameFaceAppo) ;
                  SETKITSMOOTHPATH( 1) ;
                  InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                  nContLoc = nContLoc + 1 ;
               }
               if ( ( nContLoc * nRise) != $EW) then {
                  SETKITLEADINTYPE( _LioTangent) ;
                  SETKITLEADOUTTYPE( _LioTangent) ;

                  if ( $N1.z >= -0.2) then {
                     if ( bMore2FaceBladeCont) then {
                        SETKITLEADINTANG( $ER + 30) ;
                        SETKITLEADOUTTANG( $ER + 30) ;
                     }
                     else {
                        SETKITLEADINTANG( 1) ;
                        SETKITLEADOUTTANG( 1) ;
                     }
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     SETKITLEADINLENC( $ER + 30) ;
                     SETKITLEADOUTLENC( $ER + 30) ;
                  }
                  else {
                     SETKITLEADINTANG( ( nDiamBladeAtt / 2) + 10) ;
                     SETKITLEADOUTTANG( ( nDiamBladeAtt / 2) + 10) ;
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     SETKITLEADINLENC( 5) ;
                     SETKITLEADOUTLENC( 5) ;
                  }
                 // setto sovramateriale in caso non riesca a lavorarlo completamente
                  if ( $ER > nMaxDepthBladeAtt) then
                     SETKITOVERMAT( $ER - nMaxDepthBladeAtt) ;
                  else
                     SETKITOVERMAT( 0) ;

                  SETKITDEPTH( nRise - $EW) ;
                  SETKITRISE( -( nRise - $EW)) ;
                  sNameFaceAppo = GetReferenceFace( sAppo, $N1.z) ;
                  CalculateToolDir( sAppo, sNameFaceAppo) ;
                  SETKITSMOOTHPATH( 1) ;
                  InsertKit( sKit, sAppo, nPosXFeat, nPri) ;

                 // se faccio lama + motosega in fondo
                  if ( $ER > nMaxDepthBladeAtt) then {
                     bMortOK = VerifyMortaise() ;
                    // verifico comunque che si possa utilizzare la motosega altrimenti salto i calcoli
                     if ( C_bCompleteWithMort  AND  bMortOK) then {
                        bCanUseMort = TRUE ;
                        ExecuteRecessWithOtherTool( FALSE, "") ;
                     }
                    // altrimenti dico che non è completo
                     else
                        OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                  }

               }
              // se è settata la normale della faccia 2
               if ( ISSETVAR( $N2)) then {
                  if ( ABS( $N2.z) > ABS( $N2.y)) then
                     nVotoFeature = 5 ;
                  else
                     nVotoFeature = 3 ;
               }
              // altrimenti controllo la normale principale
               else {
                  if ( ABS( $Np.z) > ABS( $Np.y)) then
                     nVotoFeature = 5 ;
                  else
                     nVotoFeature = 3 ;
               }
               SetVotoFeatureRibasso( $N1) ;
            }
         }
         else {
            OutputReport( _BcfWarnErr, "{sError} {sLap}:14 {$NaF} {sNotExecute} {sWrongDim}") ;
            bError = TRUE ;
         }
      }
      else {
         OutputReport( _BcfWarnErr, "{sError} {sLap}:15 {$NaF} {sNotExecute} {sNotWork2}") ;
         bError = TRUE ;
      }
   }


   procedure WorkFace( string sMain, string sSecond)
   {
      bool   bCont = TRUE ;
      num    nDirFace ;
      string sSuffAtt = "" ;
      vec3   v3NormMainFace = $N1;
      vec3   v3Normtool ;

      bSuffWorkPerp = FALSE ;
      if ( $CL == 132 OR $CL == 121) then {
         bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, sSecond, sMain, _TypeTMach_Rib, _nForceToolToUse) ;
         SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sSuffAtt) ;
      }
      else {
         bToolFind = FindTool( nRadiusFeat, nNormal, 1, sSecond, sMain, _TypeTMach_Rib, _nForceToolToUse) ;
         SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sSuffAtt) ;
      }
      GETFACEFACEANGLW( sMain, sSecond, &nAng, &nLen, &nWid) ;
      GETFACENORMAL( sMain, &v3NormMainFace) ;
     // ribasso lungo la trave
      if ( v3NormMainFace.x == 0) then
         nDirFace = v3NormMainFace.y ;
     // ribasso sopra trasversale
      elsif ( v3NormMainFace.y == 0) then
         nDirFace = v3NormMainFace.x ;
     // ribasso sul fianco o con inclinazioni
      else
         nDirFace = v3NormMainFace.z ;

      if ( bToolFind) then {
         if ( v3NormMainFace.z >= 0  AND  v3NormMainFace.z > ABS( nDirFace)) then {
            if ( nWid < nToolDiam) then {
               sKit = C_sPrefCont + sToolKit + sSuffAtt ;
               bSuffWorkPerp = TRUE ;
            }
            else {
               sKit = C_sPrefSvuot + sToolKit ;
               bCont = FALSE ;
            }
         }
         else {
           // controllo che la direzione dell'utensile sia sempre verso l'alto
            GETTOOLDIR( sMain, sSecond, &nToolDir, &v3Normtool) ;
            if ( v3Normtool.z >= 0) then {
               sKit = C_sPrefCont + sToolKit + sSuffAtt ;
               if ( nWid > nToolLen) then {
                  SETKITDEPTH( nToolLen - nWid) ;
                  OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
               }
            }
            else
               bError = TRUE ;
         }
      }
      else
         bError = TRUE ;

      if ( NOT( bError)) then {
         if ( bCont) then
            CalculateToolDir( sMain, sSecond) ;
         InsertKit( sKit, sMain, nPosXFeat, nPri) ;
      }
      else
         OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
   }

  // TRUE = facce non ortogonali tra loro, FALSE = tutte le facce sono ortogonali tra loro
   function CheckTiltedFace( string sWorkedFaces, bool bExecuteWork) : BOOL
   {
      bool   bAngleFound ;
      num    nFaces ;
      num    nI ;
      string sFace[6] ;
      string sFaceToWork ;
      string sRefFace ;

     // reset valori
      bImpossibleToWork = FALSE ;
      bNotOrt = FALSE ;

      nFaces = GETCANONICFACES( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
      if ( nFaces > 1) then {
         nI = 2 ;
         while ( nI <= nFaces) {
            bAngleFound = GETFACEFACEANGLW( sFace[1], sFace[nI], &nAng, &nLen, &nWid, &nProj) ;
            if ( $CL != 129  AND  $CL != 128) then {
              // Se non trovo l'angolo errore. Non c'è errore in classe 142.
              // Infatti in quel caso sarebbe sempre errore, perchè non tutte le facce sono collegate alla faccia 1.
               if ( NOT( bAngleFound) AND $CL != 142  AND  NOT( $IsSheet)) then {
                  bImpossibleToWork = TRUE ;
                  bNotOrt = TRUE ;
                  return bNotOrt ;
               }
               else {
                 // se devo lavorare un ribasso sul fianco su sheet, posso lavorare anche se meno di 90°
                  if ( $IsSheet  AND ( ( $CL == 121 OR  $CL == 132) AND  $Np.z == 0)) then {
                     bImpossibleToWork = FALSE ;
                     bNotOrt = FALSE ;
                     return bNotOrt ;
                  }
                 // decido se lavorare o non lavorare in base alle dimensioni della proiezione della faccia secondaria sulla faccia principale
                  elsif ( nProj < -( C_nLimitProjToWork)) then {
                    // Se lavoro con mortasatrice permetto anche angoli acuti
                     if ( NotUseMillOnRecess()) then {
                        if ( NOT( bCanUseMort)) then
                           bImpossibleToWork = TRUE ;
                     }
                     else
                        bImpossibleToWork = TRUE ;
                     bNotOrt = TRUE ;
                     return bNotOrt ;
                  }
                  elsif ( nProj > C_nLimitProjToWork) then {
                    // controllo se tra le facce una delle due è già stata lavorata (la faccia 1 dovrebbe essere sempre lavorata)
                     if ( STRSTR( sWorkedFaces, sFace[1]) >= 0) then {
                        sFaceToWork = sFace[nI] ;
                        sRefFace = sFace[1] ;
                     }
                     else {
                        sFaceToWork = sFace[1] ;
                        sRefFace = sFace[nI] ;
                     }
                     if ( bExecuteWork) then
                        WorkFace( sFaceToWork, sRefFace) ;
                     bNotOrt = TRUE ;
                  }
               }
            }
            nI = nI + 1 ;
         }
      }
      return bNotOrt ;
   }

   procedure CheckInOut( string sKitName)
   {
      num  nAttaccoT = 0 ;
      num  nAttaccoP = 0 ;
      num  nAngle = 0 ;
      num  nRaggio = 0 ;
      bool bCheckCont = FALSE ;
      bool bCheckDoveTail = FALSE ;

      bCheckCont = nTypeLeadMach == 1 ;
      bCheckDoveTail = STRSTR( sKitName, C_sNameBaseFreCR) != 0 ;
      if ( bCheckCont OR bCheckDoveTail) then {
         GETKITDATA( sKitName, _ToolDiam, 1 , &nRaggio) ;
         nRaggio = nRaggio / 2 ;

         if ( bCheckDoveTail) then {
           // il parametro cambia se mortasa a coda di rondine frontale
            if ( $Caf == 3056) then
               $Al = ABS( $P08) ;
            else {
               if ( $S == 1) then {
                  if ( $P06 > 0) then {
                     $Al = 180 - ABS( $P06) ;
                  }
                  else {
                     $Al = ABS( $P06) ;
                  }
               }
               elsif ( $S == 2) then {
                  if ( $P06 > 0) then {
                     $Al = ABS( $P06) ;
                  }
                  else {
                     $Al = 180 - ABS( $P06) ;
                  }
               }
            }
         }

         if ( ABS( $AL) > 5  AND  ABS( $AL - 90) > 5  AND  ABS( $AL - 180) > 5  AND  ABS( $AL - 360) > 5) then {
         // se fresa perpendicoare tiene già conto dell'estensione della faccia.
            if ( bSuffWorkPerp) then {
               nAttaccoT = nRaggio + C_nSicurezza ;
              // Attacco ingresso e uscita sono uguali
               SETKITLEADINTANG( nAttaccoT) ;
               SETKITLEADOUTTANG( nAttaccoT / 2) ;
            }
            else {
               if ( $CL == 121  OR  ( $CL == 132 AND ( $Pmin.x > 5  AND  $Pmax.x < ( $L - 5)))) then {
                  nAngle = 180 - $AL ;
                  nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                  SETKITLEADINTANG( nAttaccoT) ;
                  nAngle = $AL ;
                  nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                  SETKITLEADOUTTANG( nAttaccoT) ;
               }
               else {
                  if ( $AL > 90) then {
                     if ( $Pmin.x > 5  AND  $Pmax.x < ( $L - 5)) then {
                        nAngle = 180 - $AL ;
                        nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                     }
                     else
                        nAttaccoT = nRaggio + 10 ;
                     SETKITLEADINTANG( nAttaccoT) ;
                     nAngle = 180 - $AL ;
                     if ( $Pmin.x <= 5  OR  $Pmax.x >= ( $L - 5)) then {
                        nAttaccoP = -( ( nRaggio * TAN( nAngle)) - ( C_nSicurezza / SIN( nAngle))) ;
                        SETKITLEADINPERP( nAttaccoP) ;
                     }
                     nAngle = $AL ;
                     nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                     SETKITLEADOUTTANG( nAttaccoT) ;
                  }
                  else {
                     nAngle = 180 - $AL ;
                     nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                     SETKITLEADINTANG( nAttaccoT) ;
                     nAngle = $AL ;
                     nAttaccoT = ( nRaggio + C_nSicurezza - ( ( nRaggio + 2) * COS( nAngle))) / SIN( nAngle) ;
                     SETKITLEADOUTTANG( nAttaccoT) ;
                  }
               }
            }
         }
      }
   }

   procedure ExecuteContRecess( num nProfondita, num nLargh, string sContKit, string sFaceKit, string sRefFace)
   {
      num nCont ;
      string sAppoNameCont = "" ;
      vec3 v3DirTool ;

      GETFACENORMAL( sFaceKit, &v3DirTool) ;
     // applico prima la contornatura con sovramateriale
      if ( nLargh > ( nToolDiam - 1)  AND  nLargh < ( nToolDiam * 1.98)  AND NOT( bExecuteRecess) AND  C_nExecuteRecessFinish == 2 ) then {
         SETKITOVERMAT( MIN( nLargh - nToolDiam + 15, nToolDiam - 1)) ;
         bExecuteRecess = TRUE ;
         if ( nProfondita > nToolLen) then {
            nCont = nProfondita - nToolLen ;
            SETKITDEPTH( -nCont) ;
         }
         VerifyAndSetStep( sContKit, 50, FALSE) ;
         CalculateToolDir( sFaceKit, sRefFace) ;
         SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sContKit) ;
         CheckInOut( sContKit) ;
         InsertKit( sContKit, sFaceKit, nPosXFeat, nPri) ;
      }

     // faccio la passata senza sovramateriale
      if ( $AL >= 80 AND $AL <= 100  AND  ( ABS( v3DirTool.z) < 0.707  OR  NOT( C_bTableForWall))) then
         SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sContKit) ;
      else
         SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sContKit) ;

      if ( nProfondita <= nToolLen) then {
         VerifyAndSetStep( sContKit, 50, FALSE) ;
         bError = FALSE ;
      }
      else {
         nCont = nProfondita - nToolLen ;
         SETKITDEPTH( -nCont) ;
         VerifyAndSetStep( sContKit, 50, FALSE) ;
         bError = TRUE ;
      }
      CheckInOut( sContKit) ;
     // applico la passata corretta
      sFaceWorked = sFaceKit ;
      CalculateToolDir( sFaceKit, sRefFace) ;
      InsertKit( sContKit, sFaceKit, nPosXFeat, nPri) ;
   }

  // funzione per CLASSE 1xx
   procedure AddContMainFace()
   {
      num     nAppoTemp = 0 ;
      string  sTempKit ;
      vec3    v3Normtool ;


      sTempKit = C_sPrefCont + sToolKit ;
      sAppo = "F01" ;
      sAppo2 = "F02" ;
      nWid = $EW ;
      nRise = $ER ;

      CheckTiltedFace( "F02", FALSE) ;
      if ( $N1.z >= -0.05 AND $N2.z >= -0.05) then {
         if ( NOT( bNotOrt)) then {
            // se tavola per pareti devo lavorare se possibile verso l'alto perchè potrei collidere con la tavola
            if ( $EW > $ER  AND  ( ( nToolLen - C_nSicurezza) < $EW OR $N1.z >= 0.707)) then {
               sAppo = "F02" ;
               sAppo2 = "F01" ;
               nWid = $ER ;
               nRise = $EW ;
            }
            else {
              // se riesco a lavorare la faccia principale e il diametro supera la lunghezza vuol dire che ho già lavorato completamente e non mi serve poi la svuotatura su faccia principale 
               if ( nRise < nToolDiam) then
                  bExecuteRecess = TRUE ;
            }
         }
         else {
            bSuffWorkPerp = TRUE ;
            nWid = $ER ;
            nRise = $EW ;
         }
         CheckInOut( sTempKit) ;
         sFaceWorked = sAppo ;
         ExecuteContRecess( nWid, nRise, sTempKit, sAppo, sAppo2) ;
      }
      else {
         if ( NOT( bNotOrt)) then {

           // devo controllare il versore Z dell'utensile e cambio faccia nel caso quest'ultimo sia negativo
            GETTOOLDIR( sAppo, sAppo2, &nToolDir, &v3Normtool) ;
           // se la faccia 1 ha normale negativa ma sono su testa di fianco posso comunque lavorare
            if ( v3Normtool.z < 0  OR  ( $N1.z < 0  AND  C_bHeadFromSide)) then {
               sAppo = "F02" ;
               sAppo2 = "F01" ;
               nWid = $ER ;
               nRise = $EW ;
               GETTOOLDIR( sAppo, sAppo2, &nToolDir, &v3Normtool) ;
            }
            if ( v3Normtool.z >= 0  OR C_bHeadFromSide) then {
               CheckInOut( sTempKit) ;
               sFaceWorked = sAppo ;
               ExecuteContRecess( nWid, nRise, sTempKit, sAppo, sAppo2) ;
            }
            else {
               OutputReport( _BcfWarnErr, "{sError} {sLap}:16 {$NaF} {sNotExecute}") ;
               bError = TRUE ;
            }

           // se devo fare finitura applico taglio di lama
            if ( C_nExecuteRecessFinish == 3) then {
               $CL = 421 ;
               nPri = C_nPriBla ;
               GETFACENORMAL( sAppo, &v3Appo) ;
               GETFACEHVREXT( sAppo, &nEaH, &nEaV, &nRise) ;
               bCutNoDepth = TRUE ;
               FindKitBlade( nInvert, nEaV, nEaH, sAppo, v3Appo, sAppo2, 0, TRUE) ;
            }
         }
         else {
            OutputReport( _BcfWarnErr, "{sError} {sLap}:17 {$NaF} {sNotExecute}") ;
            bError = TRUE ;
         }
      }
     // devo rimettere i valori a posto
      sAppo = "F01" ;
      sAppo2 = "F02" ;
      nWid = $EW ;
      nRise = $ER ;
   }


   function ApplyFinishCutNoBrake( string sMainFaceFeat) : BOOL
   {
      bool   bMustExecuteRecess = FALSE ;
      bool   bWorkOtherFace = FALSE ;
      bool   bSideBlade = FALSE ;
      num    nAppoPri ;
      num    nFaces ;
      num    nI ;
      string sLastFace = "" ;
      vec3   v3LastDir ;
      string sAppoFace = "" ;

      nAppoPri = nPri ;

      SetPriorityBlade( $Np, sMainFaceFeat) ;
      // taglio di lama su tutte le facce
      nI = 2 ;
      nFaces = 1 ;
      while( nI < MAX_FFACE) {
         sAppoFace = "F" + OPT( nI < 10, "0", "") + OUTSTR( "{nI}") ;
         // se esiste la faccia la lavoro
         if ( GETFACENORMAL( sAppoFace, &v3Appo)) then {
            // prima faccia che trovo
            if ( nFaces == 1) then {
               nFaces = nFaces + 1 ;
               // se rivolta verso l'alto applico di già la lavorazione
               if ( v3Appo.z == 0) then {
                  GETFACEBOX( sAppoFace, &ptMin, &ptMax) ;
                  // se sono in testa/coda cerco altra faccia rivolta verso l'esterno
                  if ( ( ptMin.x > $L-500  AND  v3Appo.x < 0)  OR  ( ptMax.x < 500  AND  v3Appo.x > 0)) then {
                     bWorkOtherFace = TRUE ;
                  }
                  // altrimenti applico direttamente
                  else {
                     sLastFace = sAppoFace ;
                     v3LastDir = v3Appo ;
                     // per sicurezza azzero il kit
                     sKit = "" ;
                     // taglio il primo lato
                     bSuffWorkPerp = TRUE ;
                     CalculateToolDir( sLastFace, sMainFaceFeat) ;
                     bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                     ExecuteBladeCont( sLastFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
                  }
               }
               elsif ( v3Appo.z >= 0) then {
                  sLastFace = sAppoFace ;
                  v3LastDir = v3Appo ;
                  // per sicurezza azzero il kit
                  sKit = "" ;
                  // taglio il primo lato
                  bSuffWorkPerp = TRUE ;
                  CalculateToolDir( sLastFace, sMainFaceFeat) ;
                  bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                  ExecuteBladeCont( sLastFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
               }
               // se è verso il basso mi salvo solo la direzione
               else {
                  sLastFace = sAppoFace ;
                  v3LastDir = v3Appo ;
               }
            }
            // seconda faccia che trovo
            elsif ( nFaces == 2) then {
               // se prima era rivolta verso il basso
               if ( v3LastDir.z < 0  OR  bWorkOtherFace) then {
                  // se la faccia attuale è rivolta verso l'alto
                  if ( v3Appo.z >= 0) then {
                     // per sicurezza azzero il kit
                     sKit = "" ;
                     // taglio il primo lato
                     bSuffWorkPerp = TRUE ;
                     CalculateToolDir( sAppoFace, sMainFaceFeat) ;
                     bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                     ExecuteBladeCont( sAppoFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
                     if ( NOT bError) {
                        // se prima era rivolta verso l'alto allora controllo solo che le due facce siano parallele
                        if ( CROSS( v3LastDir, v3Appo) == VEC3(0,0,0)) then {
                           // taglio il secondo lato
                           bSuffWorkPerp = TRUE ;
                           CalculateToolDir( sAppoFace, sMainFaceFeat) ;
                           bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                           GETKITDATA( sKit, _ToolThick, 0, &nDiamBladeAtt) ;
                           SETKITDEPTH( nDiamBladeAtt - $EW) ;
                           ExecuteBladeCont( sAppoFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
                           // esco dal ciclo
                           nI = MAX_FFACE + 1 ;
                        }
                     }
                  }
               }
               else {
                  // se prima era rivolta verso l'alto allora controllo solo che le due facce siano parallele
                  if ( CROSS( v3LastDir, v3Appo) == VEC3(0,0,0)) then {
                     // taglio il secondo lato
                     bSuffWorkPerp = TRUE ;
                     CalculateToolDir( sLastFace, sMainFaceFeat) ;
                     bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                     GETKITDATA( sKit, _ToolThick, 0, &nDiamBladeAtt) ;
                     SETKITDEPTH( nDiamBladeAtt - $EW) ;
                     ExecuteBladeCont( sLastFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
                     // esco dal ciclo
                     nI = MAX_FFACE + 1 ;
                  }
                  // se direzione diversa devo applicare di nuovo
                  else {
                     if ( v3Appo.z >= 0) then {
                        // per sicurezza azzero il kit
                        sKit = "" ;
                        // taglio il primo lato
                        bSuffWorkPerp = TRUE ;
                        CalculateToolDir( sAppoFace, sMainFaceFeat) ;
                        bSideBlade = OPT( ABS( $Np.z) > ABS( $Np.y), FALSE, TRUE) ;
                        ExecuteBladeCont( sAppoFace, nInvert, nToolDir, bSideBlade, FALSE, FALSE, sMainFaceFeat) ;
                     }
                  }
               }
            }
         }
         nI = nI + 1 ;
      }
      nPri = nAppoPri ;

      return TRUE ;
   }

   procedure FindKitRecess()
   {
      bool   bMustExecuteRecess = FALSE ;
      num    nDepth = 0 ;
      num    nFaces ;
      num    nI ;
      num    nAppoPri = 0 ;
      string sFaces = "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
      string sFace[6] ;

     // se non devo fare finitura o se la fresa è uguale alla larghezza della feature o feature lunga, non faccio contornatura ma solo svuotatura
      if ( ( C_nExecuteRecessFinish != 1)  AND ( $EW != nToolDiam OR C_nExecuteRecessFinish == 3)  AND  NOT( bLongFeat)) then {
         sKit = C_sPrefCont + sToolKit ;

        // se fessura frontale( 3017) o mortasa frontale (3051)
         if ( $Caf == 3017 OR $Caf == 3051) then
            SETKITRISE( $ER) ;
         if ( CheckTiltedFace( sFaces, FALSE)) then {
            bSuffWorkPerp = TRUE ;
            nFaces = GETCANONICFACES( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
            nI = 2 ;
            if ( nFaces > 1) then {
               while ( nI <= nFaces) {
                  if ( $AL >= 80 AND $AL <= 100) then
                     SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                  else
                     SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                  CheckInOut( sKit) ;
                  CalculateToolDir( "F01", sFace[nI]) ;
                  VerifyAndSetStep( sKit, 0, FALSE) ;
                  InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                  nI = nI + 1 ;
               }
            }
         }
         else {
           // se voglio fare la finitura ed ho già abilitato il flag per lavorare i ribassi con lama se possibile
            if ( C_nExecuteRecessFinish == 3  AND  C_bMakeRecessWithBlade) then {
               bMustExecuteRecess = ApplyFinishCutNoBrake( "F01") ;
            }
           // se macchina senza carrelli e lavorazione verticale
            elsif ( $Np.z == 1  AND  NOT( bMachineWithCarr)  AND  ( $AL != 0 AND $AL != 180 AND $AL != 360)) then {
              // mi salvo la priorità dell'utensile
               nAppoPri = nPri ;
               nPri = C_nPriBla ;
               SetPriorityBlade( $Np, "F02") ;

               GETFACEHVREXT( "F02", &nEaH, &nEaV, &nEaR) ;
               FindBlade( "F02", FALSE, TRUE, nEaV, nEaH, 0, _bForceComplete) ;

               GETFACENORMAL( sFaces, &v3Appo) ;
               SetPriorityBlade( v3Appo, sFaces) ;
               SETKITDEPTH( 0) ;
               InsertKit( C_vsNomeKitBlade[nBladeIndex], sFaces, nPosXFeat, nPri) ;
               bMustExecuteRecess = TRUE ;
               nPri = nAppoPri ;
            }
            else {
               if ( $AL >= 80 AND $AL <= 100) then
                  SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
               else
                  SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
               CheckInOut( sKit) ;
               CalculateToolDir( sFaces, "F01") ;
               VerifyAndSetStep( sKit, 0, FALSE) ;
               InsertKit( sKit, sFaces, nPosXFeat, nPri) ;
            }
         }
      }
      else
         bMustExecuteRecess = TRUE ;

      bNotOrt = FALSE ;
      sFaces = "F01" ;
      sFaceWorked = sFaces ;
     // se fessura frontale( 3017) o mortasa frontale (3051)
      if ( $Caf == 3017 OR $Caf == 3051) then
         SETKITRISE( $ER) ;

      if ( $EW > ( nToolDiam * 2)  OR  bMustExecuteRecess) then {
         if ( $ER > nToolLen) then {
            bError = TRUE ;
            SETKITDEPTH( nToolLen - $ER) ;
         }
         else
            bError = FALSE ;

         sKit = C_sPrefSvuot + sToolKit ;
         SETKITDEPTH( 0) ;

         if ( C_nExecuteRecessFinish == 3  AND  $EW-1 >= nToolDiam) then
            SETKITCONTOURDIST( 0.5) ;

         CalculateHeadSolution( $N1) ;
         VerifyAndSetStep( sKit, 0, FALSE) ;
         InsertKit( sKit, sFaces, nPosXFeat, nPri) ;
      }

      nVotoFeature = 5 ;
      if ( C_nExecuteRecessFinish == 3  AND  C_bMakeRecessWithBlade  AND  ABS( $NP.z) < 0.707) then
         nVotoFeature = nVotoFeature - 1 ;

      SetVotoFeatureRibasso( $N1) ;

      if ( bError) then
         OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
      bMustExecuteRecess = FALSE ;
   }

   // ritorna il nome della faccia di riferimento per lavorazioni con mortasatrice o con lama
   function GetReferenceFace( string sFaceP, num nVerZ) : STRING
   {
      num    nFaces ;
      num    nI ;
      num    nArea = 0 ;
      num    nBigArea = 0 ;
      num    nDistToBorder ;
      num    nPosYLoc = 0 ;
      string sFace[6] ;
      string sRefFace = "" ;
      vec3   v3AppoFaceTemp ;
      vec3   v3AppoLoc ;

      nFaces = GETCANONICFACES( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
      nI = 1 ;

     // se faccia principale verticale e direzione verticale, cerco faccia con normale in Z nulla
      if ( ABS( nVerZ) < 0.05  AND  ( $AV == 90 OR $AV == 270)) then {
         while ( nI <= nFaces) {
            if ( STRSTR( sFaceP, sFace[nI]) <= 0) then {
               GETFACENORMAL( sFace[nI], &v3AppoFaceTemp) ;
               if ( v3AppoFaceTemp.z == 0) then {
                  if ( sRefFace == "") then
                     sRefFace = sFace[nI] ;
                  else {
                    // se sono sulle teste, tengo il motore verso l'esterno
                     if ( nPosXFeat < 700  AND v3AppoFaceTemp.x < 0) then
                        sRefFace = sFace[nI] ;
                     if ( nPosXFeat > $L-700  AND v3AppoFaceTemp.x > 0) then
                        sRefFace = sFace[nI] ;
                  }
               }
              // se non c'è una faccia con il versore Z della normale nullo mi salvo quella rivolta verso l'alto
               if ( v3AppoFaceTemp.z > 0) then {
                  nArea = GetFaceArea( sFace[nI], sFace[1]) ;
                  if ( nArea > nBigArea) then {
                     nBigArea = nArea ;
                     sRefFace = sFace[nI] ;
                  }
               }
            }
            nI = nI + 1 ;
         }
      }
     // se faccia principale verticale e direzione orizzontale, cerco faccia con normale verso l'alto
      elsif ( ABS( nVerZ) < 0.05) then {
         while ( nI <= nFaces) {
            if ( sFace[nI] != sFaceP) then {
               GETFACENORMAL( sFace[nI], &v3AppoFaceTemp) ;
               if ( $AV == 0 OR $AV == 180 OR $AV == 360) then {
                  if ( v3AppoFaceTemp.z == 1) then
                     return sFace[nI] ;
               }
               else {
                  if ( v3AppoFaceTemp.z >= 0) then {
                     nArea = GetFaceArea( sFace[nI], sFace[1]) ;
                     if ( nArea > nBigArea) then {
                        nBigArea = nArea ;
                        sRefFace = sFace[nI] ;
                     }
                  }
               }
            }
            nI = nI + 1 ;
         }
      }
     // se faccia principale verso l'alto cerco quella più grande o quella che tiene il motore più verso l'esterno
      else {
         while ( nI <= nFaces) {
           // non controllo la faccia principale
            if ( sFace[nI] != sFaceP) then {
              // caso speciale 132. Scelgo faccia che mi lascia meno distanza da bordo
               if ( $CL == 132) then {
                  v3AppoLoc = CROSS( $N1, $N2) ;
                  GETFACENORMAL( sFace[nI], &v3AppoFaceTemp) ;
                 // se feature longitudinale
                  if ( ABS( v3AppoLoc.x) > ABS( v3AppoLoc.y) ) then {
                    // calcolo posizione media in Y, perchè non ce l'ho
                     nPosYLoc = ( $Pmin.y + $Pmax.y) / 2 ;
                    // cerco faccia con normale verso Y-
                     if ( nPosYLoc <= $W/2  AND  v3AppoFaceTemp.y < 0) then
                        sRefFace = sFace[nI] ;
                    // cerco faccia con normale verso Y-
                     elsif ( nPosYLoc > $W/2  AND  v3AppoFaceTemp.y > 0) then
                        sRefFace = sFace[nI] ;
                  }
                 // se trasversale
                  else {
                    // cerco faccia con normale verso Y-
                     if ( nPosXFeat <= $L/2  AND  v3AppoFaceTemp.x < 0) then
                        sRefFace = sFace[nI] ;
                    // cerco faccia con normale verso Y-
                     elsif ( nPosXFeat > $L/2  AND  v3AppoFaceTemp.x > 0) then
                        sRefFace = sFace[nI] ;
                  }
               }
              // gestione standard
               else {
                  GETFACENORMAL( sFace[nI], &v3AppoFaceTemp) ;
                  if ( v3AppoFaceTemp.z >= 0) then {
                     nArea = GetFaceArea( sFace[nI], sFace[1]) ;
                     if ( nArea > nBigArea) then {
                        nBigArea = nArea ;
                        sRefFace = sFace[nI] ;
                     }
                  }
               }
            }
            nI = nI + 1 ;
         }
      }
      if ( sRefFace == "") then
         bError = TRUE ;
      return sRefFace ;
   }

   procedure SetLeadInOutMort( string sMainFace, vec3 v3NMainFace)
   {
      bool   bOpenS = FALSE ;
      bool   bOpenE = FALSE ;
      string sNameRefFace = "" ;

      sNameRefFace = GetReferenceFace( sMainFace, v3NMainFace.z) ;
      if ( NOT( bError)) then {
        // gestione speciale mortasatrice
         GETTOOLDIR( sMainFace, sNameRefFace, &nToolDir, &v3NMainFace, &bOpenE, &bOpenS) ;
         SETKITDIR( nToolDir) ;
         if ( bOpenS) then
            SETKITLEADINTANG( nLargMort / 2) ;
         if ( bOpenE) then
            SETKITLEADOUTTANG( nLargMort / 2) ;
      }
   }

   // ritorna sempre la faccia 1. La lavorazione di lama viene gestita come una contornatura
   function SearchFaceToWork() : STRING
   {
      num    nFaces ;
      num    nI ;
      num    nReferenceVal ;
      string sFace[6] ;
      string sResult ;

      nFaces = GETCANONICFACES( &sFace[1], &sFace[2], &sFace[3], &sFace[4], &sFace[5], &sFace[6]) ;
      bMore2FaceBladeCont = FALSE ;
      if ( nFaces == 2) then
         sResult = "F01" ;
      elsif ( nFaces == 3 OR C_bForceContWithBlade) then
         sResult = "F01" ;
      elsif ( nFaces == 4) then {
         sResult = "F01,F02" ;
         bMore2FaceBladeCont = TRUE ;
      }
      elsif ( nFaces == 5) then {
         sResult = sFace[1] ;
         GETFACEFACEANGLW( sFace[1], sFace[2], &nAng, &nReferenceVal, &nWid) ;
         nReferenceVal = MIN( nReferenceVal, nWid) ;
         nI  = 2 ;
         while ( nI <= nFaces) {
            GETFACEFACEANGLW( sFace[nI], sFace[1], &nAng, &nLen, &nWid) ;
            if ( ABS( nReferenceVal - nLen) < 0.5) then {
               sResult = sResult + "," + sFace[nI] ;
            }
            nI = nI + 1 ;
         }
         bMore2FaceBladeCont = TRUE ;
      }
      else {
         bError = TRUE ;
         OutputReport( _BcfWarnErr, "{sError} {sLap}:18 {$NaF} {sNotExecute}") ;
         return "" ;
      }
      return sResult ;
   }


// ----------- FUNZIONI PER TAGLI LONGITUDINALI -------------------
   procedure ExecuteCutLongWithBlade( string sNameKit, string sFaceToWork, num nPriority, vec3 v3NormFaceCut, bool bOverMat)
   {
      num nNumeroPassate = 0 ;
      num nAltezzaPasso = 0 ;
      num nPassata = 1 ;
      num nDeltaZ = 0 ;
      num nCompZ = 0 ;
      num nMoltiplicatore = 1 ;
      num nZLimit = 0 ;

     // sui tagli longitudinali doppi viene aumentato lo step di taglio
      if ( $CL > 340) then
         nMoltiplicatore = 1.4 ;
     // se vale 0 metto un valore altissimo
      if ( C_nStepLongCut == 0) then
         C_nStepLongCut = 1000 ;
      nNumeroPassate = MAX( CEIL( $EW / ( C_nStepLongCut * nMoltiplicatore)), 1) ;

     // se macchina con carrelli e taglio verso il basso forzo di non affondare
      if ( bMachineWithCarr  AND  NOT( bOverMat)  AND  ( v3NormFaceCut.z < 0  OR  $Pmin.z < 2)  AND  NOT( C_bCanUseSubPiece)) then
         bOverMat = TRUE ;

      while ( nPassata <= nNumeroPassate) {
         nCompZ = SQRT( ( v3NormFaceCut.x * v3NormFaceCut.x) + ( v3NormFaceCut.y * v3NormFaceCut.y)) ;
         nDeltaZ = $EW * nCompZ ;
         nAltezzaPasso = MIN( ( C_nStepLongCut * nMoltiplicatore), $EW / nNumeroPassate) * nPassata * nCompZ ;
         if ( nPassata == nNumeroPassate  AND  bOverMat) then {
            GETKITDATA( sNameKit, _ToolThick, 0, &nRise) ;
           // se il taglio è verso l'alto
            if ( v3NormFaceCut.z > 0) then
               nZLimit = 0.3 ;
            else {
              // se doppio taglio longitudinale
               if ( $CL > 340  AND  $CL < 350) then
                  nZLimit = 0 ;
               else
                  nZLimit = ( nRise + 1) * SIN( ASIN( ABS( v3NormFaceCut.z))) ;
            }
            SETKITDEPTH( nAltezzaPasso - nDeltaZ - nZLimit) ;
            SETKITZBENDING( nAltezzaPasso - nDeltaZ - nZLimit) ;
         }
         else {
            if ( $AS > 180  OR  $AS == 0) then {
               if ( v3NormFaceCut.z > 0.995) then
                  nZLimit = 0 ;
               else
                  nZLimit = 2 ;
               SETKITDEPTH( nAltezzaPasso - nDeltaZ + nZLimit) ;
               SETKITZBENDING( nAltezzaPasso - nDeltaZ + nZLimit) ;
            }
            else {
               SETKITDEPTH( nAltezzaPasso - nDeltaZ) ;
               SETKITZBENDING( nAltezzaPasso - nDeltaZ) ;
            }
         }
         InsertKit( sNameKit, sFaceToWork, nPosXFeat, nPriority) ;
         nPassata = nPassata + 1 ;
      }
   }

   procedure ExecuteSquadBeam( string sFaceToWork)
   {
      num nMaxMatTool ;

     // lavorazione con lama
      if ( $P04 == 1) then {
         FindBlade( sFaceToWork, FALSE, TRUE, $EW, $EL, 0, _bForceComplete) ;
         nPri = CheckPriSmallPiece( C_nPriBla + ( C_nDeltaSquad * MAX( $HP, $MP))) ;
         ExecuteCutLongWithBlade( C_vsNomeKitBlade[nBladeIndex] , sFaceToWork, nPri, $N1, FALSE) ;
      }
     // lavorazione con fresa
      elsif ( $P04 == 2) then {
         SETKITDIR( _Nord) ;
         if ( NOT( C_bTableForWall)) then
            SETKITDEPTH( 5) ;
        // uso tutto il massimo materiale della fresa
         GETKITDATA( C_sNameContSmusso, _ToolMaxMat, 1, &nMaxMatTool) ;
         SETKITSTEP( nMaxMatTool) ;
         nPri = CheckPriSmallPiece( C_nPriBla + ( C_nDeltaSquad * MAX( $HP, $MP)) - 350) ;
         InsertKit( C_sNameContSmusso, sFaceToWork, nPosXFeat, nPri) ;
      }
   }


   procedure AddContOtherFace()
   {
      string sName = ""  ;
      num nDirCont1 ;
      num nDirCont2 ;
      num nPriOtherFace ;


      if ( ( $E1H != $L  AND  $Caf != 1010)  AND  ( $AS >= 180 OR $AS == 0)) then {
         sName =  C_sPrefCont + sToolKit ;
         bSuffWorkPerp = TRUE ;
         nPri = nPri - 1 ;
         if ( $N1.z >= 0) then {
            if ( GETFACENORMAL( "F05", &v3appo)) then
               CalculateToolDir( "F01", "F05") ;
            else {
               SETKITDIR( _NearXp) ;
               SETKITOVERMAT( -3) ;
            }
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sName) ;
            InsertKit( sName, "F01", nPosXFeat, nPri) ;
            if ( GETFACENORMAL( "F07", &v3appo)) then
               CalculateToolDir( "F03", "F07") ;
            else {
               SETKITDIR( _NearXm) ;
               SETKITOVERMAT( -3) ;
            }
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sName) ;
            InsertKit( sName, "F03", nPosXFeat, nPri) ;
         }
         if ( ISSETVAR( $N2)) then {
            if ( $N2.z != 0) then {
               if ( GETFACENORMAL( "F06", &v3appo)) then
                  CalculateToolDir( "F02", "F06") ;
               else {
                  SETKITDIR( _NearXp) ;
                  SETKITOVERMAT( -3) ;
               }
               SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sName) ;
               InsertKit( sName, "F02", nPosXFeat, nPri) ;
               if ( GETFACENORMAL( "F08", &v3appo)) then
                  CalculateToolDir( "F04", "F08") ;
               else {
                  SETKITDIR( _NearXm) ;
                  SETKITOVERMAT( -3) ;
               }
               SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sName) ;
               InsertKit( sName, "F04", nPosXFeat, nPri) ;
            }
         }
      }
   }

   // ritorna il nome del kit
   function FindKitCutLong( vec3 v3Norm, string sNameFace) : STRING
   {
      num    nZLimit = 0 ;
      num    nZLimitHead = 0 ;
      num    nZLimitHeadB = 0 ;
      num    nZLimitCollClamps = 0 ;
      num    nYLimit = 0 ;
      num    nAngleFaceWork = 0 ;
      num    nOtherAngle = 0 ;
      num    nDiffRadHeadTool = 0 ;
      num    nDistY ;
      string sNameKit = "" ;

     // prima cerco una fresa dedicata al taglio longitudinale
      bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_LCut, _nForceToolToUse) ;
      if ( NOT bToolFind) then
         bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;

      if ( bToolFind) then {
         sNameKit = C_sPrefCont + sToolKit ;

         GETFACEBOX( sNameFace, &ptMin, &ptMax) ;

        // differenza tra raggio ingombro naso mandrino e raggio utensile
         nDiffRadHeadTool = ( C_nDiamNasoMandrino / 2)  -  ( nToolDiam / 2) ;
        // angolo della faccia da lavorare ( calcolato tra la faccia sopra della trave e la faccia del taglio longitudinale)
         nAngleFaceWork = 90 - ASIN( v3Norm.z) ;
        // angolo complementare
         nOtherAngle = ASIN( v3Norm.z) ;
        // distanza tra il punto più basso del naso mandrino e il punto più basso della faccia da lavorare ( in Z)
         nZLimit = ( SIN( nAngleFaceWork) * nToolLen)  -  ( $T - ptMin.z) ;
        // distanza tra il centro del naso mandrino e il centro dell'utensile ( in Y)
         nYLimit = COS( nAngleFaceWork) * nToolLen ;
        // distanza tra nYLimit e il punto più vicino allo spigolo del grezzo
         if ( ABS( nOtherAngle) != 0  AND  ABS( nOtherAngle) != 90  AND  ABS( nOtherAngle) != 270) then
            nDistY = ( SIN( nAngleFaceWork) * nToolLen) / TAN( nOtherAngle) ;
         else
            nDistY = 0 ;
        // calcolo la distanza tra il punto più basso del motore e l'appoggio del pezzo. Il motore deve stare più alto delle morse ( circa 140mm)
         nZLimitHead = ( SIN( nAngleFaceWork) * ( nToolLen + nTHLen + C_nCollDist1)) + C_nSicurezza ;
         nZLimitHeadB = ( COS( nAngleFaceWork) * (( C_nDiamMotore - nToolDiam) / 2 )) ;
         nZLimitCollClamps = $Pmin.z + ( nZLimitHead - nZLimitHeadB) ;

        // primo test   : la lunghezza della faccia da lavorare deve essere più piccola della lunghezza utensile
        // secondo test : controllo che il naso manrino sia più alto rispetto allo spessore del pezzo
        // terzo test   : controllo che il naso mandrino sia al di fuori del grezzo rispetto alla larghezza
        // quarto test  : controllo che rimanga sempre più alto delle morse orizzontali o che non abbia i carrelli
         if ( $EW < ( nToolLen - 10)  AND  ( nZLimit > ( sin( nOtherAngle) * nDiffRadHeadTool) + C_nSicurezza
            OR ( nYLimit + nDistY) > ( $W + C_nSicurezza))  AND  ( nZLimitCollClamps > C_nAltezzaMorseO  OR  NOT( bMachineWithCarr))) then {
           // se fresa dedicata ai tagli longitudinali è meglio lavorare perpendicolare ( deve avere anche un diametro maggiore di 200mm)
            if ( $Caf != 1010  AND  VerifyTypeTMach( _TypeTMach_LCut, C_vnTypeMachUse[nToolIndex])  AND  nToolDiam > 200) then {
               bSuffWorkPerp = TRUE ;
               bSide = FALSE ;
            }
            else {
               bSide = TRUE ;
            }
         }
         else {
            if ( $Np.z > 0.259) then {
               bSuffWorkPerp = TRUE ;
               bSide = FALSE ;
            }
            else {
               bSide = TRUE ;
            }
         }

         if ( $E1H == $L  OR  $Caf == 1010) then {
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sNameKit) ;
            sNameKit = sNameKit ;
         }
         else {
            SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sNameKit) ;
            sNameKit = sNameKit ;
            bPerp = TRUE ;
         }
      }

      return sNameKit ;
   }

   procedure SetParamCutLong( num nDirection, vec3 v3Norm, string sKitAppo)
   {
      num nStep ;
      num nStepToUse ;
      num nAreaPerStep ;

     // se concavo
      if ( ( $AS < 180  AND $AS != 0)  AND  $CL > 340) then {
         SETKITDEPTH( 0) ;
         SETKITOVERMAT( 0) ;
      }
     // se verticale (passo a zero sui carrelli)
      elsif ( $Pmin.z < 5  AND  v3Appo.z >= 0  AND  bMachineWithCarr) then {
         SETKITDEPTH( 0) ;
         SETKITOVERMAT( 0) ;
      }
     // se convesso
      elsif ( ( $AS >= 180 OR $AS == 0) AND NOT( bSide)) then {
         GETKITDATA( sKitAppo, _KitStep, 0, &nStep) ;
         nStep = CEIL( $ER / MAX( nStep, C_nSecurityStep)) ;
         if ( nStep > 1) then {
            nAreaPerStep = ( ( $E1V * $E1R) / 2) / nStep ;
            nStepToUse = CEIL( nAreaPerStep / $E1V) * 2 ;
            SETKITRISE( ( nStepToUse * (nStep - 1)) + 1) ;
            SETKITSTEP( nStepToUse) ;
         }
         if ( $Pmin.z < 5) then
            SETKITOVERMAT( 0.2) ;
         else
            SETKITOVERMAT( -5) ;
         SETKITDEPTH( 0) ;
      }
      else {
         if ( bSide) then {
            if ( NOT( C_bTableForWall)) then
               SETKITDEPTH( 5) ;
         }
         SETKITOVERMAT( 0) ;
      }
     // se lavorazione perpendicolare devo allungare componente perpendicolare per evitare di entrare nel pezzo con la testa dell'utensile
     // if ( bPerp) then
      //   SETKITLEADINPERP( nToolDiam) ;
      if ( nDirection != 0) then {
         if ( $Caf == 1010) then
            SETKITDIR( _NearYm) ;
         else
            SETKITDIR( nDirection) ;
      }
   }

   procedure CheckInOutCutLong( string sKitCutLong, num nEstVerFace)
   {
      num nRaggioFresa ;

      if ( bPerp) then {
         GETKITDATA( sKitCutLong, _ToolDiam, 1, &nRaggioFresa) ;
         nRaggioFresa = nRaggioFresa / 2 ;
         SETKITLEADINPERP( nEstVerFace + nRaggioFresa + 10) ;
      }
   }

   procedure AddFace( string sKitTemp, string sAppoFace, string sAppoSecFace, num nVertEst, vec3 v3NLCut)
   {
      num nFeed ;
      string sKitNotToModify = "" ;

      VerifyAndSetStep( sKitTemp, 0, FALSE) ;
     // abbasso la priorità per farlo eseguire alla fine
      nPri = 100 ;
      GETFACENORMAL( sAppoFace, &v3Appo) ;
     // aumento la feed di lavoro se taglio longitudinale molto piccolo
      if ( $CL == 322  OR  $CL == 342  OR  $CL == 343  OR  $CL == 344) then {
         GETKITDATA( sKitTemp, _ToolFeed, 0, &nFeed) ;
         if ( bSide  AND  C_bIncreaseFeedBlade) then
            SETKITFEED( nFeed * 2) ;
      }

      if ( bSide) then {
         if ( nVertEst >= nToolLen - 20) then {
            if ( nToolDiam  >  C_nDiamMotore) then {
               InsertKit( sKitTemp, sAppoFace, nPosXFeat, nPri) ;
            }
            else {
               bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, sAppoFace, sAppoSecFace, _TypeTMach_Rib, _nForceToolToUse) ;
               CalculateHeadSolution( v3Appo) ;
               InsertKit( C_sPrefSvuot + sToolKit, sAppoFace, nPosXFeat, nPri) ;
            }
         }
         else {
            InsertKit( sKitTemp, sAppoFace, nPosXFeat, nPri) ;
         }
      }
      else {
         if ( $Caf != 1010  AND  ( ( nVertEst >= ( nToolDiam * 2) AND $AS <= 180 AND $AS != 0) OR ( nVertEst >= ( nToolDiam * 1.9) AND ( $AS >= 180 OR $AS == 0)))) then {
            CalculateHeadSolution( v3Appo) ;
            InsertKit( C_sPrefSvuot + sToolKit, sAppoFace, nPosXFeat, nPri) ;
         }
         else {
           // SETKITFLIPSIDE( TRUE) ;
            VerifyAndSetStep( sKitTemp, 40, TRUE) ;
            if ( GETFACEHVREXT( sAppoFace, &nEaH, &nEaV, &nEaR)) then
               SETKITRISE( nEaR) ;
            SetParamCutLong( _Nord, v3NLCut, sKitTemp) ;
            InsertKit( sKitTemp, sAppoFace, nPosXFeat, nPri) ;
           // SETKITFLIPSIDE( TRUE) ;
            if ( nVertEst > ( nToolDiam - 5)) then {
               if ( $E1H == $L) then
                  SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKitNotToModify) ;
               else
                  SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sKitNotToModify) ;
               VerifyAndSetStep( sKitTemp, 40, TRUE) ;
              // lavorazioni sulla prima faccia
               CheckInOutCutLong( sKitTemp, nVertEst) ;
              // inverto la direzione
               if ( nToolDir == _Nord) then
                  SetParamCutLong( _Sud, v3NLCut, sKitTemp) ;
               else
                  SetParamCutLong( _Nord, v3NLCut, sKitTemp) ;
               SETKITOVERMAT( -5) ;
               SETKITRISE( nEaR) ;
               InsertKit( sKitTemp, sAppoFace, nPosXFeat, nPri) ;
            }
         }
      }
   }


   procedure AddCutLong( string sAppoKit, string sFaceToWork, string sOtherFace, num nAppoVExt, num nNFace, vec3 nAppoNFace)
   {
      if ( $CL < 340) then {
         if ( nAppoNFace.z >= 0  OR  NOT( bMAchineWithCarr)) then {
            CheckInOutCutLong( sAppoKit, nAppoVExt) ;
            SetParamCutLong ( _Nord, nAppoNFace, sAppoKit) ;
            AddFace( sAppoKit, sFaceToWork, sOtherFace, nAppoVExt, nAppoNFace) ;
         }
         elsif ( nAppoNFace.z < 0  AND  nLengthFeat <= ( C_nLenLongFeat * 2)) then {
            CheckInOutCutLong( sAppoKit, nAppoVExt) ;
            SetParamCutLong ( _Nord, nAppoNFace, sAppoKit) ;
            AddFace( sAppoKit, sFaceToWork, sOtherFace, nAppoVExt, nAppoNFace) ;
            OutputReport( _BcfWarn, "{sAttention} {sLongCut}: {$Naf} {sNotComplete}") ;
         }
         else
            OutputReport( _BcfWarnErr, "{sError} {sLongCut}:19 {$NaF} {sNotExecute}") ;
      }
      else {
        // se cnvesso
         if ( $AS >= 180  OR  $AS == 0) then {
            if ( nAppoNFace.z > 0  OR  NOT( bMAchineWithCarr)) then {
               CheckInOutCutLong( sAppoKit, nAppoVExt) ;
               SetParamCutLong ( _Nord, nAppoNFace, sAppoKit) ;
               AddFace( sAppoKit, sFaceToWork, sOtherFace, nAppoVExt, nAppoNFace) ;
            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sLongCut}:20 {$NaF} {sNotExecute}") ;
         }
        // se concavo
         else {
            GETTOOLDIR( sFaceToWork, sOtherFace, &nToolDir, &v3ToolDir) ;
            CheckInOutCutLong( sAppoKit, nAppoVExt) ;
            if ( v3ToolDir.z < 0  AND  bSide) then {
               bSuffWorkPerp = TRUE ;
               SetParamCutLong ( nToolDir, nAppoNFace, sAppoKit) ;
               bSide = FALSE ;
            }
            else {
               bSide = TRUE ;
               SetParamCutLong ( nToolDir, nAppoNFace, sAppoKit) ;
            }
            AddFace( sAppoKit, sFaceToWork, sOtherFace, nAppoVExt, nAppoNFace) ;
         }
      }
   }

// -------------- FUNZIONI PER PROFILO ARCUATO --------------------

   // ritorna il massimo materiale della fresa (per decidere il numero di passate)
   function SetParamProf( num nLarg, bool bProfilDouble) : NUM
   {
      num nMaxDepthFre ;

      nMaxDepthFre = nToolLen ;
      sKit = C_sPrefCont + sToolKit ;
     // se mi trovo su un lato allora attacco tangente, altrimenti attacco direttamente sul profilo
      if ( $Pmin.x < 10  OR  $Pmin.y < 10  OR  ABS( $Pmax.x - $L) < 10   OR  ABS( $Pmax.y - $W) < 10) then
         SetLeadInOutCont( FALSE, _Clg_Tangente, _Clg_Tangente, &sKit) ;
      else
         SetLeadInOutCont( FALSE, _Clg_Nessuno, _Clg_Nessuno, &sKit) ;

      if ( bProfilDouble) then {
         if ( nLarg < nMaxDepthFre) then
            SETKITDEPTH( MIN( OPT( C_bTableForWall, 0, 10), nMaxDepthFre - nLarg)) ;
         else
            SETKITDEPTH( MIN( -( nLarg / 2) + 2, nMaxDepthFre - nLarg)) ;
         if ( ( nLarg / 2) > nMaxDepthFre) then {
            OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$Naf} {sNotComplete}") ;
            nAppo2 = 1 ;
         }
      }
      else {
         if ( nLarg < nMaxDepthFre) then
            SETKITDEPTH( MIN( OPT( C_bTableForWall, 0, 10), nMaxDepthFre - nLarg)) ;
         else {
            OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$Naf} {sNotComplete}") ;
            SETKITDEPTH( ( nMaxDepthFre - nLarg)) ;
         }
      }

      return nMaxDepthFre ;
   }

   procedure FindKitProf( string sFace)
   {
      bool bProfilDouble = FALSE ;
      bool bOk ;
      num nLarghezza = 0 ;
      num nMaxDepthCont ;
      num nMaxDepthFre ;
      num nTypeMach ;
      num nFirstDir ;
      num nSecondDir ;
      num nJ ;
      vec3 v3AppoDirSide ;

      bOk = TRUE ;

      if ( $CL > 600  AND  $CL < 699) then {
         nTypeMach = nStandard ;
         v3AppoDirSide = VEC3(0, 1, 0) ;
         if ( $Nf > 1) then {
            nI = 1 ;
            sFace = "" ;
            while ( nI <= MAX_FFACE) {
               nJ = 1 ;
               while ( nJ <= $Nsf[nI]) {
                  sFace = sFace + OPT( ( nI < 10), Outstr( "F0{nI}"), Outstr( "F{nI}")) +
                                 OPT( ( $Nsf[nI] == 1), "", Outstr( "_{nJ}")) + "," ;
                  nJ = nJ + 1 ;
               }
               nI = nI + 1 ;
            }
         }
      }
      else {
         nTypeMach = nProfil ;
         v3AppoDirSide = VEC3(0, 0, 1) ;
      }

      bToolFind = FindTool( nRadiusFeat, nTypeMach, 1, "F01", "F02,F03", _TypeTMach_Prof, _nForceToolToUse) ;

      if ( bToolFind) then {
         if ( $CL > 600 AND $CL < 699) then {
           // se piede di camoscio abbasso priorità
            if ( $CL == 611) then
               nPri = nPri - 1 ;
            if ( $F == 1 OR $F == 3) then {
               v3AppoDirSide = VEC3(0, 0, 1) ;
               nLarghezza = $T ;
               if ( nLarghezza < nToolLen) then
                  nVotoFeature = 4 ;
               else
                  nVotoFeature = 1 ;
               nFirstDir = _Nord ;
            }
            else {
               v3AppoDirSide = VEC3(0, 1, 0) ;
               bProfilDouble = TRUE ;
               nLarghezza = $W ;
              // se feature lunga abbasso priorità per fare in modo di lavorarla piatta, se possibile
               if ( bLongFeat) then {
                 // se feature lunga e normale verso il basso non si può lavorare
                  GETFACENORMAL( "F01", &v3Appo) ;
                  if ( v3Appo.z < 0) then
                     nVotoFeature = 0 ;
                  else
                     nVotoFeature = 2 ;
               }
               else
                  nVotoFeature = OPT( bVeryShortBeam, 0 , OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 1), 5)) ;
               nFirstDir = _NearYp ;
               nSecondDir = _NearYm ;
            }
            if ( ( ( nPosXFeat > $L / 2  AND  $McLeftLoad)  OR  ( nPosXFeat < $L / 2  AND  NOT( $McLeftLoad))) AND  C_bExecuteMeasure) then
               nManagementFlag = _Last ;
         }
         elsif ( ( $CaF >= 3100  AND  $CaF <= 3106)  OR  $CaF == 3949) then {
            if ( $F == 1 OR $F == 3) then {
              // direzione utensile calcolando di applicare una lavorazione con parametro _Nord
               if ( ( $F == 3 AND $S == 2)  OR  ( $F == 1 AND $S == 1)) then {
                  v3AppoDirSide = VEC3( 0, -1, 0) ;
                  nFirstDir = _NearYm ;
                  nSecondDir = _NearYp ;
               }
               else {
                  v3AppoDirSide = VEC3( 0, 1, 0) ;
                  nFirstDir = _NearYp ;
                  nSecondDir = _NearYm ;
               }

               nLarghezza = $W ;
               bProfilDouble = TRUE ;
               if ( $Np.z > 0) then
                  nVotoFeature = OPT( bVeryShortBeam, 1, OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 1, 2), 5)) ;
               else
                  nVotoFeature = OPT( bShortBeam, 1, 2) ;
            }
            else {
               nFirstDir = _Nord ;
               v3AppoDirSide = VEC3( 0, 0, 1) ;
               nLarghezza = $T ;
               if ( nLarghezza < nToolLen) then
                  nVotoFeature = 3 ;
               else
                  nVotoFeature = 1 ;
            }
            if ( ( ( nPosXFeat > $L / 2  AND  $McLeftLoad)  OR  ( nPosXFeat < $L / 2  AND  NOT( $McLeftLoad))) AND  C_bExecuteMeasure) then
               nManagementFlag = _Last ;
         }
         elsif ( $CL == 221) then {
            GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid) ;
            nLarghezza = nLen ;
         }
         nMaxDepthCont = SetParamProf( nLarghezza, bProfilDouble) ;

         CalculateHeadSolution( v3AppoDirSide) ;

         if ( nLarghezza >= nMaxDepthCont) then
            bOk = FALSE ;

         VerifyAndSetStep( sKit, 40, FALSE) ;

         SETKITDIR( nFirstDir) ;
         if ( C_bExecuteSgroProfil) then
            SETKITSTEP( 0) ;
        // lavoro discorde portando fuori il truciolo ( tranne dal sopra)
         if ( nFirstDir != _Nord) then
            SETKITFLIPSIDE() ;
         InsertKit( sKit, sFace, nPosXFeat, nPri) ;
         if ( NOT( bOk)) then {
            if ( bProfilDouble) then {
               SetParamProf( nLarghezza, bProfilDouble) ;
               VerifyAndSetStep( sKit, 40, FALSE) ;
             //  if ( nPosXFeat > $L / 2) then
                  SETKITDIR( nSecondDir) ;
             //  else
             //     SETKITDIR( nFirstDir) ;
               CalculateHeadSolution( v3AppoDirSide) ;
               bSuffSolOpp = NOT( bSuffSolOpp) ;
               if ( C_bExecuteSgroProfil) then
                  SETKITSTEP( 0) ;
              // lavoro discorde portando fuori il truciolo
               SETKITFLIPSIDE() ;
               InsertKit( sKit, sFace, nPosXFeat, nPri) ;
            }
            else
               OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$Naf} {sNotComplete}") ;
         }
      }
      else
         OutputReport( _BcfWarnErr, "{sError} {sProfile}:21 {$Naf} {sNotExecute}") ;
   }

   procedure FindKitProf2( string sFace, num nOverMat)
   {
      bool bProfilDouble = FALSE ;
      bool bBigTool = TRUE ;
      bool bVeryBigTool = FALSE ;
      bool bOk ;
      num nLarghezza = 0 ;
      num nMaxDepthCont ;
      num nMaxDepthFre ;
      num nTypeMach ;
      num nFirstDir ;
      num nSecondDir ;
      vec3 v3AppoDirSide ;

      bOk = TRUE ;

      nTypeMach = nProfil ;
      v3AppoDirSide = VEC3( 0, 0, 1) ;

      if ( ( ( $F != 1  OR  C_bCarrTurn)  AND  NOT( bVeryShortBeam))  OR  $F == 3) then {
         bToolFind = FindTool( nOpenFeat, nTypeMach, 1, "F01", "F02,F03", _TypeTMach_Prof, _nForceToolToUse) ;
        // se il diametro utensile è più grande del limite per lavorare dico che è grande
         bBigTool = OPT( nToolDiam > C_nLimitRadiusProfile, TRUE, FALSE) ;
        // se il diametro è il doppio di quello che userò per finitura
         bVeryBigTool = OPT( nToolDiam > ( C_nLimitRadiusProfile * 2 * 2), TRUE, FALSE) ;
      }
      else {
         bToolFind = FindTool( nRadiusFeat, nTypeMach, 1, "F01", "F02,F03", _TypeTMach_Prof, _nForceToolToUse) ;
         bBigTool = FALSE ;
      }

      if ( bToolFind) then {
         if ( $CL > 600 AND $CL < 699) then {
           // se piede di camoscio abbasso priorità
            if ( $CL == 611) then
               nPri = nPri - 1 ;
            if ( $F == 1 OR $F == 3) then {
               v3AppoDirSide = VEC3(0, 0, 1) ;
               nLarghezza = $T ;
               if ( nLarghezza < nToolLen) then
                  nVotoFeature = 4 ;
               else
                  nVotoFeature = 1 ;
               nFirstDir = _Nord ;
            }
            else {
               v3AppoDirSide = VEC3(0, 1, 0) ;
               bProfilDouble = TRUE ;
               nLarghezza = $W ;
               nVotoFeature = OPT( bVeryShortBeam, 0 , OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 1), 5)) ;
               nFirstDir = _NearYp ;
               nSecondDir = _NearYm ;
            }
            if ( ( nPosXFeat > $L / 2  AND  $McLeftLoad)  OR  ( nPosXFeat < $L / 2  AND  NOT( $McLeftLoad))) then
               nManagementFlag = _Last ;
         }
         elsif ( ( $CaF >= 3100  AND  $CaF <= 3106)  OR  $CaF == 3949) then {
            if ( $F == 1 OR $F == 3) then {
              // direzione utensile calcolando di applicare una lavorazione con parametro _Nord
               if ( ( $F == 3 AND $S == 2)  OR  ( $F == 1 AND $S == 1)) then {
                  v3AppoDirSide = VEC3( 0, -1, 0) ;
                  nFirstDir = _NearYm ;
                  nSecondDir = _NearYp ;
               }
               else {
                  v3AppoDirSide = VEC3( 0, 1, 0) ;
                  nFirstDir = _NearYp ;
                  nSecondDir = _NearYm ;
               }

               nLarghezza = $W ;
               bProfilDouble = TRUE ;
               if ( $Np.z > 0) then
                  nVotoFeature = OPT( bVeryShortBeam, 1, OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 1, 2), 5)) ;
               else
                  nVotoFeature = OPT( bShortBeam, 1, 2) ;
            }
            else {
               nFirstDir = _Nord ;
               v3AppoDirSide = VEC3( 0, 0, 1) ;
               nLarghezza = $T ;
               if ( nLarghezza < nToolLen) then
                  nVotoFeature = 3 ;
               else
                  nVotoFeature = 1 ;
            }
         }
         elsif ( $CL == 221) then {
            GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid) ;
            nLarghezza = nLen ;
         }
         nMaxDepthCont = SetParamProf( nLarghezza, bProfilDouble) ;
         CalculateHeadSolution( v3AppoDirSide) ;
         if ( nLarghezza >= nMaxDepthCont) then
            bOk = FALSE ;

         VerifyAndSetStep( sKit, OPT( bBigTool, OPT( bVeryBigTool, 75, 55), 40), FALSE) ;
         SETKITDIR( nFirstDir) ;
         SETKITOVERMAT( nOverMat) ;
        // se sgrossatura porto sempre fuori ( tranne dal sopra)
         if ( nFirstDir != _Nord) then
            SETKITFLIPSIDE() ;
         InsertKit( sKit, sFace, nPosXFeat, nPri) ;
         if ( NOT( bOk)) then {
            if ( bProfilDouble) then {
               SetParamProf( nLarghezza, bProfilDouble) ;
               VerifyAndSetStep( sKit, OPT( bBigTool, OPT( bVeryBigTool, 75, 55), 40), FALSE) ;
               SETKITDIR( nSecondDir) ;
               CalculateHeadSolution( v3AppoDirSide) ;
               bSuffSolOpp = NOT( bSuffSolOpp) ;
               SETKITOVERMAT( nOverMat) ;
              // se sgrossatura porto sempre fuori
               SETKITFLIPSIDE() ;
               InsertKit( sKit, sFace, nPosXFeat, nPri) ;
            }
         }
      }
   }

  // ----------------- FUNZIONI PER TENONE -------------------------

  // se TRUE è stata fatta svuotatura
   function ExecutePocket() : BOOL
   {
      bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Ten, _nForceToolToUse) ;

      if ( $Dt > nToolDiam) then {
         bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
         SETKITRISE( $P11) ;
         CalculateHeadSolution( $N1) ;
         SETKITCONTOURDIST( 10) ;
         InsertKit( C_sPrefSvuot + sToolKit, "F01", nPosXFeat, nPri) ;
         bPock = TRUE ;
      }
      else
         bPock = FALSE ;
      return bPock ;
   }


// ----------------- FUNZIONI PER INCASTRO -------------------------

  // ritorna il nome della faccia principale, quella su cui applicare le lavorazioni
   function ChangeValueVariables( bool bFaces, bool bChangeFaces) : STRING
   {
      string sNameFace = "" ;
      num    nAngF2 ;
      num    nLenF2 ;
      num    nWidF2 ;

     // lavoro la faccia 1 di fianco
      if ( bFaces) then {
         sNameFace = "F01" ;
         nAppo = $E1R ;
         $E1R = $EW ;
         $EW = nAppo ;
      }
     // lavoro faccia 2 di fianco
      if ( bChangeFaces) then {
         sNameFace = "F02" ;
         GETFACEFACEANGLW( "F02", "F01", &nAngF2, &nLenF2, &nWidF2) ;
         $E1R = nWidF2 ;
      }
     // lavoro faccia 1 perpendicolarmente
      else
         sNameFace = "F01" ;

      return sNameFace ;
   }

   // ritorna il versore utensile
   function SetJointDirection( bool bChangeFaces, bool bCheckNormal) : VEC3
   {

      if ( bCheckNormal) then {
         GETTOOLDIR( "F02", "F01", &nToolDir, &v3ToolDir) ;
         return v3ToolDir ;
      }
      else {
         if ( bChangeFaces) then
            GETTOOLDIR( "F02", "F01", &nToolDir, &v3ToolDir) ;
         else
            GETTOOLDIR( "F01", "F02", &nToolDir, &v3ToolDir) ;
         SETKITDIR( nToolDir) ;
      }
      return $N2 ;
   }

   procedure ExecutePocketJoint( bool bExecute)
   {
      string sFaceToWork = "" ;

      if ( ( $N1.z >= 0  OR  C_bHeadFromSide)  AND  bExecute) then {
         bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
        // contornatura
         if ( $EW <= nToolDiam  AND  $AS >= 91) then {
           // se perpendicolare vuol dire che è già stato fatto
            if ( NOT( bPerp) OR  $AS >= 91) then {
               sKit = C_sPrefCont + sToolKit ;
               if ( $AL >= 80 AND $AL <= 100) then {
                  SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                  bSuffWorkPerp = TRUE ;
               }
               else {
                  SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                  bSuffWorkPerp = TRUE ;

               }
               bSuffWorkPerp = TRUE ;

               if ( $E1R >= nToolLen) then {
                  OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
                  SETKITDEPTH( nToolLen - $E1R) ;
               }
               CalculateToolDir( "F01", "F02") ;
               InsertKit( sKit, "F01", nPosXFeat, nPri) ;
            }
         }
        // seconda passata di contornatura
         elsif ( $EW < nToolDiam * 2 - 5  AND  $EW > nToolDiam AND  $AS < 92  AND  C_nExecuteRecessFinish == 2) then {
            sKit = C_sPrefCont + sToolKit ;
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
            if ( bPerp) then {
               bSuffWorkPerp = TRUE ;
            }

            if ( $E1R >= nToolLen) then {
               OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
               SETKITDEPTH( nToolLen - $E1R) ;
            }
            VerifyAndSetStep( sKit, 0, FALSE) ;
            SETKITLEADINTANG( ( nToolDiam / 2) + 5) ;
            SETKITLEADOUTTANG( nToolDiam / 2) ;
            SETKITOVERMAT( $EW - nToolDiam + 5) ;
            CheckInOut( sKit) ;

           // la passata devo farla prima di quella antischeggia. Dato che devo inserirla successivamente, faccio finta che cambia la posizione.
            if ( $McLeftLoad) then
               nPosXAppo = nPosXFeat + 1 ;
            else
               nPosXAppo = nPosXFeat - 1 ;
            if ( bChangedFaceToWork) then {
               sFaceToWork = "F02" ;
               CalculateToolDir( sFaceToWork, "F01") ;
               InsertKit( sKit, sFaceToWork, nPosXAppo, nPri) ;
            }
            else {
               sFaceToWork = "F01" ;
               CalculateToolDir( sFaceToWork, "F02") ;
               InsertKit( sKit, sFaceToWork, nPosXAppo, nPri) ;
            }
         }
        // svuotatura
         elsif ( $EW >= ( nToolDiam - 1)) then {
            sKit = C_sPrefSvuot + sToolKit ;
            CalculateToolDir( "F02", "F01") ;
            if ( $E1R >= nToolLen) then {
               OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
               SETKITDEPTH( nToolLen - $E1R) ;
            }
            InsertKit( sKit, "F01", nPosXFeat, nPri) ;
         }
         else
            OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
      }
      elsif ( bExecute) then
         OutputReport( _BcfWarnErr, "{sError} {sNotch}:22 {$NaF} {sNotExecute}") ;
   }

  // TRUE se le facce sono state invertite, cioè la lavorazione è da eseguire sulla faccia 2 anzichè 1
   function AddContFirstFace() : BOOL
   {
      string sFaceToWork = "" ;
      bool   bFace = FALSE ;
      bool   bChangeFace = FALSE ;
      bool   bWorkFace1 ;
      num    nTDir = 0 ;
      vec3   v3DirToolFace2 ;
      vec3   v3TDir ;

      bPerp = FALSE ;
      sKit = C_sPrefCont + sToolKit ;

      if ( $AL >= 80 AND $AL <= 100) then
         SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
      else
         SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;

     // cerco soluzione migliore per lavorare
   //   if ( $Pmax.x > C_nDistHeadInca  OR  $Pmin.x < $L - C_nDistHeadInca) then {
         bWorkFace1 = FALSE ;
         if ( nPosXFeat < $L / 2) then {
            if ( $N1.x > 0) then {
               if ( ABS( $N1.x) > 0.5) then
                  bWorkFace1 = TRUE ;
            }
            else {
               if ( ABS( $N2.x) > 0.5) then
                  bWorkFace1 = FALSE ;
            }
         }
         else {
            if ( $N1.x > 0) then {
               if ( ABS( $N2.x) > 0.5) then
                  bWorkFace1 = FALSE ;
            }
            else {
               if ( ABS( $N1.x) > 0.5) then
                  bWorkFace1 = TRUE ;
            }
         }
   /*   }
      else {
         if ( ABS( $N1.x) > 0.707) then
            bWorkFace1 = TRUE ;
         else
            bWorkFace1 = FALSE ;
      }*/

      if ( bWorkFace1) then {
         bFace = TRUE ;
         GETTOOLDIR( "F01", "F02", &nTDir, &v3TDir) ;
         CheckInOut( sKit) ;
      }
      else {
         v3DirToolFace2 = SetJointDirection( bChangeFace, TRUE) ;
         bChangeFace = TRUE ;
         if ( ABS( v3DirToolFace2.x) < 0.866) then {
            GETTOOLDIR( "F02", "F01", &nTDir, &v3TDir) ;
            CheckInOut( sKit) ;
         }
         else {
            GETTOOLDIR( "F01", "F02", &nTDir, &v3TDir) ;
            bSuffWorkPerp = TRUE ;
            bPerp = TRUE ;
            CheckInOut( sKit) ;
         }
      }

      if ( v3TDir.z >= 0  OR  C_bHeadFromSide) then {
         sFaceToWork = ChangeValueVariables( bFace, bChangeFace) ;

        // controllo per non sbattere il mandrino contro la trave
         if ( $E1R > nToolLen) then {
            nAppo = nToolLen - $E1R ;
            SETKITDEPTH( nAppo) ;
         }
         VerifyAndSetStep( sKit, 0, FALSE) ;
         SetJointDirection( bChangeFace, FALSE) ;
         CalculateHeadSolution( v3ToolDir) ;
         InsertKit( sKit, sFaceToWork, nPosXFeat, nPri) ;
         
         if ( $E1R > nToolDiam) then {
            GETFACENORMAL( sFaceToWork, &v3Appo) ;
            if ( v3Appo.z > 0) then {
               CalculateHeadSolution( v3Appo) ;
               sKit = C_sPrefSvuot + sToolKit ;
               InsertKit( sKit, sFaceToWork, nPosXFeat, nPri) ;
            }
         }
      }
      else
         bError = TRUE ;

      AddContSecondFace( bChangeFace) ;

      return bChangeFace ;
   }

   procedure AddContSecondFace( bool bChangeFaces)
   {
      vec3 v3DirFace2 ;
      vec3 v3Dir ;
      num  nMaxDepth  = 0 ;
      num  nTdir = 0 ;

      if ( NOT( bChangeFaces) AND $AS >= 91) then {
         GETFACEFACEANGLW( "F02", "F01", &nAng, &nLen, &nWid) ;
         if ( $CL == 221) then {
            bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
            nMaxDepth = nToolLen ;
            if ( ABS( $N2.z) > 0.7071  OR  ABS( $N2.x) > 0.7071) then {
               GETTOOLDIR( "F01", "F02", &nTDir, &v3Dir) ;
               if ( nWid < ( nToolDiam - 1)) then {
                  sKit = C_sPrefCont + sToolKit ;
                  SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                  bSuffWorkPerp = TRUE ;
               }
               else {
                  GETFACENORMAL( "F02", &v3Appo) ;
                  CalculateHeadSolution( v3Appo) ;
                  sKit = C_sPrefSvuot + sToolKit ;
               }
            }
            else {
               GETTOOLDIR( "F02", "F01", &nTDir, &v3Dir) ;
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
            }
         }
         else {
            bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib, _nForceToolToUse) ;
            nMaxDepth = nToolLen ;
            nPri = nPri + 10 ;
            if ( ABS( $N2.z) > 0.7071  OR  ABS( $N2.x) > 0.7071) then {
               GETTOOLDIR( "F02", "F01", &nTDir, &v3Dir) ;
               if ( nWid < ( nToolDiam - 1)) then {
                  sKit = C_sPrefCont + sToolKit ;
                  SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sKit) ;
                  bSuffWorkPerp = TRUE ;
               }
               else {
                  GETFACENORMAL( "F02", &v3Dir) ;
                  CalculateHeadSolution( v3Dir) ;
                  sKit = C_sPrefSvuot + sToolKit ;
               }
            }
            else {
               GETTOOLDIR( "F02", "F01", &nTDir, &v3Dir) ;
               sKit = C_sPrefCont + sToolKit ;
               SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sKit) ;
            }
         }

         CheckInOut( sKit) ;

         if ( v3Dir.z >= 0) then {
            SetJointDirection( NOT( bChangeFaces), FALSE) ;
            if ( bSuffWorkPerp) then {
               if ( $EW > nMaxDepth) then {
                  SETKITDEPTH( nMaxDepth - $EW) ;
                  OutputReport( _BcfWarn, "{sAttention} {sNotch}: {NaF} {sNotComplete}") ;
               }
            }
            else {
               GETFACEFACEANGLW( "F02", "F01", &nAng, &nLen, &nWid) ;
               if ( nWid > nMaxDepth) then {
                  SETKITDEPTH( nMaxDepth - nWid) ;
                  OutputReport( _BcfWarn, "{sAttention} {sNotch}: {NaF} {sNotComplete}") ;
               }
            }
            InsertKit( sKit, "F02", nPosXFeat, nPri) ;
         }
         else
            OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
      }
   }


// ------------------ FUNZIONI PER SMUSSO --------------------------

   procedure ExecuteChamfer()
   {
      string sNameChamfer = C_sNameContSmusso ;
      string sNameFirstFace = "" ;
      string sNameSecondFace = "" ;

      nPri = CheckPriSmallPiece( 90) ;
     // se è una feature  "smusso"
      if ( $CaF == 3036) then {
         sNameFirstFace = "F02" ;
         sNameSecondFace = "F03" ;
         SETKITDIR( _Nord) ;
         SETKITDEPTH( 5) ;
         InsertKit( sNameChamfer, sNameFirstFace, nPosXFeat, nPri) ;
         SETKITDIR( _Nord) ;
         SETKITDEPTH( 5) ;
         InsertKit( sNameChamfer, sNameSecondFace, nPosXFeat, nPri) ;
      }
     // se è un  "taglio longitudinale"  che si deve lavorare come uno  "smusso"
      else {
         sNameFirstFace = "F01,F03" ;
         sNameSecondFace = "F02,F04" ;

         if ( $N1.z > 0) then {
            SETKITDEPTH( 5) ;
            SETKITDIR( _Nord) ;
            InsertKit( sNameChamfer, sNameFirstFace, nPosXFeat, nPri) ;
         }
         else
            OutputReport( _BcfWarnErr, "{sError} {sLongCut}:23 {$NaF} {sNotExecute} -> {sNameFirstFace}") ;
         if ( ISSETVAR( $N2)) then {
            if ( $N2.z > 0) then {
               SETKITDEPTH( 5) ;
               SETKITDIR( _Nord) ;
               InsertKit( sNameChamfer, sNameSecondFace, nPosXFeat, nPri) ;
            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sLongCut}:24 {$NaF} {sNotExecute} -> {sNameSecondFace}") ;
         }
      }
   }

// --------------- FUNZIONI PER CONCAVE E CONVESSE -----------------

   procedure ExecuteContConcConv()
   {
      num   nDistance ;

      bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Prof, _nForceToolToUse) ;
      sKit = C_sPrefCont + sToolKit ;

     // lavorazione faccia 1 ( sempre di testa)
      if ( GETFACENORMAL( "F01", &v3Appo)  AND  $P12 != 0) then {
        // se devo fare con la lama ( non posso dal sotto)
         if ( C_bUseBladeOnProfil  AND  $F != 1) then {
            sAppo = "F01" ;
            sAppo2 = "F02" ;
            GETFACEHVREXT( sAppo, &nEaH, &nEaV, &nEaR) ;

            FindBlade( sAppo2, FALSE, TRUE, nEaH, nEaR, 0, _bForceComplete) ;
            SetPriorityBlade( $Np, "F01") ;
            SETKITLEADINPERP( 0) ;
            SETKITLEADOUTPERP( 0) ;
            SETKITLEADINTANG( 1) ;
            SETKITLEADOUTTANG( 1) ;
            SETKITLEADINLENC( nEaH + 30) ;
            SETKITLEADOUTLENC( nEaH + 30) ;
            bSuffWorkPerp = TRUE ;
            CalculateToolDir( sAppo, sAppo2) ;
            SETKITPERPENDICULAR( TRUE) ;
            
            InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
            SETKITLEADINPERP( 0) ;
            SETKITLEADOUTPERP( 0) ;
            SETKITLEADINTANG( 1) ;
            SETKITLEADOUTTANG( 1) ;
            SETKITLEADINLENC( nEaR + 30) ;
            SETKITLEADOUTLENC( nEaR + 30) ;
            CalculateToolDir( sAppo, sAppo2) ;
            FindBlade( sAppo, FALSE, TRUE, nEaR, nEaH, 0, _bForceComplete) ;
            InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
            nVotoFeature = 3 ;
         }
        // se con fresa
         else {
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
            VerifyAndSetStep( sKit, 0, TRUE) ;
            CalculateToolDir( "F01", "F02") ;
            InsertKit( sKit, "F01", nPosXFeat, nPri) ;
         }
      }

     // lavorazione faccia 3
      if ( GETFACENORMAL( "F03", &v3Appo)  AND  $P15 != 0) then {
        // se devo fare con la lama ( non posso dal sotto)
         if ( C_bUseBladeOnProfil  AND  $F != 1) then {
            sAppo = "F03" ;
            sAppo2 = "F02" ;
            GETFACEHVREXT( sAppo, &nEaH, &nEaV, &nEaR) ;

            FindBlade( sAppo2, FALSE, TRUE, nEaH, nEaR, 0, _bForceComplete) ;
            SetPriorityBlade( $Np, "F01") ;
            SETKITLEADINPERP( 0) ;
            SETKITLEADOUTPERP( 0) ;
            SETKITLEADINTANG( 1) ;
            SETKITLEADOUTTANG( 1) ;
            SETKITLEADINLENC( nEaH + 30) ;
            SETKITLEADOUTLENC( nEaH + 30) ;
            bSuffWorkPerp = TRUE ;
            CalculateToolDir( sAppo, sAppo2) ;
            SETKITPERPENDICULAR( TRUE) ;
            
            InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
            SETKITLEADINPERP( 0) ;
            SETKITLEADOUTPERP( 0) ;
            SETKITLEADINTANG( 1) ;
            SETKITLEADOUTTANG( 1) ;
            SETKITLEADINLENC( nEaR + 30) ;
            SETKITLEADOUTLENC( nEaR + 30) ;
            CalculateToolDir( sAppo, sAppo2) ;
            FindBlade( sAppo, FALSE, TRUE, nEaR, nEaH, 0, _bForceComplete) ;
            InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
            nVotoFeature = 3 ;
         }
        // se con fresa
         else {
            if ( v3Appo.z >= 0) then {
               SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
               if ( nPosXFeat >= ( $L / 2)) then
                  nDistance = $L - $Pmin.x ;
               else
                  nDistance = $Pmax.x ;

               VerifyAndSetStep( sKit, 0, TRUE) ;
              // cerco di lavorare di testa
               if ( nDistance <= nToolLen OR $Np.z < 0) then {
                  if ( GETTOOLDIR( "F03", "F02", &nToolDir)) then {
                     CalculateToolDir( "F03", "F02") ;
                     bSuffWorkPerp = TRUE ;
                    // se feature dal sotto abbasso priorita' e metto a zero l'elevazione
                     nVotoFeature = 1 ;
                     SETKITRISE( 0) ;
                     InsertKit( sKit, "F03", nPosXFeat, nPri) ;
                  }
               }
               else {
                  if ( GETTOOLDIR( "F03", "F02", &nToolDir)) then {
                     CalculateToolDir( "F03", "F02") ;
                     InsertKit( sKit, "F03", nPosXFeat, nPri) ;
                  }
               }
            }
            else
               OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$NaF} {sNotComplete}") ;
         }
      }
   }

// --------------- FUNZIONI GIUNTO SPECIALE -----------------

procedure ExecuteSpecialJoint( bool bSinglePassage, num nInteraxFinger, num nNumberFingerMill, num nDepthMach, string sJointKit)
{
   num nNumberFinger = 0 ;
   num nOverMatL = 0 ;
   num nOverMatMill = 0 ;
   num nNumPassages = 0 ;
   num nI = 0 ;


   if ( $F == 3  OR  $F == 1) then {
      nPri = 50 ;
      nVotoFeature = 5 ;
     // se singolo passaggio centrale
      if ( bSinglePassage) then {
         SETKITDIR( _Nord) ;
         SETKITDEPTH( -( $T / 2)) ;
         InsertKit( sJointKit, "F01", nPosXFeat, nPri) ;
      }
     // se si deve eseguire il massimo di denti possibili
      else {
         nNumberFinger = FLOOR( $T / nInteraxFinger) ;
        // calcolo prima passata
         if ( $P04 == 1) then {
            nOverMatL = ( $T - ( nNumberFinger * nInteraxFinger)) / 2 ;
            nOverMatMill = nOverMatL ;
         }
         else
            nOverMatL = ( $T - ( nNumberFinger * nInteraxFinger)) / 2 + ( nInteraxFinger / 2) ;

         while ( ( nI <= nNumberFinger  AND  $P04 == 1)  OR  ( nI < nNumberFinger  AND  $P04 == 2)) {
            SETKITOVERMAT( -( ABS( nDepthMach / 2))) ;
            SETKITDEPTH( - nOverMatL) ;
            SETKITDIR( _Nord) ;
            InsertKit( sJointKit, "F01", nPosXFeat, nPri) ;
            SETKITOVERMAT( -( ABS( nDepthMach))) ;
            SETKITDEPTH( - nOverMatL) ;
            SETKITDIR( _Nord) ;
            InsertKit( sJointKit, "F01", nPosXFeat, nPri) ;
            nI = nI + nNumberFingerMill ;
           // se sto eseguendo la femmina ( se necessario) devo accavallare l'ultima passata a quella precedente
            if ( $P04 == 2  AND  ( nI + nNumberFingerMill) > nNumberFinger) then
               nOverMatL = nOverMatL + ( nNumberFinger - nI) * nInteraxFinger ;
            else
               nOverMatL = nOverMatL + ( nNumberFingerMill * nInteraxFinger) ;
         }
        // passaggi di rimozione denti non completi, con fresa ( solo se maschio)
         if ( $P04 == 1) then {
            bToolFind = FindTool( nRadiusFeat, nStandard, 1, "F01", "F02", _TypeTMach_Rib, _nForceToolToUse) ;
            sKit = C_sPrefCont + sToolKit ;
            SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
            bSuffWorkPerp = TRUE ;
           // contornatura parte sotto
            SETKITOVERMAT( -( nOverMatMill)) ;
            SETKITDIR( _Nord) ;
            SETKITDEPTH( nDepthMach) ;
            InsertKit( sKit, "F01", nPosXFeat, nPri) ;
           // contornatura parte sopra
            SETKITOVERMAT( -( nToolDiam - nOverMatMill)) ;
            SETKITDIR( _Sud) ;
            SETKITDEPTH( nDepthMach) ;
            InsertKit( sKit, "F01", nPosXFeat, nPri) ;
         }
      }
   }
   else {
      nPri = 0 ;
      nVotoFeature = 0 ;
   }
}

// ======== Istruzioni immediate =============================================
{

}