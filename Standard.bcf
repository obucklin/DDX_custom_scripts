//
// Configurazione Standard lavorazione automatiche travi   06/02/2012
//
// 31.07.07 v4.2F1 DS Creazione file.
// 18.09.07 v4.2F2 AV Tutte le condizioni sono state riportate da .mcf a .bcf.
// 08.10.07 v4.2F3 AV Calcolo affondamento massimo delle forature.
// 23.10.07 v4.2F4 AV Con fresa grande partenza sui tenoni e contornature al di fuori della trave.
// 10.01.08 v4.2F5 AV Cambiata gestione classe su tagli di lama. Prima versione delle nuove condizioni.
//                    Prima versione gestione "Pezzi piccoli". Con modifica priorità e gestione rotazioni( non ancora gestito da BEAM).
// 28.02.08 v4.2F6 AV Gestione feature "Frontali" con faccia ausiliaria (fessura, mortasa, mortasa coda di rondine).
// 29.02.08 v4.2F7 AV Gestione calcolo ribaltamenti per "gruppi" di foratura.
// 19.03.08 v4.3A1 DS Modifiche a ON_ROTATE di fori e di ribassi con mortasa.
// 20.03.08        DS Agg. gestione sol. opposta ai tenoni. Corr. calcolo sovram. sgross. mortase CR.
//                    Agg. stampa versione su debeg. Corr. su tagli singoli corner.
// 28.03.08 v4.3A2 AV Gestione lavorazione con lama in sostituzione della mortasatrice (creato kit) -> Soluzione abbandonata da 4.3C4 in poi.
// 01.04.08 v4.3A3 AV Gestione messaggi in diverse lingue.
// 18.04.08 v4.3A4 AV Prima versione tagli "da sotto" (creato kit) -> Soluzione abbandonata da 4.3C4 in poi.
// 29.04.08 v4.3B1 AV Serve EwdBeam v4.3c2 (agg. GetFaceBox).
// 05.06.08 v4.3C1 AV Spostate le funzioni nel file logico BCA.
// 13.06.08 v4.3C2 AV Gestione completa di Suprema (carico sx e dx) e PMT.
// 03.07.08 v4.3C3 AV Gestione completa di PM360.
// 22.07.08 v4.3C4 AV Gestita lama per lavorazioni di contornatura ( es. per tasche lavorabili con mortasatrice).
// 06.08.08 v4.3C5 AV Serve EwdBeam v4.3d9 (agg. SetKitFlipSide su tagli di lama).
//                 AV Gestiti fori con centrino( per forature lunghe senza preforo), la fresa associata lavora sia come punta sia interpolando.
// 26.09.08 v4.4B5 AV Gestione fori con "ribasso", usando la stessa procedura dei centrini.
// 07.10.08 v4.4B6 DS Modifiche a ON_FEATURE di incastri (se piccolo contornatura).
// 17.10.08 v4.4B7 AV Aggiunta gestione tasche passanti ( $CL 142) e gestione ribassi a C con svuotatura su facce ausiliarie.
// 05.11.08 v4.4B8 SV Prima versione con nuove funzioni nella sezione ON_DISP ( per posizionamento su tavole senza carrelli).
// 18.12.08 v4.4B9 AV Prima gestione rinvio da sotto per fori e ribassi.
// 05.03.09 v4.5A1 AV Possibilità scelta strategia per lavorazioni di lama e mortasatrice. ( Con lama ora è possibile rimanere nella geometria).
// 10.03.09 v4.5A2 AV Possibilità scelta svuotatura o marcatura ( contornatura) per lavorazioni con rinvio. Parametro  "C_bOptimizeRR".
// 23.03.09 v4.5A3 AV Corretta disposizione automatica dei pezzi su PM360.
//                    Migliorata gestione priorità. Per verificare se coda o testa, controllo variabile "nDistanceFromTail".
//                    Inserito comando diretto : "Pausa" dopo le forature. Gestione speciale per Stratex( MultL115).
// 26.03.09 v4.5A4 AV Migliorata gestione priorità. Viene controllata anche la "squadratura di lunghezza".
//                    Se una tasca non si riesce a lavorare con la lama, ora viene inserita una contornatura per segnarne la posizione.
// 14.04.09 v4.5A5 AV Nuova gestione ribassi.
// 08.05.09 v4.5B1 AV Prima versione scelta frese.( variabili fisse ora solo nelle rotazioni).
// 11.09.09 v4.5B2 AV Migliorata gestione rinvio, lavorazioni da sotto con scelta frese da lista.
// 24.11.09 v4.5B3 AV Prima versione gestione tagli a "cubetti".
// 19.02.10 v4.5B4 AV Nuova gestione per scelta "soluzione opposta".
// 30.03.10 v4.6A3 AV Gestione nuovo metodo calcolo lavorazioni ( tolta la parte ON_ROTATE).
// 04.10.10 v4.6A4 AV Gestione nuova lavorazione ( incastro a pettine) per Heko Spanten.
// 14.10.10 v4.6B1 AV Gestione nuova lavorazione per ribassi classe 142 grandi, sfinestratura con lama più mortasatrice negli spigoli.
// 14.01.11 v4.6C1 AV Utilizzata nuova varibile ($BcfStatus) per processare i comandi diretti solo durante l'applicazioni delle lavorazioni
// 16.02.11 v4.6D1 AV Spostata gestione comandi speciali per cliente nel BCP
// 24.06.11 v4.6D2 AV Prima versione gestione rotazioni che permettono carico pezzo verticale ( per il momento valore fisso)
// 12.09.11 v4.6D4 AV Gestione contornature con modifica degli attacchi e uscite.
//                 AV Nuova gestione migliorata per Tagli longitudinali, classe 300.
// 02.11.11 v4.6D5 AV Gestione soluzione opposta se  "bHeadFromSide"
//                 AV Gestione lama grande con assi bloccati se  "bHeadFromSide"
// 03.02.12 v4.8A1 VS Modifiche varie per macchina Hage.
// 06.02.12        DS Agg. gestione disposizione con sole morse davanti.
// 27.02.12 v4.8A2 AV Agg. gestione minimizzazione rapidi su forature.
// 20.03.12 v4.8C1 AV Prima versione gestione macchine per pareti
// 18.07.12 v4.8G3 MP Minimizzazione rapidi, priorità lama e inserimento fori per sheet
// 24.01.13 v4.9A1 AV Prima versione BCF-travi
// 29.07.14 v6.1A1 AV Prima versione gestione scelta lame
// 05.03.20 v6.7C1 AV Rimossa vecchia gestione lavorazioni in doppio
// 05.03.20 v6.7C1 AV Aggiunta nuova sezione BEG_INSKIT in ON_FEATURE per gestione speciale cliente
// 15.03.21 v6.8B5 DV Aggiunta possibilità di tenere entrata/uscita come kit se lavorati sheet
//
// -----------------------------------------------------------------------------


// MACCHINE GESTITE :
// - SUPREMA( 1 e 2 teste  -  Carico SX e DX),
// - PMT,
// - PM360,
// - MultL115,
// - Ultra( 2 teste - Carico DX),
// - Extra,
// - HageMatic405.
// -----------------------------------------------------------------------------


CONSTANTS     //----------------------------------------------------------------
// bool, num, string, vec3
   bool   bNewRot                     = TRUE ;             // TRUE se voglio utilizzare la nuova gestione per le lavorazioni ( senza ON_ROTATE)
   bool   _bForceNotComplete          = FALSE ;            // Per funzione che trova la lama, si accetta una lama anche se non lavora completamente
   bool   _bForceComplete             = TRUE ;             // Per funzione che trova la lama, si accetta una lama solo se lavora completamente
   num    BEAM_NO                     = 0 ;                // trave non lavorabile
   num    BEAM_STD                    = 1 ;                // trave normale
   num    BEAM_SMALL                  = 2 ;                // trave corta
   num    BEAM_SMALL_BIG              = 3 ;                // trave corta di sezione grande
   num    BEAM_ON_VAC                 = 4 ;                // trave su ventose
   num    MAX_FFACE                   = 16 ;               // massimo numero di facce in una feature
   num    _ON_PART_END                = 1 ;                // per funzioni speciali cliente: funzione chiamata alla fine della sezione "ON_PART"
   num    _ON_FEAT                    = 2 ;                // per funzioni speciali cliente: funzione chiamata nella sezione "ON_FEATURE"
   num    _ON_DISP                    = 3 ;                // per funzioni speciali cliente: funzione chiamata nella sezione "ON_DISP"
   num    _ON_DISP_ERR                = 4 ;                // per funzioni speciali cliente: funzione chiamata nella sezione "ON_DISP_ERR"
   num    _ON_END_FEAT                = 5 ;                // per funzioni speciali cliente: funzione chiamata nella sezione "ON_FEATURE" alla fine
   num    _BEFORE_INSKIT              = 6 ;                //  per funzioni speciali cliente: sezione "ON_FEATURE" prima di inserimento kit
   num    _AFTER_INSKIT               = 7 ;                // per funzioni speciali cliente: sezione "ON_FEATURE" dopo l'inserimento kit
   num    _ON_END_PART                = 8 ;                // per funzioni speciali cliente: funzione chiamata all'inizio della sezione "ON_END_PART"
   num    _ON_PART_BEG                = 9 ;                // per funzioni speciali cliente: funzione chiamata all'inizio della sezione "ON_PART"
   num    _BEG_INSKIT                 = 10 ;               //  per funzioni speciali cliente: sezione "ON_FEATURE" prima di inserimento kit, prima dei settaggi
   num    nInvert                     = 0 ;                // foro fatto con flag "inverti" (usato anche da altre funzioni)
   num    nNormal                     = 1 ;                // foro fatto normalmente (usato anche da altre funzioni)
   num    nProfil                     = 2 ;                // usato per ricavare i dati in lavorazione tipo profilatura
   num    nStandard                   = 3 ;                // usato per ricavare i dati in lavorazione tipo foratura
   num    nForceMaxRadius             = 4 ;                // usato per scegliere l'utensile con il diametro più grande, non considerando la prirità
   num    nOpenFeat                   = 10 ;               // Se non c'è problema di raggio
   num    nCheckDiamFeat              = 20 ;               // Se la fresa non può essere più grande della larghezza della feature
   num    nRadiusFeat                 = 30 ;               // se c'è il problema dei raggi sugli angoli
   num    _TaglioSopra                = 1 ;                // parametro usato per calcolare il voto della lavorazione. Indica un taglio da sopra
   num    _TaglioFianco               = 2 ;                // parametro usato per calcolare il voto della lavorazione. Indica un taglio corner
   num    _TaglioCubetti              = 3 ;                // parametro usato per calcolare il voto della lavorazione. Indica un taglio con cubetti
   num    _TaglioSvuota               = 4 ;                // parametro usato per calcolare il voto della lavorazione. Indica un taglio con kit svuotatura con fresa
   num    _ContFresa                  = 5 ;                // parametro usato per calcolare il voto della lavorazione. Indica una lavorazione di contornatura con fresa
   num    _SvuotaFresa                = 6 ;                // parametro usato per calcolare il voto della lavorazione. Indica una lavorazione di svuotatura con fresa
   num    _Clg_Lineare                = 1 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita lineare
   num    _Clg_AntiScheggia           = 2 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita antischeggia
   num    _Clg_Perpendicolare         = 3 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita perpendicolare
   num    _Clg_Tangente               = 4 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita tangente
   num    _Clg_Nessuno                = 5 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita nessuno
   num    _Clg_Kit                    = 6 ;                // parametro utilizzato per inserire una contornatura con accacco/uscita come da kit
   num    _ForoNessuno                = 1 ;                // parametro utilizzato per non inserire fori di pulizia spigoli
   num    _Foro90                     = 2 ;                // parametro utilizzato per inserire fori di pulizia spigoli solamente nei corner con inclinazione 90°
   num    _ForoIncl                   = 3 ;                // parametro utilizzato per inserire fori di pulizia spigoli solamente nei corner con inclinazione diversa da 90°
   num    _ForoTutti                  = 4 ;                // parametro utilizzato per inserire fori di pulizia spigoli sempre, indipendentemente dall'inclinazione del corner
   num    _TypeTMach_BH               = 1 ;                // Tipo di lavorazione richiesta ( quando si cercano le frese) -> BlockHaus
   num    _TypeTMach_Ten              = 2 ;                // Tipo di lavorazione richiesta ( quando si cercano le frese) -> Tenone
   num    _TypeTMach_Rib              = 4 ;                // Tipo di lavorazione richiesta ( quando si cercano le frese) -> Ribasso / Tasca
   num    _TypeTMach_CR               = 8 ;                // Tipo di lavorazione richiesta ( quando si cercano le frese) -> Coda di Rondine
   num    _TypeTMach_LCut             = 16 ;               // Tipo di lavorazione richiesta ( quando si cercano le frese) -> Fresa dedicata al taglio longitudinale
   num    _TypeTMach_Prof             = 32 ;               // Tipo di lavorazione richiesta ( quando si cercano le frese) -> Fresa dedicata ai profili
   string sVerBCF                     = "V.6.1A1" ;        // versione BCF
   string sVerBCA                     = "V.6.1A1" ;        // versione BCA
   vec3   _DirXp                      = vec3( 1, 0, 0) ;   // versore diretto verso X+
   vec3   _DirXm                      = vec3( -1, 0, 0) ;  // versore diretto verso X-

END_CONSTANTS

VARIABLES     //----------------------------------------------------------------
   // bool, num, string, vec3
   bool   bError                      = FALSE ;            // flag che indica se nei controlli si è verificato un errore
   bool   bRRUsed                     = FALSE ;            // flag che indica se è stato sato il rinvio speciale
   bool   bShortBeam ;
   bool   bVeryShortBeam ;
   bool   bPieceEnlarged              = FALSE ;
   bool   bLongFeat ;
   bool   bPock                       = FALSE ;
   bool   bCanDoubleHole              = FALSE ;            // flag che indica se è possibile eseguire una foratura doppia
   bool   bHole                       = FALSE ;            // se feature foro vale TRUE, altrimenti FALSE
   bool   bLongHole                   = FALSE ;            // TRUE se con preforo (da fare quindi il prima possibile)
   bool   bVeryLongHole               = FALSE ;            // se ho punte lunghe che devono per forza lavorare di fianco
   bool   bCanInvert                  = TRUE ;             // flag che indica se è possibile che la lavorazione possa essere invertita
   bool   bHoleInvert                 = FALSE ;            // flag che indica se la lavorazione di foratura è invertita
   bool   bBlade800                   = TRUE ;
   bool   bUseBlade                   = FALSE ;
   bool   bKX5                        = TRUE ;
   bool   bPerp                       = FALSE ;
   bool   bSide                       = FALSE ;
   bool   bNotOrt                     = FALSE ;
   bool   bIsTail                     = FALSE ;
   bool   bExistMort                  = FALSE ;
   bool   bExistBHTool                = FALSE ;
   bool   bCanUseMort                 = FALSE ;
   bool   bExecuteHole                = FALSE ;
   bool   bExecuteRecess              = FALSE ;
   bool   bExecuteProfilRecess        = FALSE ;
   bool   bBlade800Side               = FALSE ;
   bool   bAppo                       = FALSE ;            // bool di appoggio generico
   bool   bImpossibleToWork           = FALSE ;
   bool   bHoleToTop                  = FALSE ;            // fori da sopra
   bool   bDoubleHoleDone             = FALSE ;
   bool   bHoleSpe65                  = TRUE ;             // gestione speciale per foro da 65: si può usare solo se il foro è perpendicolare
   bool   bWorkLikeProfil             = FALSE ;
   bool   bHoleWithMill               = FALSE ;
   bool   bMachineWithCarr ;                               // flag che indica presenza carrelli: TRUE per macchine tipo Suprema, FALSE per macchine tipo PMT
   bool   bChangedFaceToWork          = FALSE ;
   bool   bNotFindAnotherKit          = FALSE ;
   bool   bHoleComplete               = FALSE ;
   bool   bMachNotComplete            = FALSE ;
   bool   bMachOK                     = FALSE ;
   bool   bMore2FaceBladeCont         = FALSE ;
   bool   bDecreasePriFor             = FALSE ;            // flag che decrementa la priorità per i fori orizzontali ( fatti dopo la squadratura)
   bool   bToolFind                   = FALSE ;            // flag che indica se è stato trovato l'utensile per la la lavorazione
   bool   bCutNoDepth                 = FALSE ;            // flag che forza a 0 l'affondamento sui tagli di lama ( mettere prima della funzione FindKitBlade)
   bool   bCutCubetti                 = FALSE ;            // flag per dire che la lama utilizzata serve per un taglio a cubetti
   bool   bSuffInvert ;                                    // indica se il kit da inserire necessita del flag inverti
   bool   bSuffSolOpp ;                                    // indica se il kit necessita del flag soluzione opposta
   bool   bSuffSolSpeHole ;                                // indica se il kit necessita del flag soluzione speciale per i fori
   bool   bSuffWorkPerp ;                                  // indica se il kit necessita del flag perpendicolare
   bool   bPathGeoInverted ;                               // indica se il kit è stato applicato ad un percorso con geometria invertita
   bool   bFirstShell                 = FALSE ;            // se sto eseguendo i tagli ortogonali nella prima shell
   bool   bExecuteCubetti             = FALSE ;            // se devo eseguire il taglio a cubetti
   bool   bCubettiUsed                = FALSE ;            // indica se nella feature è stata calcolata almeno una volta la cubettatura
   bool   bSplitRowPart               = FALSE ;            // se devo tagliare in più parti uno sfrido troppo lungo
   bool   bMustExecuteCubetti         = FALSE ;            // se si dovrebbero creare i cubetti, ma non possono essere creati (Es: normale negativa della faccia principale)
   bool   bCutMore                    = FALSE ;            // se voglio prolungare il taglio di circa 5 millimetri per essere sicuro di tagliare completamente
   bool   bCutLess                    = FALSE ;            // se voglio ridurre il taglio di circa 2 millimetri per essere sicuro di non rovinare la superficie perpendicolare
   bool   bAcuteAngle                 = FALSE ;            // se cubettatura < 90°
   bool   bCutComplete                = FALSE ;            // se lavoro la feature CLASSE 4 come una sfinestratura salvo il flag che saltare tutte le altre facce
   bool   bJointStraight              = FALSE ;
   bool   bIsNormalFeature            = TRUE ;
   bool   bIsNormalDisp               = TRUE ;
   bool   bWindowCut                  = FALSE ;
   bool   bCenterCut                  = FALSE ;
   bool   bSecondFaceCubetti          = FALSE ;            // flag per secondo taglio a cubetti nella stessa feature
   bool   bSecondFaceCut              = FALSE ;
   bool   bMultFace                   = FALSE ;            // controllo se sono presenti delle sottofacce
   bool   bGlobPause                  = FALSE ;            // flag per sapere se ho già scritto il comando di pausa. Ne devo scrivere uno per programma
   bool   bBigArea1                   = FALSE ;            // flag per taglio di lama che verifica se l'area della faccia 1 è più grande di quella della faccia 2
   bool   bBladeSide                  = FALSE ;            // flag per taglio di fianco
   bool   bSpecialCut                 = FALSE ;            // flag per taglio speciale
   bool   bSplit                      = FALSE ;
   bool   bMachOnTurnedCarr           = FALSE ;            // se lavorazione con carrelli ribaltati
   bool   bSpecialSuff180             = FALSE ;
   bool   bFoundSplitBlade            = FALSE ;            // se esiste una lama per tagliare da sopra in modo standard
   num    nConstRotAppo               = 0 ;                // variabile appoggio C_nRotationStyle in caso serva modificarla
   num    nUseMillToWin               = 0 ;                // 0 = con fresa, 1 = lama che taglia fino al fondo + mortasatrice, 2 = lama solo in parte + mortasatrice
   num    nTempPriFor                 = 0 ;                // priorità temporanea per fori (cambia se foro verticale od orizzontale)
   num    nNumberCentering            = 0 ;                // record del vettore contenente il nome del kit da utilizzare( solo per gestione con centrino)
   num    nMinimumDiamHole            = 0 ;                // contiene il minor diametro dei fori presenti nella trave( serve per gestione con centrino)
   num    nSolutionHole               = 0 ;
   num    nBeamType                   = 0 ;                // tipo di trave (corta, .....)
   num    nBeamTypeGeneral            = 0 ;                // tipo di trave (corta, .....) utilizzata dala funzione SetPartData
   num    nPosXFeat ;
   num    nPosYFeat ;
   num    nPri ;
   num    nPriAdd ;                                        // eventuale priorità da aggiungere per cliente
   num    nDiametro                   = 0 ;                // indica il diametro dell'utensile
   num    nAppo                       = 0 ;                // variabile numerica di appoggio generico
   num    nAppo2                      = 0 ;                // variabile numerica di appoggio generico
   num    nRise                       = 0 ;
   num    nLenFirstHole               = 0 ;
   num    nLenSecondHole              = 0 ;
   num    nLargMort                   = 0 ;
   num    nSpessMort                  = 0 ;
   num    nEaH                        = 0 ;                // estensione orizzontale faccia ausiliaria
   num    nEaV                        = 0 ;                // estensione verticale faccia ausiliaria
   num    nEaR                        = 0 ;                // elevazione faccia ausiliaria
   num    nToolDir                    = 0 ;
   num    nLen ;
   num    nWid ;
   num    nAng ;
   num    nProj ;
   num    nHl[4] ;                                         // numero dei fori per faccia
   num    nGf[4] ;                                         // numero gruppi per faccia
   num    nMaxLenHole                 = 0 ;                // lunghezza massima di foratura
   num    nMaxDepthFreAtt             = 0 ;                // variabile appoggio per massimo affondamento fresa attuale
   num    nMaxDepthBladeAtt           = 0 ;                // variabile appoggio per massimo affondamento lama attuale
   num    nDiamBladeAtt               = 0 ;                // diametro della lama attualmente usata
   num    nLenLongCont ;
   num    nMaxMatMortaise             = 0 ;                // massimo materiale mortasatrice
   num    nTypeHole                   = 0 ;
   num    nToolIndex                  = 0 ;                // indice dell'utensile scelto per la lavorazione
   num    nToolLen                    = 0 ;                // lunghezza utensile scelto per la lavorazione
   num    nToolDiam                   = 0 ;                // diametro utensile scelto per la lavorazione
   num    nToolNumber                 = 0 ;                // numero di utensili all'interno del kit
   num    nToolPos                    = 0 ;
   num    nToolType                   = 0 ;
   num    nKitToolPos                 = 0 ;                // posizione utensile
   num    nBladeIndex                 = 0 ;                // indice lama scelta per la lavorazione
   num    nBladeThick                 = 0 ;
   num    nBladeDiam                  = 0 ;
   num    nBladeMaxMat                = 0 ;
   num    nVotoFeature                = 0 ;                // voto feature. Più il voto è alto più la lavorazione è corretta.
   num    nVotoFeature2               = 0 ;                // voto feature quando trave ribaltata. Più il voto è alto più la lavorazione è corretta.
   num    nVotoFeatureTemp            = 0 ;                // voto feature appoggio. Usato se ho due o più lavorazioni in un'unica feature. Devo tenere il voto più basso
   num    nMachPossible               = 0 ;                // se si può applicare la lavorazione
   num    nManagementFlag             = 0 ;                // flag per capire quando lavorare la feature ( il prima possibile, alla fine, ecc...)
   num    nManageFlip                 = 0 ;
   num    nLengthFeat                 = 0 ;                // lunghezza totale feature
   num    nTHDiam ;                                        // diametro portautensile attuale
   num    nTHLen ;                                         // lunghezza portautensile attuale
   num    nPosXAppo                   = 0 ;
   num    nPosYAppo                   = 0 ;
   num    nTypeLeadMach               = 0 ;                // tipo di attacco della lavorazione ( solo per contornature)
   num    nHorizVices                 = _ViseNo ;          // flag per uso morse orizzontali
   num    nVertVices                  = _ViseNo ;          // flag per uso morse verticali
   num    nRefs                       = _RefNo ;           // flag per uso riferimenti
   num    g_nI ;                                           // indice contatore
   num    nJ ;                                             // indice contatore
   num    nMpOffsX                    = 0 ;                // offset in X di posizione curr pezzo per disposizione multipezzi
   num    nMpNextOffsX                = 0 ;                // offset in X di posizione prox pezzo per disposizione multipezzi
   num    nReferenceDistance          = 0 ;
   num    nDirCutCubetti              = 0 ;                // direzione creazione cubetti
   num    nMaxDiamUsedTool[4]         = 0 ;                // diametro utilizzato in lavorazioni in ogni fase. Serve per settare il kerf
   num    g_nFeatFaceDir              = 0 ;
   num    _nForceToolToUse            = 0 ;                // variabile appoggio per forzare scelta utensile
   num    nNumFeatureFace             = 0 ;                // numero facce della feature
   num    nGlobPos                    = 0 ;                // variabile appoggio per operazioni sulla posizione della feature
   num    nGlobPri                    = 0 ;                // variabile appoggio per operazioni sulla priorità della feature
   num    nSplit                      = 0 ;                // variabile utilizzata per la spezzatura delle feature lunghe
   num    nRest                       = 0 ;                // variabile utilizzata per la spezzatura delle feature lunghe
   num    nAppoSplitLen               = 0 ;                // variabile appoggio per lunghezza spezzatura feature
   num    nLongCutFaceExec            = 0 ;                // 0 nessuna faccia, 12 se entrambe le facce, 1/2 singola faccia eseguita
   num    nContFace                   = 0 ;                // per tagli longitudinali
   num    nTurnBeamPri                = 0 ;
   string sSplit                      = "" ;               // variabile utilizzata per la spezzatura delle feature lunghe
   string sSplitFace                  = "" ;               // faccia da separare per la spezzatura della feature lunghe
   string sFacesCutLong               = "" ;               // variabile utilizzata per la spezzatura delle feature lunghe
   string sToolKit                    = "" ;               // nome dell'utensile + tipo di lavorazione( contornatura, svuotature..ecc..)
   string sBladeKit                   = "" ;               // nome della lama + tipo di lavorazione( taglio normale, corner, ecc...)
   string sAppo                       = "" ;               // variabile stringa di appoggio generica
   string sAppo2                      = "" ;               // variabile stringa di appoggio generica
   string sAppoNameKit                = "" ;               // variabile appoggio per eventuali errori su nomi kit
   string sGlobFace                   = "" ;               // variabile appoggio per operazioni sulle facce alle quali applicare la lavorazione
   string sAppoNameTool               = "" ;               // variabile appoggio per operazioni sui nomi degli utensili
   string sKit ;
   string sKit2 ;
   string sNameHole                   = "" ;
   string sTipoAttacco                = "" ;
   string sFaceWorked                 = "QQQ" ;
   string sFace ;
   string sFace2 ;
   string sTypeSolution ;                                  // valore della soluzione opposta
   string sTypeSolutionSpe ;                               // valore della soluzione speciale
   string sCornerMill ;
   string sFeatureFaces ;
   string sMaterial                   = "" ;
   string sFacesMustToWork            = "" ;
   vec3   v3Appo ;
   vec3   v3Appo2 ;
   vec3   ptMin ;                                          // valore che contiene il punto minimo della faccia
   vec3   ptMax ;                                          // valore che contiene il punto massimo della faccia
   vec3   v3ToolDir ;                                      // contiene la direzione dell'utensile ( serve per verificare se soluzione normale oppure opposta)
   vec3   v3PriCube ;                                      // contiene la normale della faccia principale. Solo per tagli a cubetti.
   vec3   v3SecCube ;                                      // contiene la normale della faccia secondaria ( se esistente). Solo per tagli a cubetti.

   string sFaceTemp1 ;
   string sFaceTemp1List ;
   string sFaceTemp2 ;
   string sFaceTemp2List ;
   string sFaceTemp3 ;
   string sFaceTemp3List ;
   num    nPassate ;

END_VARIABLES


PROCEDURES    //----------------------------------------------------------------
   // procedure, function

END_PROCEDURES


EVENTS        //----------------------------------------------------------------

   ON_INIT :

      OUTDEB( 1, "BcfMgr/on_init : ^"{$BcfFile}^" {sVerBCF}") ;

     // esecuzione file di procedure e funzioni per automatismo
      sAppo = STRGSUB( STRUPR( $BcfFile), ".BCF", ".bca") ;
      run sAppo ;
      OUTDEB( 1, "               : ^"{sAppo}^" {sVerBCA}") ;

     // esecuzione file di procedure e funzioni per automatismo
      sAppo = STRGSUB( $BcfFile, ".bcf", ".bcv") ;
      run sAppo ;
      OUTDEB( 1, "               : ^"{sAppo}^"") ;

     // esecuzione file di personalizzazione
      run $BcpFile ;
      OUTDEB( 1, "   loaded ^"{$BcpFile}^"") ;

     // esecuzione file di linguaggio
      sAppo = STRGSUB( STRUPR( $BcfFile), ".BCF", ".bcl") ;
      run sAppo ;

     // determino se macchina con carrelli
      bMachineWithCarr = ( $McCarNbr > 0) ;

     // controllo vettore nomi kit con kit effettivi
      g_nI = 1 ;
      while ( g_nI <= 60  AND  C_vDiamFor[g_nI] != 0) {
         CheckDrill( C_vDiamFor[g_nI], C_vNomeForCorto[g_nI], TRUE) ;
         CheckDrill( C_vDiamFor[g_nI], C_vNomeForLungo[g_nI], FALSE) ;
        // se l'utensile è una fresa scrivo il vero diametro
         if ( C_vDiamFor[g_nI] > 0) then {
            GETKITDATA( C_vNomeForCorto[g_nI], _ToolName, 1, &sAppo) ;
            GETTOOLDATA( sAppo, _ToolType, &nToolType) ;
           // se è una fresa usata come foratura allora scrivo il diametro corretto
            if ( nToolType == _TtMilling) then
               GETKITDATA( C_vNomeForCorto[g_nI], _ToolDiam, 0, &C_vDiamFor[g_nI]) ;
         }

         g_nI = g_nI + 1 ;
      }

     // lettura larghezza mortasatrice
      bExistMort = ( GETKITDATA( C_sNameKitMortaise, _ToolDiam, 0, &nLargMort)  AND
                  GETKITDATA( C_sNameKitMortaise, _ToolThick, 0, &nSpessMort)  AND
                  GETKITDATA( C_sNameKitMortaise, _ToolMaxMat, 0, &nMaxMatMortaise)) ;

     // Disabilito in base alla configurazione
     // utilizzo mortasatrice
      if ( NOT( bMachConf32)) then
         bExistMort = FALSE ;
     // se posso lavorare dal sotto
      if ( NOT( bMachConf31)) then {
        // se testa di fianco è come se avesse il rinvio dato che posso lavorare sotto-squadra
         if ( C_bHeadFromSide) then
            C_bUseAngularTransmission = TRUE ;
         else
            C_bUseAngularTransmission = FALSE ;
      }
     // se non ho lama piccola non posso fare taglio a cubetti
      if ( NOT( bMachConf30)) then
         C_nExecuteCubetti = 1 ;
     // squadratura
      if ( NOT( bMachConf29)) then {
         C_nDeltaSquad = 0 ;
         C_nTopCut = 0 ;
         C_nBottomCut = 0 ;
      }
     // Blockhaus
      if ( NOT( bMachConf28)) then
         C_bUseToolBlockHaus = FALSE ;
     // testa a 4 uscite rotante
      if ( NOT( bMachConf27)) then
         C_nFirstPosSecSpeHead = 0 ;
     // bMachConf26 = Gestione Sheet ( se non è attiva la gestione forzo a lavorare SOLO travi)
      if ( NOT( bMachConf26)) then
         C_nTypeBeam = 3 ;
     // bMachConf25 = Gestione compensazione sezione trave teorico/reale
     // bMachConf24 = Gestione step MORT 
      
     // se macchina con carrelli non posso fare sfinestratura con lama
      if ( ( C_nStrategyWindow == 1 OR C_nStrategyWindow == 2)  AND  ( bMachineWithCarr  AND  NOT( C_bCanUseSubPiece))) then
         C_nStrategyWindow = 4 ;

      if ( bExistMort) then {
     // se Max_Mat non impostato lo calcolo con 150mm di sicurezza
         if ( nMaxMatMortaise == 0) then {
            GETKITDATA( C_sNameKitMortaise, _ToolLen, 0, &nMaxMatMortaise) ;
            nMaxMatMortaise = nMaxMatMortaise - 150 ;
         }
      }
     // forzo utilizzo lama per lavorazioni
      else
         C_nStrategyBladeWork = 2 ;

     // se carrelli che si ribaltano, prendo fase con voto più alto (indipendentemente dal numero di rotazioni)
      if ( C_bCarrTurn) then
         nTurnBeamPri = 0 ;

   ON_FINISH :
      OUTDEB( 1, "BcfMgr/on_finish") ;


END_EVENTS


AUTOMACH      //----------------------------------------------------------------

   ON_PART :

     // resetto variabili per funzioni speciali cliente
      CustomerSpecialManagement( _ON_PART_BEG) ;

     // mi salvo il tipo di rotazione richiesta
      nConstRotAppo = C_nRotationStyle ;

     // controllo tipologia pezzo
      if ( $BcfStatus == _BcfGeneral  OR  $BcfStatus == _BcfGenerLav) then {
        // C_nTypeBeam == 1  ->  sia sheet che beam
        // solo sheet
         if ( C_nTypeBeam == 2  AND  NOT( $IsSheet)) then
            OutputReport( _BcfErr, "{sErrType}") ;
        // solo travi
         elsif ( C_nTypeBeam == 3  AND  $IsSheet) then
            OutputReport( _BcfErr, "{sErrType}") ;
      }

     // se macchina con carrelli e gestione grezzo in macchina (Cms Suprema, Uniteam Ultra, ...)
      if ( bMachineWithCarr  AND  C_bRawMgmtInMachine) then {
        // se ho impostato minor numero di rotazioni ma il pezzo è molto alto o sbilanciato, allora devo forzare di partire con parte larga
         if ( nConstRotAppo == _LsAnySide) then {
            if ( MIN( $W, $T) < 60) then
               nConstRotAppo = _LsBigSide ;
            elsif ( MAX( $W, $T) > 600) then
               nConstRotAppo = _LsBigSide ;
            elsif ( $W/$T < 0.35  OR  $W/$T > 2.75) then
               nConstRotAppo = _LsBigSide ;
         }

         bFoundSplitBlade = FindBlade( "", FALSE, TRUE, MAX( $T, $W), MIN( $T, $W), 0, _bForceComplete) ;
        // il pezzo è dichiarato come normale
         bPieceEnlarged = FALSE ;

        // pezzo di sezione troppo grande
         if ( ( min( $W, $T) > C_nMinLimDim  OR  max( $W, $T) > C_nMaxLimDim)) then {
            nBeamType = BEAM_NO ;
            OutputReport( _BcfErr, "{sErrSagoma}") ;
         }
        // pezzo su ventose
         elsif ( max( $W, $T) > C_nMinLimDim) then {
            nBeamType = BEAM_ON_VAC ;
            SetPartData( ( $L + C_nHeadOverMat), 0, C_nHeadOverMat-C_nOffsetOverMat, _StdPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
            AddPartZone( 0, $L) ;
         }
        // GESTIONE PEZZI CORTI
        // pezzo corto di grossa sezione con morse
         elsif ( NOT( bFoundSplitBlade)  AND  $L < C_nLimitShortBigBeamNoAdd) then {
            nBeamType = BEAM_SMALL_BIG ;
            SetPartData( ($L + 1100 + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _SmallPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
            AddPartZone( 0, ($L + 1100)) ;
            bPieceEnlarged = TRUE ;
         }
        // pezzo corto con morse
         elsif ( $L < C_nLimitShortBeamNoAdd) then {
            nBeamType = BEAM_SMALL ;
            SetPartData( ( C_nLenRawDimShortPz + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _SmallPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
            AddPartZone( 0, C_nLenRawDimShortPz) ;
            bPieceEnlarged = TRUE ;
         }
        // pezzi normali con morse
         else {
            bFoundSplitBlade = FindBlade( "", FALSE, TRUE, $T, $W, 0, _bForceComplete) ;
            nBeamTypeGeneral = _StdPart ;

            if ( C_bTableWithClamps) then
               nBeamType = BEAM_SMALL ;
            else
               nBeamType = BEAM_STD ;
            if ( ( $L + C_nHeadOverMat) < ( C_nOutMax + ( $McCarNbr - 2) * C_nMaxCarrM + C_nOutMax)  AND  ( $L < C_nLenForce4Carr OR C_nLenForce4Carr == 0)) then {
               if ( $CurrStrategy == 0) then {
                 // se il pezzo non è per caduta, ma comunque non troppo lungo, se va in errore riprovo aggiungendo del grezzo
                  if ( $L < 2000) then
                     SetPartData( ($L + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, nBeamTypeGeneral, nConstRotAppo, FALSE, 0, nTurnBeamPri, 1) ;
                  else
                     SetPartData( ($L + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, nBeamTypeGeneral, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
               }
               elsif ( $CurrStrategy == 1) then {
                  nBeamType = BEAM_SMALL ;
                 // SetPartData( ( C_nLenRawDimShortPz + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _SmallPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
                 // AddPartZone( 0, C_nLenRawDimShortPz) ;
                  SetPartData( MAX( 1800, ( $L + 700 + C_nHeadOverMat)), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _SmallPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
                  AddPartZone( 0, $L) ;
                  bPieceEnlarged = TRUE ;
               }
            }
            else
               SetPartData( ($L + C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _CustomPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
            AddPartZone( 0, $L) ;
         }
        // controllo se lavorare i fori da sopra
         bHoleToTop = FALSE ;
         if ( C_bWorkHoleToTop  AND  nBeamType != BEAM_ON_VAC) then {
            GETHOLESCOUNT( C_nDistHoleAxis, &nGf[1], &nHl[1], &nGf[2], &nHl[2], &nGf[3], &nHl[3], &nGf[4], &nHl[4]) ;
           // devono esserci almeno 4 gruppi di fori
            if ( nGf[1] > 3 OR nGf[2] > 3 OR nGf[3] > 3 OR nGf[4] > 3) then {
               if ( $L / C_nIngToWork < nGf[1] OR $L / C_nIngToWork < nGf[2] OR $L / C_nIngToWork < nGf[3] OR $L / C_nIngToWork < nGf[4]) then {
                  if ( nHl[1] <= C_nMaxLenLongHole AND nHl[2] <= C_nMaxLenLongHole AND nHl[3] <= C_nMaxLenLongHole AND nHl[4] <= C_nMaxLenLongHole) then
                     bHoleToTop = TRUE ;
               }
            }
         }
      }
     // se macchina con carrelli senza gestione grezzo in macchina ( Hage Hagematic, ...)
      elsif ( bMachineWithCarr) {
        // pezzo di sezione troppo grande
         if ( MIN( $W, $T) > C_nMinLimDim  OR  MAX( $W, $T) > C_nMaxLimDim) then {
            nBeamType = BEAM_NO ;
            OutputReport( _BcfErr, "{sErrSagoma}") ;
         }
        // pezzi con o senza morse
         else {
            nBeamType = BEAM_STD ;
            SetPartData( ( $L + 2 * C_nHeadOverMat), OPT( $McLeftLoad, 0, 1), C_nHeadOverMat-C_nOffsetOverMat, _CustomPart, nConstRotAppo, FALSE, 0, nTurnBeamPri) ;
            AddPartZone( 0, $L) ;
         }
      }
     // se macchina per pareti ( extra)
      elsif ( C_bTableForWall) then {
         nBeamType = BEAM_STD ;
         SetPartData( $L, 0, 0, _CustomPart, nConstRotAppo) ;
         AddPartZone( 0, $L) ;
        // se richiesto aggiungo tagli longitudinali per squadratura pezzo
         if ( ( C_nTopCut != 0  OR  C_nBottomCut != 0)) then {
            if ( $W > $T) then
               SETPARTALONGCUTS( 0 ,C_nBottomCut, 0, C_nTopCut) ;
           // $T >= $W ( il caso più frequente dovrebbe essere  $T > $W)
            else
               SETPARTALONGCUTS( C_nBottomCut, 0, C_nTopCut, 0) ;
         }
      }
     // altrimenti macchina con tavola ( PMT, PM360, MultiL115)
      else {
         if ( min( $W, $T) > C_nMinLimDim  OR  max( $W, $T) > C_nMaxLimDim) then {
            nBeamType = BEAM_NO ;
            OutputReport( _BcfErr, "{sErrSagoma}") ;
         }
        // pezzi normali
         else {
            nBeamType = BEAM_STD ;
            SetPartData( $L, 0, 0, _CustomPart, nConstRotAppo, C_bOffsetBox, C_nBoxOffset) ;
            AddPartZone( 0, $L) ;
           // se richiesto aggiungo tagli longitudinali per squadratura pezzo
            if ( ( C_nTopCut != 0  OR  C_nBottomCut != 0)) then {
               if ( $W > $T) then
                  SETPARTALONGCUTS( 0, C_nBottomCut, 0, C_nTopCut) ;
              // $T >= $W ( il caso più frequente dovrebbe essere  $T > $W)
               else
                  SETPARTALONGCUTS( C_nBottomCut, 0, C_nTopCut, 0) ;
            }
         }
      }

     // recupero indice fresa per "centrini" ( invece dei prefori) per le punte lunghe
      GetIndexHoleCont() ;
     // impostazione parametri mortasatrice
      SETPARTMORTISE( OPT( bExistMort, nSpessMort, 0), 250) ;

     // aggiungo tagli di testa e di coda
      SETPARTCUTSONLR( C_nExecuteCutLeft, C_nExecuteCutRight) ;

     // impostazione fori antischeggia
      SETPARTABHOLES( C_nAntiBreakHoles) ;

     // impostazione per splittare BH
      SETPARTSPLITBLOCKHAUS(C_nSplitBH) ;
      
     // recupero il materiale
      sMaterial = GETPIECENOTE( "TY=") ;

     // le lavorazioni d squadratura devono essere sempre prima delle altre
      C_nDeltaSquad = ABS( C_nDeltaSquad) ;

     // calcolo dimensioni travi
      if ( C_nLenVeryShortBeam > C_nLenShortBeam) then
         C_nLenVeryShortBeam = C_nLenShortBeam ;
      bShortBeam = ( $L <= C_nLenShortBeam) AND bMachineWithCarr ;
      bVeryShortBeam = ( ( $L <= C_nLenVeryShortBeam) AND bMachineWithCarr) ;

     // se CarrTurn non devo considerare limiti travi piccole
      if ( bMachineWithCarr  AND  C_bCarrTurn) then {
         bShortBeam = FALSE ;
         bVeryShortBeam = FALSE ;
      }

      nReferenceDistance = MIN( C_nDistanceFromTail, $L / 2) ;

      // se presente utilizzo file per ordinare le lavorazioni con due teste
      if ( C_sNameFileOptMach != "") then
         SetEndSclFile("%MACHPATH%\Scl\" + C_sNameFileOptMach) ;

     // resetto variabili per funzioni speciali cliente
      CustomerSpecialManagement( _ON_PART_END) ;

   ON_ROTATE :
      OutputReport( _BcfErr, "ERROR OLD  ON_ROTATE") ;

   ON_FEATURE :
     // output debug
      OutDebugVar( 10) ;

      bError               = FALSE ;
      bToolFind            = FALSE ;
      bSuffSolOpp          = FALSE ;
      bSuffWorkPerp        = FALSE ;
      bPathGeoInverted     = FALSE ;
      bIsNormalFeature     = TRUE ;
      bRRUsed              = FALSE ;
      bHole                = FALSE ;
      bCanUseMort          = FALSE ;
      bKX5                 = TRUE ;
      bAppo                = FALSE ;
      bExecuteCubetti      = FALSE ;
      bMustExecuteCubetti  = FALSE ;
      bSplitRowPart        = FALSE ;
      bHoleInvert          = FALSE ;
      bBlade800            = TRUE ;
      bCutMore             = FALSE ;
      bCutLess             = FALSE ;
      bCutComplete         = FALSE ;
      bSecondFaceCubetti   = FALSE ;
      bSecondFaceCut       = FALSE ;
      bSplit               = FALSE ;
      bDoubleHoleDone      = FALSE ;
      bCubettiUsed         = FALSE ;
      nToolNumber          = 1 ;
      nToolDiam            = 0 ;
      nToolIndex           = 0 ;
      nBladeDiam           = 0 ;
      nBladeIndex          = 0 ;
      nVotoFeature         = 0 ;
      sToolKit             = "" ;
     // la posizione è il centro del box
      nPosXFeat            = 0.5 * ( $Pmin.x + $Pmax.x) ;
      nPosYFeat            = 0.5 * ( $Pmin.y + $Pmax.y) ;
      nLengthFeat          = $Pmax.x - $Pmin.x ;
      nMachPossible        = 2 ;
      nManagementFlag      = _Std ;
      nManageFlip          = _Std ;

      if ( NOT ISSETVAR($Np)) then {
         $Np = $N1 ;
      }

     // se è settata, vuol dire che sto applicando le lavorazioni. Vado quindi a vedere se sono in fase con carrelli ribaltati
      if ( ISSETVAR( $ROTNUM)  AND  C_bCarrTurn) then
         bMachOnTurnedCarr = $ROTCURR == 1 ;
      elsif ( NOT( ISSETVAR( $ROTNUM))) then
         bMachOnTurnedCarr = TRUE ;

      if ( bMachineWithCarr) then {
         C_nDistHeadFeat = MIN( C_nDistHeadFeat, $L / 2) ;
        // se al centro non bisogna mai considerarla lunga
         if ( ( $Pmax.y < $W  AND  $Pmin.y > 0  AND $Pmax.x < $L  AND  $Pmin.x > 0) AND $Np.z > 0) then
            bLongFeat = FALSE ;
        // se pezzi corti
         elsif ( ( bShortBeam  OR  bVeryShortBeam)) then {
            if ( ABS( $Np.x) > 0.98) then
               bLongFeat = nLengthFeat > C_nLenLongFeatSmallPiece ;
            elsif ( $Np.z > 0.98  OR  ( $CL == 142  AND  ABS( $Np.z) > 0.98)) then
               bLongFeat = nLengthFeat > C_nLenLongFeatSmallPiece ;
            else
               bLongFeat = TRUE ;
         }
        // se è una feature di testa
         elsif ( $Pmin.x < 5  OR  $Pmax.x > $L - 5) then {
            if ( $CL > 130  AND  $CL < 199) then
               bLongFeat = nLengthFeat > C_nLenLongFeat ;
            else
               bLongFeat = nLengthFeat > C_nLenLongFeat  OR  nLengthFeat > $L / 4 ;
         }
        // se feature in mezzo alla trave
         else
            bLongFeat = nLengthFeat > C_nLenLongFeat  OR  nLengthFeat > $L / 2 ;
      }
      else {
         if ( C_bTableForWall) then
            bLongFeat = TRUE ;
         else
            bLongFeat = FALSE ;
      }

     // PRIMA DI TUTTO : eventuali funzioni speciali per cliente
      bIsNormalFeature = CustomerSpecialManagement( _ON_FEAT) ;

      if ( bIsNormalFeature) then {
      // ------------    FEATURES  "IBRIDE"    ------------
         // viene considerata "ibrida" una feature che, per tipologia, appartiene ad una classe, ma che, per forma,
         // può essere fatta risalire ad un'altra. Quindi si cambia il numero della classe e si impostano i parametri che servono.
         if ( $CL == 118) then {
           // trasformo classe 118 in classe 142
            $EL = $ER ;
            $EW = $EV ;
            $ER = $EH ;
            $CL = 142 ;
         }
        // da RIBASSO -> a INCASTRO
         elsif ( $CL == 122) then {
            $CL = 221 ;
           // devo impostare la variabile $AS perchè nei ribassi non viene mai definita
            GETFACEFACEANGLW( "F01", "F02", &nAng) ;
            $AS = nAng ;
         }
        // da INCASTRO -> a RIBASSO
         elsif ( $CL == 251) then {
            $CL = 151 ;
         }
       // da TAGLIO -> a TAGLIO LONGITUDINALE
         elsif ( $CL == 411) then {
            if ( nLengthFeat > ( ( $L / 5) * 4) AND NOT( bShortBeam)) then
               $CL = 321 ;
            elsif ( ABS( $Np.x) < 0.087  AND  bLongFeat) then
               $CL = 321 ;
         }
       // da TAGLIO -> a RIBASSO
         elsif ( $CL == 421) then {
           // se taglio concavo e almeno una faccia è rivolta verso il basso, provo a considerarlo come un ribasso 
         //   if ( ( $N1.z < 0 OR $N2.z < 0)) then {
          //     $CL = 121 ;
         //   }
         }
       // da SMUSSO -> a TAGLIO LONGITUDINALE
         elsif ( $Caf == 3036  AND  C_sNameContSmusso == "") then {
           // per lo smusso tutti i dati sono calcolati sulla faccia 2, devo settare quelli della faccia 1
            $CL = 321 ;
            if ( NOT( ISSETVAR( $AS))) then
               $AS = 0 ;
            if ( NOT( ISSETVAR( $N1))) then {
               $N1 = $Np ;
               if ( NOT( ISSETVAR( $N2))) then {
                  $E1H = $EH ;
                  $E1V = $EV ;
               }
               else {
                  $E1H = $E2H ;
                  $E1V = $E2V ;
                  $E1R = $E2R ;
               }
               RESETVAR( "$N2") ;
            }
         }
       // ------------   CAMBIO DI CATEGORIA / STESSA CLASSE    ------------
        // faccio diventare un ribasso standard di tipo BlockHaus
         if ( $CL == 132  AND  C_bUseToolBlockHaus) then {
            v3Appo = CROSS( $N1, $N2) ;
            if ( v3Appo.x == 0) then
               $Caf = 3033 ;
         }
        // ---------- CLASSE RIBASSO ( 1 ) ------------------------------
        // fessura (3016), fessura frontale (3017), ribasso (3030), ribasso con foro (3031),
        // scanalatura (3032), mortasa (3050), mortasa frontale (3051), taglio cornicione (3034),
        // tasca (3039), ribasso blockhaus (3033), ribasso completo blockhaus (3037)
         if ( $CL >= 100  AND  $CL <= 199) then {
           // gestione speciale e semplificata per ribassi Blockhaus
            if ( ( $Caf == 3033  OR  $Caf == 3037) AND  C_bUseToolBlockHaus
                  AND ( $Np.z >= 0  OR  VerExecNegativeBH() OR  C_bHeadFromSide)) then {
               bExistBHTool = FindTool( nOpenFeat, nNormal, 1, "F01", "F02", _TypeTMach_BH) ;
              // in questo caso controllo sicurezza X 2 volte per stare più lontano
               if ( bExistBHTool  AND  $ER < (( nToolDiam - C_nDiamMotore) / 2) - ( C_nSicurezza * 2)) then {
                  if ( NOT( C_bHeadFromSide)  OR  ( C_bHeadFromSide  AND  $T < 190)) then {
                     bLongFeat = FALSE ;
                     bCanUseMort = FALSE ;
                     ExecuteRecessWithOtherTool( TRUE, "") ;
                     if ( $Np.z >= 0.707) then
                        nVotoFeature = 5 ;
                     else
                        nVotoFeature = 2 ;
                     bAppo = TRUE ;
                  }
                  else
                     bAppo = FALSE ;
               }
               else
                  bAppo = FALSE ;
            }
           // altri casi standard ( se non BH)
            if ( NOT( bAppo)) then {
              // se la feature ha angoli acuti ( oltre tolleranza) blocco il calcolo
               CheckTiltedFace( "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", FALSE) ;
               if ( bImpossibleToWork) then
                  OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
               else {
                // ===  gestione casi "speciali"  ===
                  if ( $CL == 149  OR  $CL == 161) then
                     OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                  elsif ( $CL == 111) then {
                     if ( ABS( $Np.z) < 1) then {
                        sFaceWorked = "F01" ;
                        FindKitBlade( nNormal, $E1V, $E1H, sFaceWorked, $N1, sFaceWorked, 0, TRUE) ;
                       // dico che ho trovato l'utensile
                        bToolFind = TRUE ;
                     }
                     elsif ( $Np.z == 1) {
                        ExecPockOnFace( "F01", nOpenFeat) ;
                        nVotoFeature = 5 ;
                        SetVotoFeatureRibasso( $N1) ;
                     }
                  }
                  elsif ( $CL == 129) then {
                     sFaceWorked = "F01" ;
                     GETFACEHVREXT( sFaceWorked, &nEaH, &nEaV, &nEaR) ;
                     GETFACENORMAL( sFaceWorked, &v3Appo) ;
                     FindKitBlade( nNormal, nEaV, nEaH, sFaceWorked, v3Appo, sFaceWorked, 0, TRUE) ;

                     if ( $ER > nBladeThick) then {
                        sFaceWorked = "F02" ;
                        GETFACEHVREXT( sFaceWorked, &nEaH, &nEaV, &nEaR) ;
                        GETFACENORMAL( sFaceWorked, &v3Appo) ;
                        FindKitBlade( nNormal, nEaV, nEaH, sFaceWorked, v3Appo, sFaceWorked, 0, TRUE) ;
                        sFaceWorked = "F01,F02" ;
                     }
                  }
                // ===  gestione casi "standard"  ===
                  elsif ( $CL == 121) then {
                    // controllo se devo spezzare l alavorazione
                    // 93 + 7 = lunghezza pressore verticale + 5 mm sicurezza
                    // 100 = Altezza pressore orizzontale
                     if ( ( ( nLengthFeat > 2000  OR  nLengthFeat > $L/1.25) AND  $L > 1500) OR ( bPieceEnlarged AND nLengthFeat > 400)) then {
                       // se pezzo con grezzo aggiuntivo oppure sono con carrelli ribaltati spezzo sempre
                       // se le facce sono per lo più orizzontali, allora non uso questa spezzatura ma faccio taglio a cubetti
                        v3Appo = CROSS( $N1, $N2) ;
                        if ( ABS( v3Appo.z) > 0.5) then
                           bSplit = FALSE ;
                        elsif ( bPieceEnlarged  OR  bMachOnTurnedCarr) then
                           bSplit = TRUE ;
                       // se sono sotto le morse verticali
                        elsif ( $Pmin.z < 130) then {
                          // se sono sulla parte sotto
                           if ( $Pmin.z < 5) then
                              bSplit = TRUE ;
                          // se sono sulla parte sopra
                           elsif ( $Pmin.y < 5  AND  $Pmin.z > 120) then
                              bSplit = FALSE ;
                           elsif ( $Pmax.y > ( $W-101)) then
                              bSplit = TRUE ;
                        }
                     }
                     if ( bSplit  AND  ( $N1.z >= 0  OR  $N2.z >= 0)) then {
                        nRest = nLengthFeat ;
                        nSplit = 0 ;
                        sSplit = "" ;

                       // se pezzo piccolo
                        if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                          // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                           nRest = MAX( 0, nLengthFeat - 150) ;
                           if ( $McLeftLoad) then {
                             // lascio sempre 150mm verso il grezzo aggiuntivo
                              nSplit = 150 ;
                              sSplit = OUTSTR( "{nSplit},") ;
                              if ( nRest > 700) then {
                                 nSplit = nLengthFeat - 700 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ;
                                 nSplit = nLengthFeat - 350 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              }
                              elsif ( nRest <= 700 AND  nRest > 350) then {
                                 nSplit = nLengthFeat - 350 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              }
                           }
                           else {
                              nSplit = 400 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              if ( nRest > 600) then {
                                 nSplit = nRest/2 + 400 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ; 
                              }
                           }
                        }
                       // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                        elsif ( nRest <= 1400) then {
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // in tutti gli altri casi
                        else {
                           nSplit = 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           
                           nRest = nLengthFeat - nSplit - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;
                          // devo comunque spezzare la parte centrale almeno una volta
                           if ( nAppo == 0) then {
                              nAppoSplitLen = nRest / 2 ;
                              nAppo = 1 ;
                           }
                           else
                              nAppoSplitLen = nRest / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                        
                        nAppo = AddTrimmedFacesByDistance( "F01", sSplit, &sFacesCutLong) ;

                        bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                       // applico lavorazioni (sempre truciolatore perchè non posso avere sfridi che rimangono li)
                        if ( bToolFind) then {
                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              sFace = GetFirstFaceInList( &sFacesCutLong) ;
                              sKit = C_sPrefCont + sToolKit ;
                              nJ = 1 ;
                              GETTOOLDIR( "F01", "F02", &nToolDir, &v3ToolDir) ;
                             // in base a come lavorero', decido se fare dopia passata
                              if ( v3ToolDir.z < 0 OR ( v3ToolDir.z == 0 AND $N1.z >= 0)) then
                                // tolgo 0.1 perchè se lo step fosse come la larghezza, il CEIL calcola 2 passaggi
                                 nAppo2 = CEIL( ($EW / C_nSecurityStep) - 0.1) ;
                              else
                                 nAppo2 = 1 ;
                              
                              while ( nJ <= nAppo2) {
                                 SETKITOVERMAT( C_nSecurityStep * (nAppo2-nJ)) ;
                                 SETKITDIR( nToolDir) ;
                                 SETKITLEADINTYPE( _LioNone) ;
                                 SETKITLEADOUTTYPE( _LioNone) ;
                                 GETFACEBOX( sFace, &ptMin, &ptMax) ;
                                 nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                                // se il pezzo è stato allungato, allora in coda abbasso priorità
                                 if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                                    bIsTail = TRUE ;
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                    bIsTail = FALSE ;
                                 }
                                 else
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;

                                 if ( v3ToolDir.z < 0 OR ( v3ToolDir.z == 0 AND $N1.z >= 0)) then {
                                    GETTOOLDIR( "F02", "F01", &nToolDir, &v3ToolDir) ;
                                    CalculateHeadSolution( v3ToolDir) ;
                                    SETKITLEADINLENC( $EW+10) ;
                                    SETKITLEADOUTLENC( $EW+10) ;
                                    bSuffWorkPerp = TRUE ;
                                   // ricalcolo direzione utensile standard
                                    GETTOOLDIR( "F01", "F02", &nToolDir, &v3ToolDir) ;
                                 }
                                 else {
                                    CalculateHeadSolution( v3ToolDir) ;
                                    SETKITLEADINLENC( $ER+10) ;
                                    SETKITLEADOUTLENC( $ER+10) ;
                                 }
                                 InsertKit( sKit, sFace, nPosXAppo, nPri) ;
                                 nJ = nJ + 1 ;
                              }
                              g_nI = g_nI + 1 ;
                           }
                          // controllo se posso effettivamente lavorare in questa posizione
                           if ( $Pmax.z == $T) then
                              nVotoFeature = 5 ;
                           else
                              nVotoFeature = 2 ;
                           if ( $Pmax.y == $W) then {
                              if ( $Pmax.z == $T AND ( $Pmin.z < 30)) then
                                 nVotoFeature = 0 ;
                              elsif ( $Pmin.z == 0 AND ( ( $T - $Pmax.z) < 20  OR  $Pmax.z > 81)) then
                                 nVotoFeature = 0 ;
                              elsif ( $Pmin.z == 0 AND $Pmin.y < ($W-65)) then
                                 nVotoFeature = 0 ;
                           }
                          // se è su faccia anteriore
                           elsif ( $Pmin.y == 0) then {
                              if ( $Pmin.z == 0) then {
                                 if ( $L <= C_nLenVeryShortBeam  AND  ( $T-$Pmax.z) < 100) then {
                                    nManageFlip = 1 ;
                                    nVotoFeature = 0 ;
                                 }
                                 elsif ( $Pmax.y > $W/2) then
                                    nVotoFeature = 0 ;
                              }
                           }
                        }
                     }
                    // gestione standard
                     elsif ( $N1.z >= -0.05  OR  C_bHeadFromSide) then {
                       // devo sempre usare la fresa piccola se corro il rischio di collidere con le morse
                        if ( $N1.z > 0.995  AND  $Pmin.z < ( C_nAltezzaMorseO + C_nSicurezza)  AND  bShortBeam  AND  $EW > C_nDistHeadFeat) then {
                           bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( bToolFind) then {
                              if ( $ER > nToolLen) then {
                                 SETKITDEPTH( nToolLen - $ER) ;
                                 bError = TRUE ;
                              }
                              if ( $EW < nToolDiam) then {
                                 CalculateToolDir( "F02", "F01") ;
                                 sKit = C_sPrefCont + sToolKit ;
                                 InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                              }
                              else {
                                 ExecPockOnFace( "F01", nOpenFeat) ;
                              }
                           }
                           nVotoFeature = 5 ;
                        }
                        else {
                           bToolFind = FindTool( nOpenFeat, nProfil, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                          // lavoro il ribasso come contornatura
                           if ( ( $EL <= nToolLen  AND  $EW > ( nToolDiam * 2)) AND C_bWorkRecessAsProfil
                              AND $N1.z == 0 AND $N2.z == 0   AND  bLongFeat  AND bToolFind) then {
                              sKit = C_sPrefCont + sToolKit ;
                              SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                              SETKITDIR( _Nord) ;
                              VerifyAndSetStep( sKit, 0, FALSE) ;
                              SETKITDEPTH( 2) ;
                              InsertKit( sKit, "F01,F02", nPosXFeat, nPri) ;
                             // se riesco faccio una passata di pulitura sull'angolo
                              if ( C_bTableForWall) then {
                                // non posso lavorare di fianco... dovrei aggiungere uno foro sullo spigolo ( per il momento non si fa niente)
                              }
                              else {
                                 if ( $ER < nToolLen) then {
                                    CalculateToolDir( "F02", "F01") ;
                                    InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                                 }
                              }
                              nVotoFeature = OPT( bShortBeam, 0, 3) ;
                           }
                           else {
                             // lavoro con lama se macchina senza carrelli o macchina con carrelli ma non è un pezzo piccolo
                             // permetto lavorazione pezzo piccolo se feature vicino a testa o coda
                             // lavorazione di taglio con lama
                              FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
                              if ( $ER <= nBladeMaxMat  AND  $EW <= nBladeMaxMat  AND  NOT( bShortBeam) AND  NOT( C_bTableForWall)  AND
                                 ( nPosXFeat < C_nDistHeadFeat  OR  nPosXFeat > ($L - C_nDistHeadFeat))  AND  C_bMakeRecessWithBlade  AND  ( ( $N1.z >= 0  AND  $N2.z >= 0) OR C_bHeadFromSide)) then {
                                 v3Appo = CROSS( $N1, $N2) ;
                                 if ( ( ( $N1.z >= 0  AND  $N2.z >= 0) OR C_bHeadFromSide)  AND  ABS( v3Appo.z) < 0.707) then {
                                    sAppo = "F01" ;
                                    sAppo2 = "F02" ;
                                    nRise = $EW ;
                                    nWid = $ER ;
                                    SetPriorityBlade( $Np, "F01") ;
                                   // lavoro faccia verticale
                                    SETKITLEADINPERP( 0) ;
                                    SETKITLEADOUTPERP( 0) ;
                                    SETKITLEADINTANG( 1) ;
                                    SETKITLEADOUTTANG( 1) ;
                                    SETKITLEADINLENC( nWid + 30) ;
                                    SETKITLEADOUTLENC( nWid + 30) ;
                                    bSuffWorkPerp = TRUE ;
                                    CalculateToolDir( sAppo2, sAppo) ;
                                    SETKITPERPENDICULAR( TRUE) ;
                                    InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo2, nPosXFeat, nPri) ;
                                   // lavoro faccia orizzontale
                                    SETKITLEADINPERP( 0) ;
                                    SETKITLEADOUTPERP( 0) ;
                                    GETKITDATA( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], _ToolDiam, 0, &nAppo) ;
                                    if ( $N1.z < 0  OR  $N2.z < 0) then {
                                       SETKITLEADINTANG( ( nAppo / 2) + 20) ;
                                       SETKITLEADOUTTANG( ( nAppo / 2) + 20) ;
                                       SETKITLEADINLENC( 2) ;
                                       SETKITLEADOUTLENC( 2) ;
                                    }
                                    else {
                                       SETKITLEADINTANG( 1) ;
                                       SETKITLEADOUTTANG( 1) ;
                                       SETKITLEADINLENC( nRise + 30) ;
                                       SETKITLEADOUTLENC( nRise + 30) ;
                                    }
                                    bSuffWorkPerp = TRUE ;
                                    CalculateToolDir( sAppo, sAppo2) ;
                                    SETKITPERPENDICULAR( TRUE) ;
                                    InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
                                    nVotoFeature = 5 ;
                                 }
                                 elsif ( $N1.z >= 0 AND $N2.z >= 0) then {
                                    $CL = 421 ;
                                    SetPriorityBlade( $Np, "F01") ;
                                    GETFACENORMAL( "F01", &v3Appo) ;
                                    GETFACEHVREXT( "F01", &nEaH, &nEaV, &nRise) ;
                                    bCutNoDepth = TRUE ;
                                    FindKitBlade( nInvert, nEaV, nEaH, "F01", v3Appo, "F02", 0, TRUE) ;
                                    GETFACENORMAL( "F02", &v3Appo) ;
                                    GETFACEHVREXT( "F02", &nEaH, &nEaV, &nRise) ;
                                    bCutNoDepth = TRUE ;
                                    FindKitBlade( nInvert, nEaV, nEaH, "F02", v3Appo, "F01", 0, TRUE) ;
                                    nVotoFeature = 3 ;
                                 }
                              }
                              else {
                                 bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                 VerifyExecutionCubetti( FALSE, "F01", $N1, TRUE) ;
                                 if ( bExecuteCubetti  AND  ( $N1.z >= 0 AND $N2.z >= -0.259) AND $EL != $L) then {
                                   // tagli a cubetti
                                    ExecuteCubetti( "F01", "F02") ;
                                    if ( NOT( bError)) then {
                                       GETFACEFACEANGLW( "F01", "F02", &nAppo) ;
                                      // se angolo > 90 faccio cubetti anche su altra faccia
                                       if ( nAppo > 90) then
                                          ExecuteCubetti( "F02", "F01") ;
                                       if ( NOT( bError)) then {
                                        //  se settato su "sempre" alzo la priorità perchè voglio farlo con lama
                                         if ( C_nExecuteCubetti == 5) then
                                             nVotoFeature = 5 ;
                                          else
                                             nVotoFeature = 3 ;
                                       }
                                       else
                                          bExecuteCubetti = FALSE ;
                                    }
                                    else
                                       bExecuteCubetti = FALSE ;
                                 }
                                 else
                                    bExecuteCubetti = FALSE ;

                                 if ( NOT( bExecuteCubetti)) then {
                                   // se non ho trovato l'utensile provo a ricalcolare
                                    if ( NOT( bToolFind)) then
                                       bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                    if ( bToolFind) then {
                                       nVotoFeature = 5 ;
                                       SetVotoFeatureRibasso( $N1) ;
                                       if ( C_nExecuteRecessFinish != 1  OR  $EW <= ( nToolDiam - 1)) then
                                          AddContMainFace() ;
                                       else {
                                          bExecuteRecess = FALSE ;
                                          sAppo = "F01" ;
                                       }
                                      // se non sono riuscito a lavorare con una passata e il ribasso non è stato eseguito
                                       if ( ( $EW > ( nToolDiam - 1) OR $ER > nToolLen) AND NOT( bExecuteRecess)) then {
                                          nRise = $ER ;
                                          if ( nRise > nToolLen) then {
                                             SETKITDEPTH( nToolLen - nRise) ;
                                             bError = TRUE ;
                                          }
                                          else
                                             bError = FALSE ;

                                          sKit = C_sPrefSvuot + sToolKit ;
                                          GETFACENORMAL( sAppo, &v3ToolDir) ;
                                          CalculateHeadSolution( v3ToolDir) ;
                                          InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                                       }
                                       if ( bError) then {
                                          OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                          bError = FALSE ;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                     else {
                        if ( NOT( C_bTableForWall)) then {
                           bToolFind = FindTool( nOpenFeat, nInvert, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( bToolFind) then {
                              nVotoFeature = 1 ;
                              SetVotoFeatureRibasso( $N2) ;
                              AddContMainFace() ;

                              if ( ( nRise > ( nToolDiam - 1) OR nWid > nToolLen) AND NOT( bExecuteRecess) AND $N2.z >= -0.05) then {
                                 if ( nWid > nToolLen) then {
                                    SETKITDEPTH( nToolLen - nWid) ;
                                    bError = TRUE ;
                                 }
                                 else
                                    bError = FALSE ;

                                 sKit = C_sPrefSvuot + sToolKit ;
                                 CalculateHeadSolution( $N2) ;
                                 InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                              }
                              if ( bError) then
                                 OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                           }
                        }
                        else
                           OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute}") ;
                     }
                  }
                  elsif ( $CL == 131  OR  $CL == 141) then {
                     if ( ( ( nLengthFeat > 2000  OR  nLengthFeat > $L/1.25) AND  $L > 1500) OR
                        ( bPieceEnlarged AND nLengthFeat > 400)  OR
                        ( nLengthFeat > 400 AND ( $Pmin.x < 200 OR $Pmax.x > $L-200))) then {
                       // verifico se spezzare
                        if ( ( bPieceEnlarged  OR  bMachOnTurnedCarr) AND nLengthFeat > 400) then
                           bSplit = TRUE ;
                        elsif (  ( nLengthFeat > 1500  OR  
                                   nLengthFeat > $L/1.25 OR 
                                   ( nLengthFeat > 800 AND ( $Pmin.x < 500 OR $Pmax.x > $L-500)))  AND  
                                 ( $Pmin.y == 0  OR  $Pmax.y == $W)) then {
                           bSplit = TRUE ;
                        }
                       // se sono sotto le morse verticali
                        elsif ( $Pmin.z < 130) then {
                           // se sono sulla parte sotto
                           if ( $Pmin.z < 5) then
                              bSplit = TRUE ;
                          // se sono sulla parte sopra
                           elsif ( $Pmax.y < 5  AND  $Pmin.z > 120) then
                              bSplit = FALSE ;
                           elsif ( $Pmax.y >= ( $W-120)) then
                              bSplit = TRUE ;
                        }
                        elsif ( $Pmin.z >= 130) then {
                           bSplit = FALSE ;
                        }
                     }
                    
                     if ( bSplit) then {
                        nRest = nLengthFeat ;
                        nSplit = 0 ;
                        sSplit = "" ;

                       // se pezzo piccolo
                        if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                          // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                           nRest = MAX( 0, nLengthFeat - 400) ;
                           if ( $McLeftLoad) then {
                              if ( nRest > 600) then
                                 nSplit = nRest/2 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              sSplit = sSplit + OUTSTR( "{nRest},") ;
                           }
                           else {
                              nSplit = 400 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              if ( nRest > 600) then {
                                 nSplit = nRest/2 + 400 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ; 
                              }
                           }
                        }
                       // se sono in centro alla trave
                        elsif ( $Pmin.x > 500  AND  $Pmax.x < $L-500 AND nLengthFeat > 1500) then {
                           nAppo = FLOOR( nLengthFeat / 1500) ;
                           nAppoSplitLen = nLengthFeat / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }
                        }
                       // se sono all'inizio della trave
                        elsif ( $Pmin.x < 500  AND  $Pmax.x < $L-500  AND nLengthFeat > 400) then {
                           nSplit = 350 - $Pmin.x ;
                           if ( nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 - $Pmin.x ;
                           if ( nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;

                           nRest = nLengthFeat - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;
                           nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo  AND  nAppoSplitLen > 0) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }
                        }
                       // se sono alla fine della trave
                        elsif ( $Pmin.x > 500  AND  $Pmax.x > $L-500  AND nLengthFeat > 350) then {
                           nRest = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                           nAppo = FLOOR( nRest / 1500) ;
                           nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo  AND  nAppoSplitLen > 0) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                           if ( nSplit > 0  AND  nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - ( 350 - ( $L - $Pmax.x)) ;
                           if (  nSplit > 0  AND  nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                        elsif ( nRest <= 1400) then {
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // in tutti gli altri casi
                        else {
                           nSplit = 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;

                           nRest = nLengthFeat - nSplit - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;

                          // devo comunque spezzare la parte centrale almeno una volta
                           if ( nAppo == 0) then {
                              nAppoSplitLen = nRest / 2 ;
                              nAppo = 1 ;
                           }
                           else
                              nAppoSplitLen = nRest / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // trimmo la faccia nelle parti calcolate
                        nAppo = AddTrimmedFacesByDistance( "F01", sSplit, &sFacesCutLong) ;
                       // gestione speciale per fessura molto stretta
                        if ( $EW < 20  AND  $N1.z >= 0) then {
                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              sFace = GetFirstFaceInList( &sFacesCutLong) ;
                              ExecuteRecessWithOtherTool( TRUE, sFace) ;
                              g_nI = g_nI + 1 ;
                           }
                           if ( $T - $Pmin.z > 120  AND  $N1.z == 0  AND  $N1.y < 0) then
                              nVotoFeature = 0 ;
                           else
                              nVotoFeature = 2 ;
                        }
                       // lavorazione di fianco
                        elsif ( $N1.z >= 0) then {
                           bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02", _TypeTMach_Rib, _nForceToolToUse) ;
                           nVotoFeature = 3 ;
                           if ( bToolfind) then {
                              g_nI = 1 ;
                              while ( g_nI <= nAppo) {
                                 sFace = GetFirstFaceInList( &sFacesCutLong) ;
                                 GETFACEBOX( sFace, &ptMin, &ptMax) ;
                                 nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                                // se il pezzo è stato allungato, allora in coda abbasso priorità
                                 if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                                    bIsTail = TRUE ;
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                    bIsTail = FALSE ;
                                 }
                                 else
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                 // se non riesco a lavorarlo completo
                                 if ( $ER > nToolLen) then {
                                    SETKITDEPTH( nToolLen - $ER) ;
                                    VerifyAndSetStep( C_sPrefSvuot + sToolKit, 0, FALSE) ;
                                 }
                                 if ( $CL == 141  AND  $Pmin.x == 0) then {
                                    SETKITINVERT() ;
                                    nPosXAppo = $L - nPosXAppo ;
                                 }
                                 CalculateHeadSolution( $N1) ;
                                 InsertKit(  C_sPrefSvuot + sToolKit, sFace, nPosXAppo, nPri) ;
                                 g_nI = g_nI + 1 ;
                              }
                           }
                        }
                        else
                           bToolFind = FALSE ;
                     }
                    // caso standard
                     else {
                        bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                        if ( bToolFind) then {
                           if ( $N1.z > 0  OR  C_bHeadFromSide  OR  ( $N1.z == 0 AND  NOT( C_bTableForWall))) then {
                              if ( NotUseMillOnRecess()  AND  $CL == 141) then {
                                 ExecuteRecessWithOtherTool( TRUE, "") ;
                              }
                              else {
                                // cerco di lavorare dall'alto
                                 bExecuteRecess = FALSE ;
                                 nVotoFeature = 5 ;
                                 SetVotoFeatureRibasso( $N1) ;
                                 if ( NOT( CheckTiltedFace( "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", FALSE)) AND ( C_nExecuteRecessFinish != 1)) then {
                                    if ( $CL == 131  AND  $N1.z == 0  AND  $N2.z == 1  AND  $EW < nToolLen) then {
                                       sFaceWorked = "F01,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
                                       CalculateToolDir( sFaceWorked, "F02") ;
                                    }
                                    else {
                                       sFaceWorked = "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
                                       CalculateToolDir( sFaceWorked, "F01") ;
                                    }
                                    if ( $CL == 131 OR ( $EW > ( nToolDiam + 3) AND $CL == 141)) then {
                                      // eseguo contornatura
                                       if ( ( $AV > 80 AND $AV < 100) /*OR ( $AV > 260 AND $AV < 290)*/) then {
                                          sKit = C_sPrefCont + sToolKit ;
                                          SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                                       }
                                       else {
                                          sKit = C_sPrefCont + sToolKit ;
                                          SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                                       }
                                       VerifyAndSetStep( sKit, 40, FALSE) ;
                                       if ( $ER > nToolLen) then {
                                          OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                          SETKITDEPTH( nToolLen - $ER) ;
                                       }
                                      // se fessura frontale( 3017) o mortasa frontale (3051)
                                       if ( $Caf == 3017 OR $Caf == 3051) then
                                          SETKITRISE( $ER) ;
                                       InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                       bExecuteRecess = TRUE ;
                                    }
                                 }
                                // svuotatura se non completo o non voglio lavorazione di finitura
                                 if ( NOT( bExecuteRecess)) then {
                                   // if ( ( $EW > ( nToolDiam / 2) AND $CL == 131) OR ( $EW >= nToolDiam  AND $CL == 141) ) then {
                                    if ( bToolFind) then {
                                       sKit = C_sPrefSvuot + sToolKit ;
                                      // cerco di lavorare la faccia 2
                                       if ( $N1.z == 0  AND  $N2.z == 1  AND  $EV < nToolLen AND $EW > ( nToolDiam * 2)) then {
                                          sAppo = "F02" ;
                                       }
                                       else {
                                          sAppo = "F01" ;
                                          if ( $ER > nToolLen) then {
                                             SETKITDEPTH( nToolLen - $ER) ;
                                             OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                          }
                                       }
                                      // se fessura frontale( 3017) o mortasa frontale (3051)
                                       if ( $Caf == 3017 OR $Caf == 3051) then
                                          SETKITRISE( $ER) ;
                                       CalculateHeadSolution( $N1) ;
                                       
                                       InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                                    }
                                    else
                                       OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                                 }
                                 else {
                                    GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid) ;
                                    if ( ( ( nWid > nToolDiam AND $CL == 131) OR ( ( nWid > nToolDiam AND nLen > ( nToolDiam * 2)) AND $CL == 141)) ) then {
                                       sKit = C_sPrefSvuot + sToolKit ;
                                       if ( $ER > nToolLen) then {
                                          SETKITDEPTH( nToolLen - $ER) ;
                                       }
                                      // se fessura frontale( 3017) o mortasa frontale (3051)
                                       if ( $Caf == 3017 OR $Caf == 3051) then
                                          SETKITRISE( $ER) ;
                                       CalculateHeadSolution( $N1) ;
                                       InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                                    }
                                 }
                              }
                             // setto voto se tavola per pareti
                              if ( C_bTableForWall) then {
                                 if ( $N1.z < 0.707) then
                                    nVotoFeature = 0 ;
                              }
                           }
                           else {
                              if ( $N2.z >= 0 AND $ER > nToolDiam) then {
                                 nVotoFeature = 3 ;
                                 SetVotoFeatureRibasso( $N1) ;
                                 v3Appo = $N2 ;
                                 sFaceWorked = "F02" ;
                                 nRise = $E2R ;
                                 if ( $E2R > nToolLen) then {
                                    SETKITDEPTH( nToolLen - $E2R) ;
                                    OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                 }
                                 sKit = C_sPrefSvuot + sToolKit ;
                                 CalculateHeadSolution( v3Appo) ;
                                 InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                // setto voto se tavola per pareti
                                 if ( C_bTableForWall) then {
                                    if ( $N2.z < 0.707) then
                                       nVotoFeature = 0 ;
                                 }
                              }
                              else {
                                 if ( NOT( C_bTableForWall)) then {
                                    bToolFind = FindTool( nRadiusFeat, nNormal, 2, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                    if ( C_bUseAngularTransmission  AND  bToolFind) then {
                                       if ( $EW < nToolDiam * 2  OR  ( C_bOptimizeRR  AND  $ER > 15)) then
                                          bRRUsed = SpecialWorkWithRR( 3, "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", $EW) ;
                                       else
                                          bRRUsed = SpecialWorkWithRR( 4, "F01", $EW) ;
                                       if ( NOT( bRRUsed)) then
                                          OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                                       nVotoFeature = 2 ;
                                       SetVotoFeatureRibasso( $N1) ;
                                    }
                                    elsif ( NotUseMillOnRecess() AND $N1.z > -0.707) then
                                       ExecuteRecessWithOtherTool( TRUE, "") ;
                                    else
                                       OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                                 }
                                 else
                                    nVotoFeature = 0 ;
                              }
                           }
                        }
                        elsif ( NotUseMillOnRecess()) then
                           ExecuteRecessWithOtherTool( TRUE, "") ;
                     }
                  }
                  elsif ( $CL == 132) then {
                    // verifico se spezzare
                     if ( ( ( nLengthFeat > 2000  OR  nLengthFeat > $L/1.25) AND ( $Pmin.y == 0  OR  $Pmax.y == $W))  OR  ( bPieceEnlarged AND nLengthFeat > 400)) then {
                        bSplit = TRUE ;
                        nRest = $L ;
                        nSplit = 0 ;
                        sSplit = "" ;
                       // se pezzo piccolo
                        if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                          // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                           nRest = MAX( 0, nLengthFeat - 400) ;
                           if ( $McLeftLoad) then {
                              if ( nRest > 600) then
                                 nSplit = nRest/2 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              sSplit = sSplit + OUTSTR( "{nRest},") ;
                           }
                           else {
                              nSplit = 400 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              if ( nRest > 600) then {
                                 nSplit = nRest/2 + 400 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ; 
                              }
                           }
                        }
                       // se sono in centro alla trave
                        elsif ( $Pmin.x > 500  AND  $Pmax.x < $L-500 AND nLengthFeat > 1500) then {
                           nAppo = FLOOR( nLengthFeat / 1500) ;
                           nAppoSplitLen = nLengthFeat / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }
                        }
                       // se sono all'inizio della trave
                        elsif ( $Pmin.x < 500  AND  $Pmax.x < $L-500  AND nLengthFeat > 400) then {
                           nSplit = 350 - $Pmin.x ;
                           if ( nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 - $Pmin.x ;
                           if ( nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;

                           nRest = nLengthFeat - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;
                           nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo  AND  nAppoSplitLen > 0) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }
                        }
                       // se sono alla fine della trave
                        elsif ( $Pmin.x > 500  AND  $Pmax.x > $L-500  AND nLengthFeat > 350) then {
                           nRest = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                           nAppo = FLOOR( nRest / 1500) ;
                           nAppoSplitLen = nRest / MAX( 1, (nAppo + 1)) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo  AND  nAppoSplitLen > 0) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - ( 700 - ( $L - $Pmax.x)) ;
                           if ( nSplit > 0  AND  nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - ( 350 - ( $L - $Pmax.x)) ;
                           if (  nSplit > 0  AND  nSplit < nLengthFeat) then
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                        elsif ( nRest <= 1400) then {
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // in tutti gli altri casi
                        else {
                           nSplit = 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;

                           nRest = nLengthFeat - nSplit - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;

                          // devo comunque spezzare la parte centrale almeno una volta
                           if ( nAppo == 0) then {
                              nAppoSplitLen = nRest / 2 ;
                              nAppo = 1 ;
                           }
                           else
                              nAppoSplitLen = nRest / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // trimmo la faccia nelle parti calcolate
                        nAppo = AddTrimmedFacesByDistance( "F01", sSplit, &sFacesCutLong) ;
                       // gestione speciale per fessura molto stretta da fare con lama
                        if ( $EW < 40  AND  $N1.z >= 0) then {
                          // verifico se riesco a fare in una passata sola.
                          // Controllo che il punto minimo sia maggiore di 40mm perchè altrimenti sono troppo vicino ai carrelli dato che il porta utensile sporge dal filo sotto
                           if ( $W - $Pmax.y > 110  AND  $Pmin.z >= 40) then {
                              nAppo = 1 ;
                              sFacesCutLong = "F01" ;
                           }
                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              sFace = GetFirstFaceInList( &sFacesCutLong) ;
                              ExecuteRecessWithOtherTool( TRUE, sFace) ;
                              g_nI = g_nI + 1 ;
                           }
                      /*     if ( $T - $Pmin.z > 120  AND  $N1.z == 0  AND  $N1.y < 0) then
                              nVotoFeature = 0 ;
                           else
                              nVotoFeature = 2 ;*/
                        }
                       // lavorazione di fianco
                        elsif ( $N1.z >= 0) then {
                          // se richiesto faccio finitura
                           if ( C_nExecuteRecessFinish == 3  AND  C_bMakeRecessWithBlade  AND  $EW > 40) then {
                              FindBlade( "F02", FALSE, TRUE, $ER, $EL, 0, _bForceComplete) ;
                              ApplyFinishCutNoBrake( "F01") ;
                           }

                           bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( bToolfind) then {
                              nVotoFeature = 3 ;
                              SetVotoFeatureRibasso( $N1) ;
                              g_nI = 1 ;
                              while ( g_nI <= nAppo) {
                                 sFace = GetFirstFaceInList( &sFacesCutLong) ;
                                 GETFACEBOX( sFace, &ptMin, &ptMax) ;
                                 nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                                // se il pezzo è stato allungato, allora in coda abbasso priorità
                                 if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                                    bIsTail = TRUE ;
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                    bIsTail = FALSE ;
                                 }
                                 else
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                 // se non riesco a lavorarlo completo
                                 if ( $ER > nToolLen) then {
                                    SETKITDEPTH( nToolLen - $ER) ;
                                    VerifyAndSetStep( C_sPrefSvuot + sToolKit, 0, FALSE) ;
                                 }
                                 CalculateHeadSolution( $N1) ;
                                 InsertKit(  C_sPrefSvuot + sToolKit, sFace, nPosXAppo, nPri) ;
                                 g_nI = g_nI + 1 ;
                              }
                           }
                        }
                        else
                           bToolFind = FALSE ;
                     }
                    // devo sempre usare la fresa piccola se corro il rischio di collidere con le morse
                     elsif ( $N1.z > 0.995  AND  ( $T - $ER) < ( C_nAltezzaMorseO + C_nSicurezza)  AND ( bShortBeam  AND ( $Pmax.y == $W AND $Pmin.y == 0))
                        AND ( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat)) then {
                        bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                        if ( bToolFind) then {
                           if ( $EW < nToolDiam * 2) then {
                              CalculateToolDir( "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", "F01") ;
                              InsertKit( C_sPrefCont + sToolKit, "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", nPosXFeat, nPri) ;
                           }
                           else {
                              CalculateHeadSolution( $N1) ;
                              InsertKit( C_sPrefSvuot + sToolKit, "F01", nPosXFeat, nPri) ;
                           }
                           nVotoFeature = 5 ;
                           SetVotoFeatureRibasso( $N1) ;
                        }
                        else
                           OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute}") ;
                     }
                     else {
                        nUseMillToWin = VerifyExecutionWindowMill() ;
                       // se ho l'utensile BlockHaus prima provo con quello
                        bMachOK = FALSE ;
                        if ( C_bUseToolBlockHaus  AND  FindTool( nOpenFeat, nNormal, 1, "F01", "F02", _TypeTMach_BH)  AND  $Np.z >= 0) then {
                           bLongFeat = FALSE ;
                           bCanUseMort = FALSE ;
                           v3Appo = CROSS( $N1, $N2) ;
                          // se passo sopra alla trave, verifico ingombro con motore
                           if ( ( ABS( v3Appo.x) != 1  AND  $ER < (( nToolDiam - C_nDiamMotore) / 2) - ( C_nSicurezza * 2))  OR  ABS( v3Appo.x) == 1) then {
                              bMachOK = TRUE ;
                              ExecuteRecessWithOtherTool( TRUE, "") ;
                           }
                           elsif ( ( ABS( v3Appo.x) != 1  AND  $ER < (( nToolDiam - C_nDiamNasoMandrino) / 2) - C_nSicurezza)  OR  ABS( v3Appo.x) == 1) then {
                              bMachOK = TRUE ;
                              ExecuteRecessWithOtherTool( TRUE, "") ;
                           }
                        }

                        if ( bMachOK  AND  NOT( bError)) then {
                           // se non c'è stato errore significa che ho lavorato con utensile tipo BH. Per il momento no nserve fare nulla
                        }
                        elsif ( nUseMillToWin > 0) then {
                           FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
                           AddCutWindow( C_vsNomeKitBlade[nBladeIndex] + C_sSuffBladeOpenWind) ;
                           AddWindowFinish() ;
                        }
                        else {
                           bToolFind = FindTool( nCheckDiamFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( ( NOT( bToolFind) AND $N1.z > -0.707)  OR  ( bMachNotComplete  AND  NotUseMillOnRecess())) then {
                              ExecuteRecessWithOtherTool( TRUE, "") ;
                           }
                           else {
                              if ( bLongFeat  AND  C_bWorkRecessAsProfil  AND  ABS( $Np.z) <= 0.15) then {
                                 bToolFind = FindTool( nRadiusFeat, nProfil, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Prof) ;
                                 if ( bToolFind) then {
                                    sKit = C_sPrefCont + sToolKit ;
                                    SetLeadInOutCont( FALSE, _Clg_Tangente, _Clg_Tangente, &sKit) ;
                                    sFaceWorked = "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
                                    SETKITDIR( _Nord) ;
                                    InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                    bExecuteProfilRecess = TRUE ;
                                    nVotoFeature = 3 ;
                                    SetVotoFeatureRibasso( $N1) ;
                                 }
                                 else
                                    bExecuteProfilRecess = FALSE ;
                              }
                              if ( NOT( bExecuteProfilRecess)) then {
                                 if ( $Np.z >= -0.01  OR  C_bHeadFromSide) then {
                                    FindTool( nCheckDiamFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                   // svuotatura su faccia principale con fresa
                                    if ( $ER < nToolLen) then
                                       FindKitRecess() ;
                                   // lavoro facce secondarie
                                    else {
                                       FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                      // contornatura con fresa "dedicata"
                                       v3Appo = CROSS( $N1, $N2) ;
                                       GETKITDATA( C_sNameFreCont, _ToolMaxMat, 0, &nAppo) ;
                                       if ( C_sNameFreCont != ""  AND  $EL < nAppo  AND  ABS(v3Appo.z) == 1  AND  bLongFeat) then {
                                          nPri = CheckPriSmallPiece( C_nPriFre - 10) ;
                                          sFaceWorked = "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
                                          SETKITDEPTH( 5) ;
                                          SETKITDIR( _Nord) ;
                                          InsertKit( C_sNameFreCont, sFaceWorked, nPosXFeat, nPri) ;
                                          nVotoFeature = 3 ;
                                          SetVotoFeatureRibasso( $N1) ;
                                       }
                                      // svuotatura ( creazione facce ausiliarie)
                                       else {
                                          nVotoFeature = 3 ;
                                          sKit = C_sPrefSvuot + sToolKit ;
                                         // svuotatura da due parti
                                          if ( v3Appo.z == 0  OR  C_bHeadFromSide) then {
                                            // faccia 1
                                             sFaceWorked = "A01" ;
                                             ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                             if ( $EL > nToolLen) then {
                                                SETKITDEPTH( MIN( nToolLen - ( $EL / 2), 5)) ;
                                                CalculateHeadSolution( v3Appo) ;
                                                InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                               // faccia 2
                                                sFaceWorked = "A02" ;
                                                v3Appo = VEC3(0, 0, 0) - v3Appo ;
                                                ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                                SETKITDEPTH( MIN( nToolLen - ( $EL / 2), 5)) ;
                                                CalculateHeadSolution( v3Appo) ;
                                                InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                                nAppo = nToolLen * 2 ;
                                                if ( v3Appo.z != 0) then
                                                   nVotoFeature = 2 ;
                                             }
                                             else {
                                                SETKITDEPTH( ( $EL / 2) + 5) ;
                                                CalculateHeadSolution( v3Appo) ;
                                                InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                             }
                                          }
                                          else {
                                            // cambio direzione della normale
                                             if ( v3Appo.z < 0) then
                                                v3Appo = VEC3(0, 0, 0) - v3Appo ;
                                             sFaceWorked = "A01" ;
                                             ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                             if ( $EL > nToolLen) then
                                                SETKITDEPTH( MIN( nToolLen - ( $EL / 2), 5)) ;
                                             else
                                                SETKITDEPTH( ( $EL / 2) + 5) ;
                                             CalculateHeadSolution( v3Appo) ;
                                             InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                             nAppo = nToolLen ;
                                          }
                                         // se non completo faccio la svuotatura su faccia principale
                                          if ( nAppo < $EL) then {
                                            // se fessura frontale( 3017) o mortasa frontale (3051)
                                             if ( $Caf == 3017 OR $Caf == 3051) then
                                                SETKITRISE( $ER) ;
                                             SETKITDEPTH( nToolLen - $ER) ;
                                             sFaceWorked = "F01" ;
                                             CalculateHeadSolution( $N1) ;
                                             InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                             OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                          }
                                          SetVotoFeatureRibasso( $N1) ;
                                       }
                                    }
                                 }
                                 else {
                                    bToolFind = FindTool( nRadiusFeat, nNormal, 2, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                    if ( C_bUseAngularTransmission  AND  bToolFind) then {
                                       if ( $EW < nToolDiam * 2  OR  ( C_bOptimizeRR  AND  $ER > 15)) then
                                          bRRUsed = SpecialWorkWithRR( 3, "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", $EW) ;
                                       else
                                          bRRUsed = SpecialWorkWithRR( 4, "F01", $EW) ;
                                       if ( NOT( bRRUsed)) then
                                          OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                                       nVotoFeature = 2 ;
                                       SetVotoFeatureRibasso( $N1) ;
                                    }
                                    elsif ( NotUseMillOnRecess() AND $N1.z > -0.707) then
                                       ExecuteRecessWithOtherTool( TRUE, "") ;
                                    else
                                       OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                                 }
                              }
                           }
                        }
                     }
                  }
                  elsif ( $CL == 142) then {
                     nUseMillToWin = VerifyExecutionWindowMill() ;
                     if ( nUseMillToWin == 0) then {
                        if ( C_sNameFreCont != "") then {
                           GETKITDATA( C_sNameFreCont, _ToolName, 1, &sAppoNameTool) ;
                           nMaxDepthFreAtt = FindMaxDepthMill( sAppoNameTool) ;
                           if ( nMaxDepthFreAtt > 0) then
                              bAppo = TRUE ;
                        }
                        else
                           bAppo = FALSE ;
                       // faccio contornatura con fresa speciale
                        if ( ( bAppo  AND  ( nDiametro < $EV AND nDiametro < $EH)  AND  ( ABS( $Np.z) == 1  OR  C_bHeadFromSide))
                           AND  C_nStrategyWindow == 3) then {
                           sKit = C_sNameFreCont ;
                           nPri = CheckPriSmallPiece( C_nPriFre - 10) ;
                           sFaceWorked = "F01,F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12" ;
                           if ( $EL > nMaxDepthFreAtt  AND  $Np.z == 0) then {
                              SETKITDEPTH( -( $EL / 2) + 5) ;
                              SETKITDIR( _Sud) ;
                              CalculateHeadSolution( VEC3( 0, 0, 0) - $Np) ;
                              InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                              SETKITDEPTH( -( $EL / 2) + 5) ;
                              SETKITDIR( _Nord) ;
                           }
                           else {
                              SETKITDEPTH( MIN( 5, nMaxDepthFreAtt - $EL)) ;
                              SETKITDIR( _Nord) ;
                           }
                           CalculateHeadSolution( $Np) ;
                           InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                           nVotoFeature = 3 ;
                           SetVotoFeatureRibasso( $Np) ;
                           bToolFind = TRUE ;
                        }
                       // faccio svuotatura o lavorazione con mortasatrice
                        else {
                           bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( NOT( bToolFind)) then {
                              if ( NotUseMillOnRecess()) then
                                 ExecuteRecessWithOtherTool( TRUE, "") ;
                           }
                           else {
                              nVotoFeature = 3 ;
                              SetVotoFeatureRibasso( $Np) ;
                              sKit = C_sPrefSvuot + sToolKit ;
                              sFaceWorked = "A01" ;
                             // lavorazione da due parti
                              if ( ( $Np.z == 0  OR  C_bHeadFromSide)  AND  $EL > nToolLen) then {
                                 ADDAUXFACE( sFaceWorked, $Np, TRUE, $EL / 2, TRUE) ;
                                 if ( $ER > nToolDiam  AND  $EW > nToolDiam) then
                                    SETKITDEPTH( MIN( 5, nToolLen - ( $EL / 2))) ;
                                 else
                                    bError = TRUE ;
                                 if ( NOT( bError)) then {
                                    CalculateHeadSolution( $Np) ;
                                    InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                    sFaceWorked = "A02" ;
                                    v3Appo = VEC3( 0, 0, 0) - $Np ;
                                    ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                    SETKITDEPTH( MIN( 5, nToolLen - ( $EL / 2))) ;
                                    CalculateHeadSolution( v3Appo) ;
                                    InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                    if ( $EL > nToolLen * 2) then
                                       OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                 }
                                 else
                                    OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sWrongDim}") ;
                              }
                             // lavorazione da un lato
                              else {
                                 v3Appo = $Np ;
                                 if ( v3Appo.z >= 0) then
                                    ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                 else {
                                    v3Appo = VEC3( 0, 0, 0) - v3Appo ;
                                    ADDAUXFACE( sFaceWorked, v3Appo, TRUE, $EL / 2, TRUE) ;
                                 }

                                 if ( $ER >= nToolDiam  AND  $EW >= nToolDiam) then {
                                    SETKITDEPTH( MIN( ($EL / 2) + OPT( ABS($Np.z) == 1 AND nLengthFeat > $L/2 , 0, 5), nToolLen - ( $EL / 2))) ;
                                 }
                                 else
                                    bError = TRUE ;

                                 if ( NOT( bError)) then {
                                    CalculateHeadSolution( v3Appo) ;
                                    InsertKit( sKit, sFaceWorked, nPosXFeat, nPri) ;
                                    if ( $EL > nToolLen) then
                                       OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                 }
                                 else
                                    OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sWrongDim}") ;
                              }
                           }
                        }
                     }
                    // sfinestratura con lavorazione di lama + mortasatrice
                     else {
                       // controllo quanto bisogna lavorare con la mortasatrice
                        bToolFind = TRUE ;
                        if ( nUseMillToWin != -1) then {
                           FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
                          // se ho trovato la lama
                           if ( nBladeIndex != 0) then {
                              AddCutWindow( C_vsNomeKitBlade[nBladeIndex] + C_sSuffBladeWind) ;

                              if ( bExistMort) then
                                 AddWindowFinish() ;
                              else
                                 OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                           }
                        }
                        else
                           OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute}") ;
                     }
                  }
                  elsif ( $CL == 151  OR  $CL == 128) then {
                    // verifico se spezzare
                     if ( ( ( nLengthFeat > 800  OR  nLengthFeat > $L/1.25) AND ( $Pmin.y == 0  OR  $Pmax.y == $W) AND $L > 1500)  OR  ( bPieceEnlarged AND nLengthFeat > 400)) then {
                        nRest = nLengthFeat ;
                        nSplit = 0 ;
                        sSplit = "" ;

                       // se pezzo piccolo
                        if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                          // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                           nRest = MAX( 0, nLengthFeat - 400) ;
                           if ( $McLeftLoad) then {
                              if ( nRest > 600) then
                                 nSplit = nRest/2 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              sSplit = sSplit + OUTSTR( "{nRest},") ;
                           }
                           else {
                              nSplit = 400 ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              if ( nRest > 600) then {
                                 nSplit = nRest/2 + 400 ;
                                 sSplit = sSplit + OUTSTR( "{nSplit},") ; 
                              }
                           }
                        }
                       // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                        elsif ( nRest <= 1400) then {
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // in tutti gli altri casi
                        else {
                           nSplit = 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;

                           nRest = nLengthFeat - nSplit - nSplit ;
                           nAppo = FLOOR( nRest / 1500) ;

                          // devo comunque spezzare la parte centrale almeno una volta
                           if ( nAppo == 0) then {
                              nAppoSplitLen = nRest / 2 ;
                              nAppo = 1 ;
                           }
                           else
                              nAppoSplitLen = nRest / (nAppo + 1) ;

                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              nSplit = nSplit + nAppoSplitLen ;
                              sSplit = sSplit + OUTSTR( "{nSplit},") ;
                              g_nI = g_nI + 1 ;
                           }

                           nSplit = nLengthFeat - 700 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                           nSplit = nLengthFeat - 350 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                       // trimmo la faccia nelle parti calcolate
                        nAppo = AddTrimmedFacesByDistance( "F01", sSplit, &sFacesCutLong) ;
                       // gestione speciale per fessura molto stretta
                        if ( $EW < 20  AND  $N1.z >= 0) then {
                           g_nI = 1 ;
                           while ( g_nI <= nAppo) {
                              sFace = GetFirstFaceInList( &sFacesCutLong) ;
                              ExecuteRecessWithOtherTool( TRUE, sFace) ;
                              g_nI = g_nI + 1 ;
                           }
                           if ( $T - $Pmin.z > 120  AND  $N1.z == 0  AND  $N1.y < 0) then
                              nVotoFeature = 0 ;
                           else
                              nVotoFeature = 2 ;
                        }
                       // lavorazione di fianco
                        elsif ( $N1.z >= 0) then {
                           bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           nVotoFeature = 3 ;
                           if ( bToolfind) then {
                              g_nI = 1 ;
                              while ( g_nI <= nAppo) {
                                 sFace = GetFirstFaceInList( &sFacesCutLong) ;
                                 GETFACEBOX( sFace, &ptMin, &ptMax) ;
                                 nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                                // se il pezzo è stato allungato, allora in coda abbasso priorità
                                 if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                                    bIsTail = TRUE ;
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                    bIsTail = FALSE ;
                                 }
                                 else
                                    nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                                // se non riesco a lavorarlo completo
                                 if ( $ER > nToolLen) then {
                                    SETKITDEPTH( nToolLen - $ER) ;
                                    VerifyAndSetStep( C_sPrefSvuot + sToolKit, 0, FALSE) ;
                                 }
                                 CalculateHeadSolution( $N1) ;
                                 InsertKit(  C_sPrefSvuot + sToolKit, sFace, nPosXAppo, nPri) ;
                                 g_nI = g_nI + 1 ;
                              }
                           }
                        }
                        else
                           bToolFind = FALSE ;
                     }
                    // caso standard
                     else {
                       // se fessura frontale( 3017) o mortasa frontale (3051)
                        if ( $Caf == 3017 OR $Caf == 3051) then
                           SETKITRISE( $ER) ;
                        if ( $N1.z >= -0.01  OR  C_bHeadFromSide) then {
                           nVotoFeature = 5 ;
                           if ( $N1.z < 0) then
                              nVotoFeature = 2 ;
                           SetVotoFeatureRibasso( $N1) ;
                           bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( NOT( bToolFind)  OR  ( NotUseMillOnRecess()  AND bMachNotComplete)) then {
                              if ( NotUseMillOnRecess()) then
                                 ExecuteRecessWithOtherTool( TRUE, "") ;
                           }
                           else {
                              if ( $EL >= nToolDiam  AND  $EW >= nToolDiam) then {
                                 sKit = C_sPrefSvuot + sToolKit ;
                                 if ( $ER > nToolLen) then {
                                    SETKITDEPTH( nToolLen - $ER) ;
                                    OutputReport( _BcfWarn, "{sAttention} {sLap}: {$NaF} {sNotComplete}") ;
                                 }
                                 CalculateHeadSolution( $N1) ;
                                 InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                              }
                              else {
                                 GETKITDATA( C_sNameFreInci, _ToolDiam, 0, &nAppo) ;
                                 if ( nAppo <= $EW  AND  nAppo != 0) then {
                                    SETKITDEPTH( 3 - $ER) ;
                                    CalculateHeadSolution( $N1) ;
                                    InsertKit( C_sNameFreInci, "F01", nPosXFeat, C_nPriEng) ;
                                 }
                                 else
                                    OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                              }
                           }
                        }
                        else {
                           bToolFind = FindTool( nRadiusFeat, nNormal, 2, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( C_bUseAngularTransmission  AND  bToolFind) then {
                              nVotoFeature = 2 ;
                              SetVotoFeatureRibasso( $N1) ;
                              if ( $EW < nToolDiam * 2  OR  ( C_bOptimizeRR  AND  $ER > 15)) then
                                 bRRUsed = SpecialWorkWithRR( 3, "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", $EW) ;
                              else
                                 bRRUsed = SpecialWorkWithRR( 4, "F01", $EW) ;
                              if ( NOT( bRRUsed)) then
                                 OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                           }
                           elsif ( NotUseMillOnRecess()) then
                              ExecuteRecessWithOtherTool( TRUE, "") ;
                           else
                              OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute} {sNotWork}") ;
                        }
                     }
                  }
                 // se fessura frontale( 3017) o mortasa frontale (3051)
                  if ( ( $Caf == 3017 OR $Caf == 3051) AND C_bActiveCutFrontFace) then {
                    // se riesco a lavorare la feature
                     if ( nVotoFeature > 0) then {
                       // verifico se c'è già un taglio
                        if ( NOT( GETCOPLANARCUT( "G01"))) then {
                           if ( GETFACEHVREXT( "G01", &nEaH, &nEaV, &nEaR)) then
                              FindKitBlade( nNormal, nEaV, nEaH, "G01", $Np, "G01", 0, TRUE) ;
                        }
                     }
                     else
                        bToolFind = FALSE ;
                  }

                 // controllo che sia stato trovato l'utensile
                  if ( NOT( bToolFind)  OR  nVotoFeature == 0) then {
                     OutputReport( _BcfWarnErr, "{sError} {sLap}: {$NaF} {sNotExecute}") ;
                  }
                 // lavoro le facce non perpendicolari alla faccia lavorata ( non con mortasatrice) se ho fatto la lavorazione principale
                  else {
                     if ( NOT( bCanUseMort)) then {
                        if ( NOT( bError)  AND  NOT( bImpossibleToWork)
                           AND  NOT( bExecuteProfilRecess) AND  NOT( bSecondFaceCubetti)) then {
                           CheckTiltedFace( sFaceWorked, TRUE) ;
                        }
                     }
                  }

                  bNotOrt = FALSE ;
                  bIsTail = FALSE ;
                  bExecuteRecess = FALSE ;
                  bExecuteProfilRecess = FALSE ;
               }
            }

            if ( C_bExecuteMeasure) then {
               if ( ( ( $Pmax.x == $L AND $McLeftLoad)  OR  ( $Pmin.x == 0  AND  NOT( $McLeftLoad))) AND (  $Pmax.y - $Pmin.y == $W  OR  $Pmax.z - $Pmin.z == $T)) then
                  nManagementFlag = _Last ;
            }

           // se ribasso con foro, lo eseguo
            if ( $CaF == 3031) then
               OutputReport( _BcfWarn, "{sAttention} {sHole}: {$NaF} {sNotComplete}") ;
         }
        // ---------- CLASSE INCASTRO -----------------------------------
        // incastro (3020), incastro giunto doppio (3080)
         elsif ( $Cl >= 200  AND  $Cl <= 299) then {
           // controllo se l'incastro è diritto
            bJointStraight = FALSE ;
            if ( $CaF == 3020) then {
               if ( NOT ISSETVAR( $N2)) then
                  $N2 = VEC3( 0,0,0) ;
               v3Appo = CROSS( $N1, $N2) ;
               if ( v3Appo.z == 0  OR  ABS( v3Appo.z) == 1) then
                  bJointStraight = TRUE ;
            }
            elsif ( $CaF == 3080) then
               bJointStraight = TRUE ;

            if ( C_bExecuteMeasure) then {
           // se taglio circa sulla testa della trave
               if ( ( $Pmax.x > ( $L - 10)  AND  $McLeftLoad)  OR  ( $Pmin.x < 10  AND  NOT( $McLeftLoad))) then
                  nManagementFlag = _Last ;
            }

           // se classe 231, la faccia principale è quella più grande. Dato che $AS è calcolato tra faccia 1 e 2 ( reali della feature),
           // in questo caso ricalcolo il valore. Infatti la faccia 1 potrebbe essere la 3 o 4 ( reale)...ecc...
            if ( $CL == 231) then {
               GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid) ;
               $AS = nAng ;
            }
            GETFACEFACEANGLW( "F01", "F02", &nAng, &nLen, &nWid, &nProj) ;
            if ( nProj > 0  OR  ABS( nProj) < ABS( C_nLimitProjToWork)  OR  $AS == 0) then {
               if ( $CL == 211) then
                  FindKitBlade( nNormal, $E1V, $E1H, "F01", $N1, "F01", 0, TRUE) ;
               elsif ( $CL == 221) then {
                  sAppo = "" ;
                  sAppo2 = "" ;
                  bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                 // se è diretto verso X più che Y, allora faccio comunque di lama
                  v3Appo = NORMALIZE( $N1 + $N2) ;
                 // lavorazione di taglio con lama
                  if ( C_nStrategyDoubleJoint == 1  OR  ABS( v3Appo.x) > ABS( v3Appo.y)  OR  ABS( v3Appo.z) > ABS( v3Appo.y)) then {
                     FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
                     if ( $ER <= nBladeMaxMat  AND  $EW <= nBladeMaxMat  AND  NOT( bShortBeam) AND  NOT( C_bTableForWall)  AND  nBladeIndex != 0) then {
                        v3Appo = CROSS( $N1, $N2) ;
                        if ( $N1.z >= 0  AND  $N2.z >= 0  AND  ABS( v3Appo.z) < 0.342) then {
                           sAppo = "F02" ;
                           sAppo2 = "F01" ;
                           nRise = $ER ;
                           nWid = $EW ;
                           SetPriorityBlade( $Np, "F01") ;
                           SETKITLEADINTANG( 1) ;
                           SETKITLEADOUTTANG( 1) ;
                           SETKITLEADINPERP( 0) ;
                           SETKITLEADOUTPERP( 0) ;
                           SETKITLEADINLENC( nRise + 30) ;
                           SETKITLEADOUTLENC( nRise + 30) ;
                           bSuffWorkPerp = TRUE ;
                           CalculateToolDir( sAppo, sAppo2) ;
                           SETKITPERPENDICULAR( TRUE) ;
                           InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
                           SETKITLEADINTANG( 1) ;
                           SETKITLEADOUTTANG( 1) ;
                           SETKITLEADINPERP( 0) ;
                           SETKITLEADOUTPERP( 0) ;
                           SETKITLEADINLENC( nWid + 30) ;
                           SETKITLEADOUTLENC( nWid + 30) ;
                           bSuffWorkPerp = TRUE ;
                           CalculateToolDir( sAppo2, sAppo) ;
                           SETKITPERPENDICULAR( TRUE) ;
                           InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo2, nPosXFeat, nPri) ;

                          // lavoro altre facce se incastro giunto doppio
                           if ( $C2 == 4  OR  $C2 == 5) then {
                              GETFACEHVREXT( "F10", &nEaH, &nEaV, &nRise) ;
                              GETFACEFACEANGLW( "F10", "F11", &nAng, &nLen, &nWid) ;
                              sAppo = "F11" ;
                              sAppo2 = "F10" ;
                              SETKITLEADINTANG( 1) ;
                              SETKITLEADOUTTANG( 1) ;
                              SETKITLEADINPERP( 0) ;
                              SETKITLEADOUTPERP( 0) ;
                              SETKITLEADINLENC( nRise + 30) ;
                              SETKITLEADOUTLENC( nRise + 30) ;
                              bSuffWorkPerp = TRUE ;
                              CalculateToolDir( sAppo2, sAppo) ;
                              SETKITPERPENDICULAR( TRUE) ;
                              InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
                              SETKITLEADINTANG( 1) ;
                              SETKITLEADOUTTANG( 1) ;
                              SETKITLEADINPERP( 0) ;
                              SETKITLEADOUTPERP( 0) ;
                              SETKITLEADINLENC( nWid + 30) ;
                              SETKITLEADOUTLENC( nWid + 30) ;
                              bSuffWorkPerp = TRUE ;
                              CalculateToolDir( sAppo, sAppo2) ;
                              SETKITPERPENDICULAR( TRUE) ;
                              InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo2, nPosXFeat, nPri) ;
                           }
                           SetVotoFeatureIncastro( _TaglioSopra) ;
                        }
                        elsif ( $N1.z >= 0 AND $N2.z >= 0) then {
                           $CL = 421 ;
                           SetPriorityBlade( $Np, "F01") ;
                           GETFACENORMAL( "F01", &v3Appo) ;
                           GETFACEHVREXT( "F01", &nEaH, &nEaV, &nRise) ;
                           bCutNoDepth = TRUE ;
                           FindKitBlade( nInvert, nEaV, nEaH, "F01", v3Appo, "F02", 0, TRUE) ;
                           GETFACENORMAL( "F02", &v3Appo) ;
                           GETFACEHVREXT( "F02", &nEaH, &nEaV, &nRise) ;
                           bCutNoDepth = TRUE ;
                           FindKitBlade( nInvert, nEaV, nEaH, "F02", v3Appo, "F01", 0, TRUE) ;
                           if ( $C2 == 4  OR  $C2 == 5) then {
                              GETFACENORMAL( "F11", &v3Appo) ;
                              GETFACEHVREXT( "F11", &nEaH, &nEaV, &nRise) ;
                              bCutNoDepth = TRUE ;
                              FindKitBlade( nInvert, nEaV, nEaH, "F11", v3Appo, "F10", 0, TRUE) ;
                              GETFACENORMAL( "F10", &v3Appo) ;
                              GETFACEHVREXT( "F10", &nEaH, &nEaV, &nRise) ;
                              bCutNoDepth = TRUE ;
                              FindKitBlade( nInvert, nEaV, nEaH, "F10", v3Appo, "F11", 0, TRUE) ;
                           }
                           SetVotoFeatureIncastro( _TaglioFianco) ;
                        }
                     }
                    // Lavorazione di contornatura e/o svuotatura
                     else {
                        VerifyExecutionCubetti( FALSE, "F01", $N1, TRUE) ;
                        if ( ( ( $N1.z >= 0 AND $N2.z >= 0) OR C_nExecuteCubetti == 5) AND bExecuteCubetti) then {
                          // tagli a cubetti
                           ExecuteCubetti( "F01", "F02") ;
                           if ( NOT( bError)) then {
                              if ( $AS > C_nMinAngle2FacesCube) then
                                 ExecuteCubetti( "F02", "F01") ;
                              if ( $C2 == 4  OR  $C2 == 5) then
                                 ExecuteCubetti( "F10", "F11") ;
                              SetVotoFeatureIncastro( _TaglioCubetti) ;
                           }
                           else
                              bExecuteCubetti = FALSE ;
                        }
                        else
                           bExecuteCubetti = FALSE ;
                        if ( NOT( bExecuteCubetti)) then {
                           bToolFind = FindTool( nOpenFeat, nProfil, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                          // se feature molto grande ( e sul fianco) lavoro con contornatura come fosse un profilo
                           if ( bLongFeat  AND  ( $EW > nToolDiam  AND  $ER > nToolDiam) AND C_bWorkRecessAsProfil  AND ( $F == 2 OR $F == 4) AND ( $N1.z == 0 AND $N2.z == 0) AND ( nToolLen > $EL)) then {
                              FindKitProf( "F01,F02") ;
                              if ( $C2 == 4  OR  $C2 == 5) then
                                 FindKitProf( "F10,F11") ;
                             // se riesco faccio una passata di pulitura sull'angolo
                              if ( C_bTableForWall) then {
                                // non posso lavorare di fianco... dovrei aggiungere uno foro sullo spigolo ( per il momento non si fa niente)
                              }
                              else {
                                 bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                                 if ( $ER < nToolLen) then {
                                    sKit = C_sPrefCont + sToolKit ;
                                    SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                                    CalculateToolDir( "F02", "F01") ;
                                    InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                                    if ( $C2 == 4  OR  $C2 == 5) then {
                                       SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                                       CalculateToolDir( "F10", "F11") ;
                                       InsertKit( sKit, "F11", nPosXFeat, nPri) ;
                                    }
                                 }
                              }
                              SetVotoFeatureIncastro( _ContFresa) ;
                           }
                           else {
                              bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                              if ( $N1.z >= 0  OR  C_bHeadFromSide) then {
                                 if ( C_nExecuteRecessFinish != 1  OR   $EW <= nToolDiam) then {
                                    bChangedFaceToWork = AddContFirstFace() ;
                                   // devo svuotare il rimanente se ho cambiato faccia di lavoro o è più grande del raggio fresa
                                   // o c'è un angolo ottuso
                                    bAppo = bChangedFaceToWork ;
                                   // se sono perpendicolari il cambio-faccia viene annullato
                                    if ( $AS > 89.5 AND $AS < 90.5) then
                                       bAppo = FALSE ;
                                    if ( NOT( bAppo)) then {
                                       if ( $EW >= ( nToolDiam - 1) OR $AS >= 91) then
                                          bAppo = TRUE ;
                                    }
                                 }
                                 else
                                    bAppo = TRUE ;
                                 ExecutePocketJoint( bAppo) ;
                                 if ( $C2 == 4  OR  $C2 == 5) then {
                                    $CL = 421 ;
                                    v3Appo = CROSS( $N1, $N2) ;
                                    GETFACENORMAL( "F11", &v3Appo2) ;
                                    GETFACEHVREXT( "F11", &nEaH, &nEaV, &nRise) ;
                                    bCutNoDepth = TRUE ;
                                    if ( v3Appo.z == 0) then
                                       FindKitBlade( nNormal, nEaV, nEaH, "F11", v3Appo2, "F10", 0, TRUE) ;
                                    else
                                       FindKitBlade( nInvert, nEaV, nEaH, "F11", v3Appo2, "F10", 0, TRUE) ;
                                    GETFACENORMAL( "F10", &v3Appo2) ;
                                    GETFACEHVREXT( "F10", &nEaH, &nEaV, &nRise) ;
                                    bCutNoDepth = TRUE ;
                                    if ( v3Appo.z == 0) then
                                       FindKitBlade( nNormal, nEaV, nEaH, "F10", v3Appo2, "F11", 0, TRUE) ;
                                    else
                                       FindKitBlade( nInvert, nEaV, nEaH, "F10", v3Appo2, "F11", 0, TRUE) ;
                                 }
                                 SetVotoFeatureIncastro( _SvuotaFresa) ;
                              }
                              else
                                 OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute}") ;
                           }
                        }
                     }   
                  }
                  else {
                     bToolFind = FindTool( nOpenFeat, nProfil, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                    // se feature molto grande ( e sul fianco) lavoro con contornatura come fosse un profilo
                     if ( bLongFeat  AND  ( $EW > nToolDiam  AND  $ER > nToolDiam) AND C_bWorkRecessAsProfil  AND ( $F == 2 OR $F == 4) AND ( $N1.z == 0 AND $N2.z == 0) AND ( nToolLen > $EL)) then {
                        FindKitProf( "F01,F02") ;
                        if ( $C2 == 4  OR  $C2 == 5) then
                           FindKitProf( "F10,F11") ;
                       // se riesco faccio una passata di pulitura sull'angolo
                        if ( C_bTableForWall) then {
                          // non posso lavorare di fianco... dovrei aggiungere uno foro sullo spigolo ( per il momento non si fa niente)
                        }
                        else {
                           bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                           if ( $ER < nToolLen) then {
                              sKit = C_sPrefCont + sToolKit ;
                              SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                              CalculateToolDir( "F02", "F01") ;
                              InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                              if ( $C2 == 4  OR  $C2 == 5) then {
                                 SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                                 CalculateToolDir( "F10", "F11") ;
                                 InsertKit( sKit, "F11", nPosXFeat, nPri) ;
                              }
                           }
                        }
                        SetVotoFeatureIncastro( _ContFresa) ;
                     }
                     else {
                        bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                        if ( $N1.z >= 0  OR  C_bHeadFromSide) then {
                           if ( C_nExecuteRecessFinish != 1  OR   $EW <= nToolDiam) then {
                              bChangedFaceToWork = AddContFirstFace() ;
                             // devo svuotare il rimanente se ho cambiato faccia di lavoro o è più grande del raggio fresa
                             // o c'è un angolo ottuso
                              bAppo = bChangedFaceToWork ;
                            // se sono perpendicolari il cambio-faccia viene annullato
                              if ( $AS > 89.5 AND $AS < 90.5) then
                                 bAppo = FALSE ;
                              if ( NOT( bAppo)) then {
                                 if ( $EW >= ( nToolDiam - 1) OR $AS >= 91) then
                                    bAppo = TRUE ;
                              }
                           }
                           else
                              bAppo = TRUE ;
                           ExecutePocketJoint( bAppo) ;
                           if ( $C2 == 4  OR  $C2 == 5) then {
                              $CL = 421 ;
                              v3Appo = CROSS( $N1, $N2) ;
                              GETFACENORMAL( "F11", &v3Appo2) ;
                              GETFACEHVREXT( "F11", &nEaH, &nEaV, &nRise) ;
                              bCutNoDepth = TRUE ;
                              if ( v3Appo.z == 0) then
                                 FindKitBlade( nNormal, nEaV, nEaH, "F11", v3Appo2, "F10", 0, TRUE) ;
                              else
                                 FindKitBlade( nInvert, nEaV, nEaH, "F11", v3Appo2, "F10", 0, TRUE) ;
                              GETFACENORMAL( "F10", &v3Appo2) ;
                              GETFACEHVREXT( "F10", &nEaH, &nEaV, &nRise) ;
                              bCutNoDepth = TRUE ;
                              if ( v3Appo.z == 0) then
                                 FindKitBlade( nNormal, nEaV, nEaH, "F10", v3Appo2, "F11", 0, TRUE) ;
                              else
                                 FindKitBlade( nInvert, nEaV, nEaH, "F10", v3Appo2, "F11", 0, TRUE) ;
                           }
                           SetVotoFeatureIncastro( _SvuotaFresa) ;
                        }
                        else
                           OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute}") ;
                     }
                  }
               }
               elsif ( $CL == 222) then {
                  SetVotoFeatureIncastro( _SvuotaFresa) ;
                  bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                  if ( $F == 3 AND $EW <= ( nToolDiam - 1)) then {
                     if ( $Np.z <= 0.75) then {
                        sKit = C_sPrefCont + sToolKit ;
                        if ( $AL > 80  AND  $AL < 100) then
                           SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                        else
                           SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                        CalculateToolDir( "F03,F04", "F01,F02") ;
                        InsertKit( sKit, "F03,F04", nPosXFeat, nPri) ;
                     }
                     else {
                        sKit = C_sPrefCont + sToolKit ;
                        if ( $AL > 80  AND  $AL < 100) then
                           SetLeadInOutCont( FALSE, _Clg_AntiScheggia, _Clg_Tangente, &sKit) ;
                        else
                           SetLeadInOutCont( FALSE, _Clg_Lineare, _Clg_Lineare, &sKit) ;
                        bSuffWorkPerp = TRUE ;
                        CalculateToolDir( "F01,F02", "F03,F04") ;
                        InsertKit( sKit, "F01,F02", nPosXFeat, nPri) ;
                     }
                  }
                  else {
                     nAppo = GetFaceArea( "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12") ;
                     nAppo2 = GetFaceArea( "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", "F01") ;
                     if ( nAppo >= nAppo2  AND  $N1.z >= 0) then {
                        CalculateHeadSolution( $N1) ;
                        InsertKit( C_sPrefSvuot + sToolKit, "F01", nPosXFeat, nPri) ;
                     }
                     else {
                        GETFACENORMAL( "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", &v3Appo) ;
                        CalculateHeadSolution( v3Appo) ;
                        InsertKit( C_sPrefSvuot + sToolKit, "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", nPosXFeat, nPri) ;
                     }
                  }
               }
               else {
                  SetVotoFeatureIncastro( _SvuotaFresa) ;
                  if ( $N1.z >= 0  OR  C_bHeadFromSide) then {
                     if ( $CL == 232) then {
                        FindTool( nCheckDiamFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                        FindKitRecess() ;
                     }
                     elsif ( $CL == 231 OR $CL == 241) then {
                        bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;

                        if ( $EL > nToolDiam  AND  $EW > nToolDiam) then {
                           CalculateHeadSolution( $N1) ;
                          // se non riesco a lavorare completo limito affondamento
                           if ( $ER > nToolLen) then {
                              SETKITDEPTH( nToolLen - $ER) ;
                              OutputReport( _BcfWarn, "{sAttention} {sNotch}: {$NaF} {sNotComplete}") ;
                           }
                           InsertKit( C_sPrefSvuot + sToolKit, "F01", nPosXFeat, nPri) ;

                           if ( $AS >= 91) then {
                              sKit = C_sPrefCont + sToolKit ;
                              SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sKit) ;
                              SETKITRISE( $ER + 5) ;
                              CalculateToolDir( "F02", "F01") ;
                              InsertKit( sKit, "F02", nPosXFeat, nPri) ;
                           }
                        }
                        else
                           OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute}") ;
                     }
                     else
                        OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute}") ;
                     if ( $CaF == 3080) then {
                        bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F05", "F06,F07,F08,F09", _TypeTMach_Rib) ;
                        GETFACENORMAL( "F05", &v3Appo) ;
                        CalculateHeadSolution( v3Appo) ;
                        InsertKit( C_sPrefSvuot + sToolKit, "F05", nPosXFeat, nPri) ;
                     }
                  }
                  else
                     OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute}") ;
               }
               bPerp = FALSE ;
            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sNotch}: {$NaF} {sNotExecute} {sErrParam}") ;
         }
        // ---------- CLASSE TAGLIO LONGITUDINALE -----------------------
        // taglio longitudinale singolo (3010), taglio longitudinale doppio (3012)
         elsif ( $CL >= 300  AND  $CL <= 399) then {
            bUseBlade = FALSE ;
            nLongCutFaceExec = 0 ;

           // su taglio doppio devo fare doppio ciclo di verifica spezzatura
            nJ = OPT( $CL >= 340, 2, 1) ;
            nContFace = 1 ;
            while( nContFace <= nJ) {
               bSplit = FALSE ;
               if ( $Caf == 3036) then {
                  if ( $P04 == 1) then
                     sSplitFace = "F01" ;
                  elsif ( $P04 == 2) then
                     sSplitFace = "F02" ;
                  elsif ( $P04 == 3) then
                     sSplitFace = "F03" ;
                  elsif ( $P04 == 4) then
                     sSplitFace = "F04" ;
               }
               else {
                  sSplitFace = OPT( nContFace == 1, "F01", "F02") ;
               }
               GETFACENORMAL( sSplitFace, &v3Appo) ;
               GETFACEBOX( sSplitFace, &ptMin, &ptMax) ;

              // controllo se devo spezzare il taglio longitudinale
               if ( bPieceEnlarged) then
                  bSplit = TRUE ;
              // se verso il basso
               elsif ( v3Appo.z < 0) then {
                 // se rivolto verso riferimenti oppure se anteriore ma con carrelli ribaltati
                  if ( v3Appo.y > 0  OR  ( v3Appo.y < 0 AND bMachOnTurnedCarr)) then
                     bSplit = TRUE ;
               }
              // se verso l'alto
               else {
                  if ( $CL > 340 AND $F == 4) then
                     bSplit = TRUE ;
                  elsif ( ptMin.z < 120) then {
                    // se rivolto verso parte frontale
                     if ( v3Appo.y < 0) then {
                       // se l'estensione virtuale della faccia è più alta delle morse verticali, non serve spezzare 
                        if ( v3Appo.z != 0) then {
                           if ( ( TAN( ASIN( ABS( v3Appo.y))) * ( $W - ptMax.y - 100)) < 60) then
                              bSplit = TRUE ;
                        }
                     }
                    // se verso parte posteriore
                     else {
                        bSplit = TRUE ;
                     }
                  }
               }

              // se devo spezzare, verifico anche che sia convesso
               if ( bSplit AND ( $AS >= 90 OR  $AS == 0)) then {
                  if ( $Caf == 1010)
                     nRest = nLengthFeat ;
                  else
                     nRest = $L ;
                  nSplit = 0 ;
                  sSplit = "" ;

                 // se pezzo piccolo
                  if ( ( bPieceEnlarged AND nLengthFeat > 400)  OR  $L < 1400) then {
                    // in testa devo tenere almeno 500mm perchè deve poter mettere il carrello riposizionandosi
                     nRest = MAX( 0, nLengthFeat - 400) ;
                     if ( $McLeftLoad) then {
                        if ( nRest > 600) then {
                           nSplit = nRest/2 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                        sSplit = sSplit + OUTSTR( "{nRest},") ;
                     }
                     else {
                        nSplit = 400 ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        if ( nRest > 600) then {
                           nSplit = nRest/2 + 400 ;
                           sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        }
                     }
                  }
                 // se la lunghezza della feature non permette di essere trimmata da entrambi i lati di 700mm, faccio un singolo taglio a 700mm
                  elsif ( nRest <= 1400) then {
                     nSplit = 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                  }
                 // in tutti gli altri casi
                  else {
                     nSplit = 350 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;

                     nRest = nLengthFeat - nSplit - nSplit ;
                     nAppo = FLOOR( nRest / 1500) ;

                    // devo comunque spezzare la parte centrale almeno una volta
                     if ( nAppo == 0) then {
                        nAppoSplitLen = nRest / 2 ;
                        nAppo = 1 ;
                     }
                     else
                        nAppoSplitLen = nRest / (nAppo + 1) ;

                     g_nI = 1 ;
                     while ( g_nI <= nAppo) {
                        nSplit = nSplit + nAppoSplitLen ;
                        sSplit = sSplit + OUTSTR( "{nSplit},") ;
                        g_nI = g_nI + 1 ;
                     }

                     nSplit = nLengthFeat - 700 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                     nSplit = nLengthFeat - 350 ;
                     sSplit = sSplit + OUTSTR( "{nSplit},") ;
                  }
                 // trimmo la faccia nelle parti calcolate
                  AddTrimmedFacesByDistance( sSplitFace, sSplit, &sFacesCutLong) ;
                 // ciclo le facce trovate
                  g_nI = 1 ;
                  while ( sFacesCutLong != "") {
                     sFace = GetFirstFaceInList( &sFacesCutLong) ;

                     if ( C_bCutLongWithBlade AND FALSE) then {
                        FindBlade( sFace, FALSE, TRUE, $E1V, $EL, 0, _bForceComplete) ;
                        sKit = C_vsNomeKitBlade[nBladeIndex] ;
                     }
                     else {
                        sKit = FindKitCutLong( $N1, sFace) ;
                       // Cambio attacchi e uscite
                        SETKITLEADINLENC( (nToolDiam / 2)) ;
                        SETKITLEADINTYPE( _LioNone) ;
                        SETKITLEADINLENC( OPT( $CaF == 3036, $EV + 10, $EW + 10)) ;
                        SETKITLEADOUTTYPE( _LioNone) ;
                        SETKITLEADOUTLENC( OPT( $CaF == 3036, $EV + 10, $EW + 10)) ;
                       // se rivolta verso il basso tolgo il perpendicolare e lavoro di spalla
                        if ( $Np.z < 0) then
                           SETKITPERPENDICULAR( FALSE) ;
                        else
                           SETKITPERPENDICULAR( TRUE) ;
                       // se il pezzo è stato allungato, allora in coda abbasso priorità
                        if ( bPieceEnlarged  AND  ( ( ptMin.x < 5 AND $McLeftLoad)  OR  ( ptMax.x > $L-5 AND NOT( $McLeftLoad)))) then {
                           bIsTail = TRUE ;
                           nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                           bIsTail = FALSE ;
                        }
                        else
                           nPri = CheckPriSmallPiece( C_nPriFre + C_vnAddPriMach[nToolIndex]) ;
                     }

                     nVotoFeature = 1 ;
                     GETFACEBOX( sFace, &ptMin, &ptMax) ;
                     nPosXAppo = ( ptMax.x + ptMin.x) / 2 ;
                     GETFACENORMAL( sFace, &v3ToolDir) ;
                    // calcolo direzione utensile
                     if ( $CL > 340  AND  $AS < 180) then
                        CalculateToolDir( sSplitFace, OPT( sSplitFace == "F01", "F02", "F01")) ;

                     CalculateHeadSolution( v3ToolDir) ;
                     SETKITFLIPSIDE( TRUE) ;
                     InsertKit( sKit, sFace, nPosXAppo, nPri) ;
                     g_nI = g_nI + 1 ;
                  }
                 // verifico che facce siano state lavorate
                  if ( nLongCutFaceExec == 0) then {
                     nLongCutFaceExec = nContFace ;
                     if ( $AS == 90) then {
                        nContFace = nContFace + 1 ;
                        nLongCutFaceExec = 12 ;
                     }
                  }
                  elsif ( nLongCutFaceExec != 0) then
                     nLongCutFaceExec = 12 ;
               }

               if ( ( nLongCutFaceExec != 12  AND $CL > 340)  OR  ( nLongCutFaceExec != 1  AND $CL < 340)) then
                  bMachNotComplete = TRUE ;
               else
                  bMachNotComplete = FALSE ;
               nContFace = nContFace + 1 ;

            }

           // se non ho completato la feature, passo per il caso standard
            if ( bMachNotComplete) {
              // setto nomi facce
               if ( $Caf == 3036) then {
                  sAppo = "F01,F02,F03,F04" ;
               }
               else {
                  sAppo = "F01" ;
                  sAppo2 = "F02" ;
               }
              // se non spezzo entro nella vecchia gestione
               if ( $Np.z > -0.984) then {
                  if ( NOT ISSETVAR( $AS)) then
                     $AS = 0 ;
                  if ( C_bCutLongWithBlade  AND  ( $AS >= 180 OR $AS == 0)   AND  $NP.z < 0.996) then {
                     bUseBlade = TRUE ;

                    // se posso usare la lama grande
                     if ( nLongCutFaceExec != 1) then {
                        if ( NOT( FindBlade( sAppo, FALSE, TRUE, $E1V, $EL, 0, _bForceComplete))) then
                           bUseBlade = FALSE ;
                     }
                     if ( ISSETVAR( $N2)  AND  nLongCutFaceExec != 2) then {
                        if ( NOT( FindBlade( sAppo2, FALSE, TRUE, $E2V, $EL, 0, _bForceComplete))) then
                           bUseBlade = FALSE ;
                     }

                  }
                  elsif ( C_bCutLongWithBlade  AND  $AS < 180  AND  $F == 3) then {
                    // se sono esattamente verticale non posso applicare lama
                     if ( $NP.z < 0.996) then
                        bUseBlade = TRUE ;
                     else
                        bUseBlade = FALSE ;
                  }

                  if ( NOT ISSETVAR( $P04)) then
                     $P04 = 0 ;
                  if ( $P04 != 0 AND ( C_nTopCut != 0  OR  C_nBottomCut != 0)) then
                     ExecuteSquadBeam( sAppo) ;
                  elsif ( bUseBlade) then {
                     FindBlade( sAppo, FALSE, TRUE, $E1V, $EL, 0, _bForceComplete) ;
                     sKit = C_vsNomeKitBlade[nBladeIndex] ;

                     nPri = CheckPriSmallPiece( 20) ;
                     if ( nLongCutFaceExec != 1) then {
                        SETKITGEOINVERT( TRUE) ;
                        ExecuteCutLongWithBlade( sKit, sAppo, nPri, $N1, FALSE) ;
                     }
                     if ( ISSETVAR( $N2)  AND  nLongCutFaceExec != 2) then {
                        SETKITGEOINVERT( TRUE) ;
                        ExecuteCutLongWithBlade( sKit, sAppo2, nPri, $N2, FALSE) ;
                     }
                  }
                  else {
                     if ( ( $CL != 349  AND  $CL != 329)  OR  C_sNameContSmusso == "") then {
                        if ( ISSETVAR( $N2)) then {
                           if ( ( $N1.z > 0  AND  $N2.z > 0) OR $F == 3) then {
                              if ( nLongCutFaceExec != 1) then {
                                 sKit = FindKitCutLong( $N1, "F01") ;
                                 AddCutLong( sKit, sAppo, sAppo2, $E1V, 1, $N1) ;
                              }
                              if ( $CL > 340  AND  nLongCutFaceExec != 2) then {
                                 sKit2 = FindKitCutLong( $N2, "F02") ;
                                 AddCutLong( sKit2, sAppo2, sAppo, $E2V, 2, $N2) ;
                              }
                              AddContOtherFace() ;
                           }
                           else {
                              bToolFind = FindTool( nOpenFeat, nNormal, 1, "F01", "F02,F03,F04,F05,F06,F07,F08,F09,F10,F11,F12", _TypeTMach_Rib) ;
                             // abbasso priorità per eseguire alla fine
                              nPri = nPri - 150 ;
                              if ( $N1.z == 0  AND  $N2.z == 0) then {
                                 if ( nLongCutFaceExec != 1) then {
                                    if ( $E1R > nToolLen) then
                                       SETKITDEPTH( nToolLen - $E1R) ;
                                    InsertKit( C_sPrefSvuot + sToolKit, sAppo, nPosXFeat, nPri) ;
                                 }
                                 if ( $AS > 90  AND  nLongCutFaceExec != 2) then {
                                    if ( $E2R > nToolLen) then
                                       SETKITDEPTH( nToolLen - $E2R) ;
                                    InsertKit( C_sPrefSvuot + sToolKit, sAppo2, nPosXFeat, nPri) ;
                                 }
                              }
                              elsif ( $N1.z == 0  AND  $N2.z > 0) then {
                                 if ( nLongCutFaceExec != 1) then {
                                    if ( $E1R > nToolLen) then
                                       SETKITDEPTH( nToolLen - $E1R) ;
                                    InsertKit( C_sPrefSvuot + sToolKit, sAppo, nPosXFeat, nPri) ;
                                 }
                                 if ( nLongCutFaceExec != 2) then {
                                    sKit = FindKitCutLong( $N2, "F02") ;
                                    AddContOtherFace() ;
                                    SETKITDIR( _Sud) ;
                                    bSuffWorkPerp = TRUE ;
                                    InsertKit( sKit, sAppo2, nPosXFeat, nPri) ;
                                 }
                              }
                              elsif ( $N2.z == 0  AND  $N1.z > 0) then {
                                 if ( nLongCutFaceExec != 2) then {
                                    if ( $E2R > nToolLen) then
                                       SETKITDEPTH( nToolLen - $E2R) ;
                                    InsertKit( C_sPrefSvuot + sToolKit, sAppo2, nPosXFeat, nPri) ;
                                 }
                                 if ( nLongCutFaceExec != 1) then {
                                    sKit = FindKitCutLong( $N1, "F01") ;
                                    AddContOtherFace() ;
                                    SETKITDIR( _Sud) ;
                                    bSuffWorkPerp = TRUE ;
                                    InsertKit( sKit, sAppo, nPosXFeat, nPri) ;
                                 }
                              }
                              elsif ( ( $F == 4  OR  $F == 2)  AND ( $N1.z < 0  OR  $N2.z < 0)) then {
                                 if ( $N1.z > 0) then {
                                    if ( nLongCutFaceExec != 1) then {
                                       sKit = FindKitCutLong( $N1, "F01") ;
                                       AddCutLong( sKit, sAppo, sAppo2, $E1V, 1, $N1) ;
                                    }
                                    if ( $AS > 90  AND  nLongCutFaceExec != 2) then {
                                       FindBlade( sAppo2, FALSE, TRUE, $E2V, $EL, 0, _bForceComplete) ;
                                       nPri = nPri + 10 ;
                                       ExecuteCutLongWithBlade( C_vsNomeKitBlade[nBladeIndex], sAppo2, nPri, $N2, TRUE) ;
                                    }
                                 }
                                 elsif ( $N2.z > 0) then {
                                    if ( nLongCutFaceExec != 2) then {
                                       sKit = FindKitCutLong( $N2, "F02") ;
                                       AddCutLong( sKit, sAppo2, sAppo, $E2V, 1, $N2) ;
                                    }
                                    if ( $AS > 90  AND  nLongCutFaceExec != 1) then {
                                       FindBlade( sAppo, FALSE, TRUE, $E1V, $EL, 0, _bForceComplete) ;
                                       nPri = nPri + 10 ;
                                       ExecuteCutLongWithBlade( C_vsNomeKitBlade[nBladeIndex], sAppo, nPri, $N1, TRUE) ;
                                    }
                                 }
                              }
                              elsif ( NOT( bMachineWithCarr)) then {
                                 if ( $CL < 340 OR ( $CL > 340  AND  $F != _BtlBottom)) then {
                                    if ( nLongCutFaceExec != 1) then {
                                       sKit = FindKitCutLong( $N1, "F01") ;
                                       AddCutLong( sKit, sAppo, sAppo2, $E1V, 1, $N1) ;
                                    }
                                    if ( $CL > 340  AND  nLongCutFaceExec != 2) then {
                                       sKit2 = FindKitCutLong( $N2, "F02") ;
                                       AddCutLong( sKit2, sAppo2, sAppo, $E2V, 2, $N2) ;
                                    }
                                    AddContOtherFace() ;
                                 }
                                 else
                                    OutputReport( _BcfWarnErr, "{sError} {sLongCut}: {$NaF} {sNotExecute}") ;
                              }
                              else
                                 OutputReport( _BcfWarnErr, "{sError} {sLongCut}: {$NaF} {sNotExecute}") ;
                           }
                        }
                        else {
                           if ( $N1.z >= 0) then {
                              sKit = FindKitCutLong( $N1, "F01") ;
                              AddCutLong( sKit, sAppo, sAppo2, $E1V, 1, $N1) ;
                              AddContOtherFace() ;
                           }
                           else {
                              if ( $E1H == $L  AND $N1.y <= 0) then {
                                 if ( FindBlade( sAppo, FALSE, TRUE, $E1V, $EL, 0, _bForceComplete))
                                    ExecuteCutLongWithBlade( C_vsNomeKitBlade[nBladeIndex], sAppo, 100, $N1, TRUE) ;
                              }
                              elsif ( nLengthFeat <= C_nLenLongFeat) then {
                                 sKit = FindKitCutLong( $N1, "F01") ;
                                 AddCutLong( sKit, sAppo, sAppo2, $E1V, 1, $N1) ;
                                 if ( $CL > 340) then {
                                    sKit2 = FindKitCutLong( $N2, "F02") ;
                                    AddCutLong( sKit2, sAppo2, sAppo, $E2V, 2, $N2) ;
                                 }
                              }
                              else
                                 OutputReport( _BcfWarnErr, "{sError} {sLongCut}: {$NaF} {sNotExecute}") ;
                           }
                        }
                     }
                     else {
                        ExecuteChamfer() ;
                     }
                  }

               }
               else
                  OutputReport( _BcfWarnErr, "{sError} {sLongCut}: {$NaF} {sNotExecute}") ;
            }

           // se più lungo di metà trave deve essere fatto per ultimo
            if ( $EL > $L / 2) then
               nManagementFlag = _Last ;

           // setto il voto
            SetVotoFeatureTaglioLong() ;
         }
        // ---------- CLASSE TAGLIO DI LAMA -----------------------------
        // taglio agli estremi (1010), taglio agli estremi con angolo (1011)
         elsif ( $Cl >= 400  AND  $Cl <= 499) then {
           // Impostazione parametri per scelta lavorazioni
           // se taglio di testa
            if ( $CL == 411  AND ( ( ( COMPARE( $Np.x, 1, 1e-6) == 0)  AND  nPosXFeat >= ( $L - 5) AND $McLeftLoad) OR
               ( ( COMPARE( $Np.x, -1, 1e-6) == 0)  AND  nPosXFeat < 5 AND NOT( $McLeftLoad)))) then
                  nManagementFlag = _Hcut ;
           // se taglio di coda
            elsif ( $CL == 411  AND ( ( ( COMPARE( $Np.x, 1, 1e-6) == 0)  AND  nPosXFeat >= ( $L - 5) AND NOT( $McLeftLoad)) OR
                  ( ( COMPARE( $Np.x, -1, 1e-6) == 0)  AND  nPosXFeat < 5 AND $McLeftLoad))) then
                  nManagementFlag = _Tcut ;
           // altri tagli
            else {
               if ( C_bExecuteMeasure) then {
                 // se taglio circa sulla testa della trave
                  if ( ( nPosXFeat > ( $L / 2)  AND  $McLeftLoad)  OR  ( nPosXFeat < ( $L / 2)  AND  NOT( $McLeftLoad))) then
                     nManagementFlag = _Last ;
                 // se taglio sulla coda della trave
                  elsif ( ( ( nPosXFeat < ( $L / 2)  AND  $McLeftLoad)  OR  ( nPosXFeat > ( $L / 2)  AND  NOT( $McLeftLoad))) AND $CL == 411) then
                     nManagementFlag = _First ;
               }
            }

           // taglio di lama singolo
            if ( $Cl == 411) then {
               FindKitBlade( nNormal, $E1V, $E1H, "F01", $N1, "F01", 0, TRUE) ;
            }
           // taglio di lama doppio concavo
            elsif ( $CL == 421 OR $CL == 422) then {
               FindBlade( "F01", FALSE, TRUE, $EW, $ER, 0, _bForceComplete) ;
              // salvo il massimo materiale della lama usata come contornatura
               v3Appo = CROSS( $N1, $N2) ;
               v3Appo = NORMALIZE( v3Appo) ;
               if ( ABS( v3Appo.z) > 0.707) then {
                  nAppo = GetFaceArea( "F01", "F02") ;
                  nAppo2 = GetFaceArea( "F02", "F01") ;
                  bBigArea1 = FALSE ;
                  if ( nAppo >= nAppo2) then
                     bBigArea1 = TRUE ;
                 // QQQ Funzione per creare taglio di sgrezzo. Non è possibile utilizzare la funzione qui sotto.
                 // ADDAUXFACE( "Z01", $Np, FALSE, 0, FALSE) ;
                  if ( $N1.z >= -0.1 AND $N2.z >= -0.1) then {
                     FindKitBlade( nInvert, OPT( bBigArea1, $E1V,$E2V), OPT( bBigArea1, $E1H,$E2H), OPT( bBigArea1, "F01","F02"), OPT( bBigArea1, $N1, $N2), OPT( bBigArea1, "F02","F01"), 0, TRUE) ;
                     nVotoFeatureTemp = nVotoFeature ;
                     if ( ( NOT( bCubettiUsed) OR $AS > 89.5 ) AND  NOT( bWindowCut)  AND  $AS > C_nMinAngle2FacesCube  AND  ( NOT( bSecondFaceCubetti) OR  $AS != 90)) then {
                        FindKitBlade( nInvert, OPT( bBigArea1, $E2V, $E1V), OPT( bBigArea1, $E2H, $E1H), OPT( bBigArea1, "F02","F01"), OPT( bBigArea1, $N2, $N1), OPT( bBigArea1, "F01","F02"), 0, TRUE) ;
                        nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
                     }
                     elsif ( $AS <= C_nMinAngle2FacesCube) then
                        OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotComplete}") ;
                  }
                  else {
                     if ( ( ( $N1.y > 0 AND $N2.y < 0 AND $S == _BtlLeft) OR ( $N1.y < 0 AND $N2.y > 0 AND $S == _BtlRight))
                        AND ( ABS( $N1.z) > 0.10 AND ABS( $N2.z) > 0.10)  AND  NOT( bCutComplete)) then {
                        FindKitBlade( nInvert, OPT( bBigArea1, $E1V,$E2V), OPT( bBigArea1, $E1H,$E2H), OPT( bBigArea1, "F01","F02"), OPT( bBigArea1, $N1, $N2), OPT( bBigArea1, "F02","F01"), 0, TRUE) ;
                        nVotoFeatureTemp = nVotoFeature ;
                        if ( ( NOT( bCubettiUsed) OR $AS > 90)  AND  NOT( bWindowCut)  AND  $AS > C_nMinAngle2FacesCube) then {
                           FindKitBlade( nInvert, OPT( bBigArea1, $E2V, $E1V), OPT( bBigArea1, $E2H, $E1H), OPT( bBigArea1, "F02","F01"), OPT( bBigArea1, $N2, $N1), OPT( bBigArea1, "F01","F02"), 0, TRUE) ;
                           nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
                        }
                        elsif ( $AS <= C_nMinAngle2FacesCube) then
                           OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotComplete}") ;
                     }
                     else
                        ExecuteCutPocket() ;
                  }
               }
               elsif ( $ER <= nBladeMaxMat  AND  $EW <= nBladeMaxMat  AND  NOT( bShortBeam) AND  NOT( C_bTableForWall) AND
                     ( $N1.z >= 0  OR  $N2.z >= 0)) then {
                  sAppo = "F01" ;
                  sAppo2 = "F02" ;
                  nRise = $ER ;
                  nWid = $EW ;
                  nPri = C_nPriBla - 100 ;
                  SetPriorityBlade( $Np, "F01") ;
                  bCutNoDepth = TRUE ;

               // committato perchè non sempre funziona
               //   sFace = "A01" ;
               //   ADDOFFSETFACE( OPT( $N1.z >= 0, "F01", "F02"), sFace, OPT( $N1.z >= 0, $E2V, $E1V)+1, FALSE) ;
               //   GETFACEHVREXT( sFace, &nEaH, &nEaV, &nEaR) ;
               //   GETFACENORMAL( sFace, &v3Appo) ;
                  FindKitBlade( nNormal, nEaV, nEaH, sFace, v3Appo, sFace, 0, TRUE) ;
                  bCutNoDepth = TRUE ;
                  if ( $N1.z >= -0.5) then {
                     if ( $N2.z > -0.173) then {
                        GETFACEFACEANGLW( "F01", "F02", &nAng, &nRise, &nWid) ;
                        SETKITLEADINTANG( 1) ;
                        SETKITLEADOUTTANG( 1) ;
                        SETKITLEADINLENC( nWid + 30) ;
                        SETKITLEADOUTLENC( nWid + 30) ;
                     }
                     else {
                        GETKITDATA( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], _ToolDiam, 0, &nAppo) ;
                        SETKITLEADINTANG( ( nAppo / 2) + 50) ;
                        SETKITLEADOUTTANG( ( nAppo / 2) + 50) ;
                        SETKITLEADINLENC( 10) ;
                        SETKITLEADOUTLENC( 10) ;
                     }
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     CalculateToolDir( sAppo, sAppo2) ;
                     SETKITPERPENDICULAR( TRUE) ;
                     if ( $AS < 90) then
                        SETKITOVERMAT( nBladeThick / TAN( $AS) + 0.1) ;
                     InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo, nPosXFeat, nPri) ;
                  }
                  else {
                     if ( $AS < 90) then
                        FindKitBlade( nNormal, $E1V, $E1H, "F01", $N1, "F02", nBladeThick / TAN( $AS) + 0.1, TRUE) ;
                     else
                        FindKitBlade( nNormal, $E1V, $E1H, "F01", $N1, "F02", 0, TRUE) ;
                  }
                  
                  if ( $N2.z >= -0.5) then {
                     if ( $N1.z > -0.173) then {
                        GETFACEFACEANGLW( "F02", "F01", &nAng, &nRise, &nWid) ;
                        SETKITLEADINTANG( 1) ;
                        SETKITLEADOUTTANG( 1) ;
                        SETKITLEADINLENC( nWid + 30) ;
                        SETKITLEADOUTLENC( nWid + 30) ;
                     }
                     else {
                        GETKITDATA( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], _ToolDiam, 0, &nAppo) ;
                        SETKITLEADINTANG( ( nAppo / 2) + 50) ;
                        SETKITLEADOUTTANG( ( nAppo / 2) + 50) ;
                        SETKITLEADINLENC( 10) ;
                        SETKITLEADOUTLENC( 10) ;
                     }
                     SETKITLEADINPERP( 0) ;
                     SETKITLEADOUTPERP( 0) ;
                     CalculateToolDir( sAppo2, sAppo) ;
                     SETKITPERPENDICULAR( TRUE) ;
                     if ( $AS < 90) then
                        SETKITOVERMAT( nBladeThick / TAN( $AS) + 0.1) ;
                     InsertKit( C_sPrefCont + C_vsNomeKitBlade[nBladeIndex], sAppo2, nPosXFeat, nPri) ;
                  }
                  else {
                     if ( $AS < 90) then 
                        FindKitBlade( nNormal, $E2V, $E2H, "F02", $N2, "F01", nBladeThick / TAN( $AS) + 0.1, TRUE) ;
                     else
                        FindKitBlade( nNormal, $E2V, $E2H, "F02", $N2, "F01", 0, TRUE) ;
                  }

                  SetVotoFeatureIncastro( _TaglioSopra) ;
               }
               elsif ( ABS( v3Appo.z) >= 0) then {
                  nAppo = GetFaceArea( "F01", "F02") ;
                  nAppo2 = GetFaceArea( "F02", "F01") ;
                  bBigArea1 = FALSE ;
                  if ( nAppo >= nAppo2) then
                     bBigArea1 = TRUE ;
                 // QQQ Funzione per creare taglio di sgrezzo. Non è possibile utilizzare la funzione qui sotto.
                 // ADDAUXFACE( "Z01", $Np, FALSE, 0, FALSE) ;
                  if ( $N1.z >= -0.1 AND $N2.z >= -0.1) then {
                     FindKitBlade( nInvert, OPT( bBigArea1, $E1V, $E2V), OPT( bBigArea1, $E1H, $E2H), OPT( bBigArea1, "F01","F02"),
                                    OPT( bBigArea1, $N1, $N2), OPT( bBigArea1, "F02","F01"), 0, TRUE) ;
                     nVotoFeatureTemp = nVotoFeature ;
                     if ( ( NOT( bCubettiUsed) OR $AS > 90)  AND  NOT( bWindowCut)  AND  $AS > C_nMinAngle2FacesCube  AND  ( NOT( bSecondFaceCubetti) OR  $AS != 90)) then {
                        FindKitBlade( nInvert, OPT( bBigArea1, $E2V, $E1V), OPT( bBigArea1, $E2H, $E1H), OPT( bBigArea1, "F02","F01"),
                                       OPT( bBigArea1, $N2, $N1), OPT( bBigArea1, "F01","F02"), 0, TRUE) ;
                        nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
                     }
                     elsif ( $AS <= C_nMinAngle2FacesCube) then
                        OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotComplete}") ;
                  }
                  else {
                     if ( ( ( ( $N1.y > 0 AND $N2.y < 0 AND $S == _BtlLeft) OR ( $N1.y < 0 AND $N2.y > 0 AND $S == _BtlRight))
                        AND ( ABS( $N1.z) > 0.10 AND ABS( $N2.z) > 0.10)  AND  NOT( bCutComplete))  OR  v3Appo.z == 0) then {
                        FindKitBlade( nInvert, OPT( bBigArea1, $E1V, $E2V), OPT( bBigArea1, $E1H, $E2H), OPT( bBigArea1, "F01","F02"),
                                       OPT( bBigArea1, $N1, $N2), OPT( bBigArea1, "F02","F01"), 0, TRUE) ;
                        nVotoFeatureTemp = nVotoFeature ;
                        if ( ( NOT( bCubettiUsed) OR $AS > 90)  AND NOT( bWindowCut)  AND  $AS > C_nMinAngle2FacesCube) then {
                           FindKitBlade( nInvert, OPT( bBigArea1, $E2V, $E1V), OPT( bBigArea1, $E2H, $E1H), OPT( bBigArea1, "F02","F01"),
                                          OPT( bBigArea1, $N2, $N1), OPT( bBigArea1, "F01","F02"), 0, TRUE) ;
                           nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
                        }
                        elsif ( $AS <= C_nMinAngle2FacesCube) then
                           OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotComplete}") ;
                     }
                     else
                        ExecuteCutPocket() ;
                  }
               }
               elsif ( $AS > 89) then
                  ExecuteCutPocket() ;
               else
                  OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotExecute}") ;
            }
           // taglio di lama doppio convesso
            elsif ( $CL == 424 OR $CL == 425 OR $CL == 426 OR $CL == 427) then {
              // Se non c'è il taglio di testa, coda o se taglio inclinato si crea una faccia che tagli tutta la trave
              // si prende la faccia con la normale in Y più vicina allo 0
               if ( ( ( $CutR == 0 AND nPosXFeat > $L / 2) OR ( $CutL == 0 AND nPosXFeat <= $L / 2)) OR ( ABS( $N1.x) < 0.985  OR  ABS( $N2.x) < 0.985)) then {
                  sFace = "A01" ;
                  if ( ( ABS( $N1.y) <= ABS( $N2.y)  AND  ABS( $N2.x) < 0.99)  OR  $N2.z < 0) then {
                     ADDOFFSETFACE( "F01", sFace, 0, FALSE) ;
                     sFace2 = "F02" ;
                  }
                  else {
                     ADDOFFSETFACE( "F02", sFace, 0, FALSE) ;
                     sFace2 = "F01" ;
                  }
               }
               else {
                  sFace = "F01" ;
                  sFace2 = "F02" ;
               }

               if ( NOT( GETCOPLANARCUT( sFace))) then {
                  GETFACEHVREXT( sFace, &nEaH, &nEaV, &nEaR) ;
                  GETFACENORMAL( sFace, &v3Appo) ;
                  FindKitBlade( nNormal, nEaV, nEaH, sFace, v3Appo, sFace2, 0, TRUE) ;
                  nVotoFeatureTemp = nVotoFeature ;
               }
               else
                  nVotoFeatureTemp = 5 ;

              // le due facce devono essere lavorate completamente a cubetti, infatti il taglio è convesso
               bSecondFaceCubetti = FALSE ;

               if ( NOT( GETCOPLANARCUT( sFace2))  AND  NOT( bCutComplete)) then {
                  GETFACEHVREXT( sFace2, &nEaH, &nEaV, &nEaR) ;
                  GETFACENORMAL( sFace2, &v3Appo) ;
                  bSecondFaceCut = TRUE ;
                  FindKitBlade( nNormal, nEaV, nEaH, sFace2, v3Appo, sFace, 0, TRUE) ;
                  nVotoFeature = MIN( nVotoFeatureTemp, nVotoFeature) ;
               }
               else
                  nVotoFeature = MIN( nVotoFeatureTemp, 5) ;

               if ( bError) then
                  nVotoFeature = 0 ;
            }
           // il caso $CL = 423 è attualmente gestito con una svuotatura su ogni faccia
            elsif ( $CL == 423) then {
               ExecuteCutPocket() ;
               nVotoFeature = 1 ;
            }
           // feature "TAGLIO DI LAMA" da eseguire con una contornatura con la fresa. NB: è diverso dalla feature "TAGLIO"
            elsif ( $CL == 418  OR  $CL == 419) then {
               bToolFind = FindTool( nRadiusFeat, nNormal, 1, "F01", "F01", _TypeTMach_Rib) ;
               if ( bToolFind) then {
                  SETKITDIR( _Nord) ;
                  sKit = C_sPrefCont + sToolKit ;
                  SetLeadInOutCont( FALSE, _Clg_Perpendicolare, _Clg_Perpendicolare, &sKit) ;
                  InsertKit( sKit, "F01", nPosXFeat, nPri) ;
                  nVotoFeature = 1 ;
               }
               else
                  OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotExecute}") ;
            }
            else
               OutputReport( _BcfWarnErr, "{sError} {sCut}: {$NaF} {sNotExecute}") ;

           // se ho trovato la lavorazione e sono sui carrelli cerco di lavorare se possibile sulla parte frontale, c'è meno ingombro che nella parte dietro
            if ( nVotoFeature > 0  AND  bMachineWithCarr) then {
               if ( $Np.y < 0  AND  NOT( bShortBeam)) then
                  nVotoFeature = nVotoFeature + 1 ;
            }
         }

        // ---------- CLASSE FORO ---------------------------------------
        // foro (3040)
         elsif ( $Cl >= 500  AND  $Cl <= 599) then {
           // resetto variabili
            bHole           = TRUE ;
            bCanDoubleHole  = FALSE ;
            sNameHole       = "H01" ;
            bError          = FALSE ;
            nAppo           = -1 ;
            nLenFirstHole   = 0 ;
            nLenSecondHole  = 0 ;
            bExecuteHole    = FALSE ;
            bSuffInvert     = FALSE ;
            sKit            = "" ;

           // foro esploso in una o più facce
            if ( $Cl == 511  OR  $CL == 512  OR  $Cl == 521  OR  $Cl == 531  OR  $Cl == 541) then
               ExecSurfHole() ;
           // se foro normale
            else
               ExecStdHole() ;

            if ( bLongHole AND $Hp > 0) then
               nManagementFlag = _First ;
            bHole = FALSE ;
         }
        // ---------- CLASSE CONTORNO LIBERO ----------------------------
        // contorno libero (3250)
         elsif ( $Cl >= 600  AND  $Cl <= 699) then {
           // caso speciale provo a fare con lavorazione di contornatura spezzando i percorsi
            if ( $CL == 619) then {
               if ( $Nf > 1  AND  $IsSheet) then
                  ExecContMultFace() ;
               else
                  $CL = 612 ;
            }
           // caso standard
            if ( $CL == 611  OR  $CL == 612) then {
               if ( $FcTy[1] == 1  AND  $Nf == 1) then
                  FindKitBlade( nNormal, $E1V, $E1H, "F01", $N1, "F01", 0, TRUE) ;
               else
                  ExecArc() ;
            }
           // caso speciale "piede di camoscio"
            elsif ( $CL == 621) then {
               bToolFind = FindTool( nRadiusFeat, nStandard, 1, "F01", "F02", _TypeTMach_Rib) ;
              // Imposto entrata ed uscita coerenti per questo tipo di lavorazione
               SETKITLEADINTYPE( _LioTangent) ;
               SETKITLEADOUTTYPE( _LioTangent) ;
               SETKITLEADINTANG( 1) ;
               SETKITLEADINPERP( -1.2) ;
               SETKITLEADINLENC( 5) ;
               SETKITLEADOUTTANG( nToolDiam) ;
               SETKITLEADOUTPERP( nToolDiam / 3) ;
               SETKITLEADOUTLENC( 5) ;
               InsertKit( C_sPrefCont + sToolKit, "F01", nPosXFeat, nPri) ;
              // faccio una svuotatura con 2 mm di sovramateriale ( distanza da bordo)
               SETKITOVERMAT( 2) ;
               InsertKit( C_sPrefSvuot + sToolKit, "F02", nPosXFeat, nPri) ;
               GETFACENORMAL( "F02", &v3Appo) ;
               if ( v3Appo.z == 1) then
                  nVotoFeature = 3 ;
               elsif ( v3Appo.z == 0) then
                  nVotoFeature = OPT( bVeryShortBeam, 0 , OPT( bShortBeam, OPT( $Pmax.x > C_nDistHeadFeat AND $Pmin.x < $L - C_nDistHeadFeat, 0, 1), 2)) ;
               else
                  nVotoFeature = 0 ;
            }
         }
        // ---------- GIUNTO A SOVRAPPOSIZIONE --------------------------
         elsif ( $CaF == 1030) then {
            ExecLapJoint() ;
         }
        // ---------- TENONE --------------------------------------------
         elsif ( $CaF == 1050  OR  $CaF == 3052) then {
           // QQQ CONTROLLO TEMPORANEO PERCHE' FEATURE HOUSE 3052 NON CALCOLA IL $DT
            if ( $CaF == 3052) then
               $Dt = MAX( MAX( $P14, $P15), ($T-$P12)/2) ;

            ExecTenon() ;
         }
        // ---------- TENONE A CODA DI RONDINE --------------------------
         elsif ( $CaF == 1055) then {
            ExecTenonCR() ;
         }
        // ---------- GIUNTO GERBER -------------------------------------
         elsif ( $CaF == 1070) then {
            ExecGerberJoint() ;
         }

        // ---------- GIUNTO A DARDO ------------------------------------
         elsif ( $CaF == 1071) then {
            ExecDartJoint() ;
         }

        // ---------- GIUNTO DOPPIO -------------------------------------
         elsif ( $CaF == 1080) then {
            ExecDoubleJoint() ;
         }
        // ---------------------- SMUSSO --------------------------------
         elsif ( $CaF == 3036) then {
            if ( $Np.z > 0.1 AND ( $T > 119 OR NOT( bLongFeat))) then {
               nVotoFeature = 2 ;
               ExecuteChamfer() ;
            }
            if ( $NF > 6) then
               OutputReport( _BcfWarn, "{sAttention} {sProfile}: {$NaF} {sNotWork}") ;
         }
        // ---------- MORTASA A CODA DI RONDINE -------------------------
         elsif ( $CaF == 3055 OR $CaF == 3056) then {
            ExecDTMortaise() ;
         }
        // ------------------- LINEA DI MARCATURA -----------------------
         elsif ( $CaF == 3060  OR  $CaF == 3061) then {
            if ( ( $F != 1  OR  C_bHeadFromSide)  AND  $Nc >= 1) then {
               if ( $F == 3) then
                  nVotoFeature = 3 ;
               else
                  nVotoFeature = 1 ;
               if ( C_sNameFreInci != "") then
                  InsertKit( C_sNameFreInci, OPT( $CaF == 3060, "C01,C02,C03,C04,C05", "C0"), nPosXFeat, C_nPriEng) ;
            }
            else
               OutputReport( _BcfWarn, "{sAttention} : {$Naf} {sNotExecute}") ;
         }
        // ------------ ARCO, CONVESSO, CONCAVO, INTESTATURA ------------
         elsif ( $CaF >= 3100  AND  $CaF <= 3104) then {
            ExecArc() ;
         }
        // ------------------- PROFILO ARCUATO --------------------------
         elsif ( $CaF == 3105) then {
            ExecBowProf() ;
         }
        // ------------------ PROFILO DI TESTA --------------------------
         elsif ( $CaF == 3106) then {
            ExecArc() ;
         }
        // OUTLINE
         elsif ( $CaF == 3350  OR  $Caf == 3352) then {
           // per il momento non si fa niente
            nVotoFeature = 1 ;
         }
        // FEATURE NON GESTITE O NON RICONOSCIUTE
         else
            OutputReport( _BcfWarn, "{sAttention} : {$Naf} {sNotExecute}") ;
      }

     // IMPOSTO PARAMETRI PER SCELTA LAVORAZIONI
      SetParamMach() ;

   ON_END_PART :
     // resetto variabili per funzioni speciali cliente
      CustomerSpecialManagement( _ON_END_PART) ;


END_AUTOMACH


AUTODISP      //----------------------------------------------------------------


   ON_SETUP :
      if ( STRCOMPARE( C_sNameSetup, "AUTO", FALSE) != 0)
         UseSetup( "%MACHPATH%\" + C_sNameSetup) ;
      else
         UseSetup( "") ;

   ON_DISP :
      bIsNormalDisp = CustomerSpecialManagement( _ON_DISP) ;

     // se ho settato una disposizione di default utilizzo quella, altrimenti faccio disposizione normale
      if ( C_sNameFileADD != "") then {
         
         if ( $DispPartNum == 1) then
            SetDispAddFile( "%MACHPATH%\" + C_sNameFileADD) ;
         else
            SetDispAddFile() ;
      }
      else {
         if ( bIsNormalDisp) then {
           // se macchina con carrelli e gestione grezzo in macchina ( Cms Suprema, Uniteam Ultra, ...)
            if ( bMachineWithCarr  AND  C_bRawMgmtInMachine) then {
               SetDispVerify( 1, FALSE) ;
               if ( $L >= C_nLenForce2Carr  AND  ( $L < C_nLenForce3Carr  OR  C_nLenForce3Carr == 0)  AND  C_nLenForce2Carr != 0) then
                  SETNUMBEROFCARRIGETOUSE( 2) ;
               elsif ( $L >= C_nLenForce3Carr  AND  ( $L < C_nLenForce4Carr OR C_nLenForce4Carr == 0)  AND  C_nLenForce3Carr != 0) then
                  SETNUMBEROFCARRIGETOUSE( 3) ;
               elsif ( $L >= C_nLenForce4Carr  AND  C_nLenForce4Carr != 0) then
                  SETNUMBEROFCARRIGETOUSE( 4) ;

              // se non setto i valori, vuol dire che faccio calcolo alla vacchia, senza tenere conto della distanza tra le lavorazioni
               if ( C_nMaxDistCenterMach != 0  AND  C_nMaxDistHeadMach != 0) then {
                 // in base allo spesore del pezzo decido lo sbalzo che posso avere in testa. Più alto è meno flette
                  if ( $L > 1500) then {
                     if ( $T > 240) then
                        SetMachiningDistance( C_nMaxDistCenterMach*1.5, C_nMaxDistHeadMach*1.5) ;
                     elsif ( $T > 139) then
                        SetMachiningDistance( C_nMaxDistCenterMach, OPT( $L<2000, C_nMaxDistHeadMach, C_nMaxDistHeadMach*1.25)) ;
                     else
                        SetMachiningDistance( C_nMaxDistCenterMach/1.25, C_nMaxDistHeadMach/1.25) ;
                  }
                 // altrimenti metto valori alti
                  else {
                     if ( $L >= C_nLenForce2Carr  AND  ( $L < C_nLenForce3Carr  OR  C_nLenForce3Carr == 0)  AND  C_nLenForce2Carr != 0) then
                        SetMachiningDistance( 400, 300) ;
                     else
                        SetMachiningDistance( $L/1.5, $L/2) ;
                  }
               }

              // non prevista disposizione MultiPezzo
               if ( $DispPartNum > 1)
                  OutputReport( _BcfErr, "Non prevista Disposizione Multipezzo") ;
              // per pezzi su tavole a ventose per ora non c'è la disposizione automatica
               if ( nBeamType == BEAM_ON_VAC) {
                  OutputReport( _BcfErr, "{sErrTabVac}") ;
               }
               elsif ( $L < C_nLenShortBeam) then {
                  SetDispClearance( C_nDistH, C_nDistZ) ;
                  SetDispDistance( OPT( $L < 2000, C_nFreeLenMin-300, C_nFreeLenMin), OPT( $L > 5000, C_nOutMax+800, C_nOutMax)) ;
                  SetCarriageDistance( C_nMaxCarr2, C_nMaxCarrM) ;
               }
               else {
                 // se pezzi non piccoli aggiungo ulteriore distanza per sicurezza ( con valori fissi)
                  SetDispClearance( C_nDistH , C_nDistZ) ;
                  SetDispDistance( OPT( $L < 2000, C_nFreeLenMin-300, C_nFreeLenMin), OPT( $L > 5000, C_nOutMax+800, C_nOutMax)) ;
                  SetCarriageDistance( C_nMaxCarr2, C_nMaxCarrM) ;
               }
              // imposto tipo pezzo di default
               SetDispDefaultPartType( _StdPart) ;
            }
           // se macchina con carrelli senza gestione grezzo in macchina (Hage Hagematic, ...)
            elsif ( bMachineWithCarr) {
               CustomerSpecialManagement( _ON_DISP) ;
            }
           // altrimenti macchina con tavola ( PMT, PM360, MultL115)
            else {
              // non prevista disposizione MultiPezzo
               if ( $DispPartNum > 1)
                  OutputReport( _BcfErr, "Non prevista Disposizione Multipezzo") ;
              // ...
               nPosXAppo = C_nPosX ;
               nPosYAppo = C_nPosY ;
              // sposto la trave in base al mio punto di riferimento
               if ( C_nStepRotateBeam == 0) then {
                  if ( C_nReferencePoint == 1) then
                     nPosXAppo = nPosXAppo + $L ;
                 // in caso C_nReferencePoint valga 2 non si fa niente
                  elsif ( C_nReferencePoint == 3) then {
                     nPosYAppo = nPosYAppo - $W ;
                     nPosXAppo = nPosXAppo + $L ;
                  }
                  elsif ( C_nReferencePoint == 4) then
                     nPosYAppo = nPosYAppo - $W ;
               }
               elsif ( C_nStepRotateBeam == 1) then {
                  if ( C_nReferencePoint == 1) then
                     nPosXAppo = nPosXAppo + $W ;
                 // in caso C_nReferencePoint valga 2 non si fa niente
                  elsif ( C_nReferencePoint == 3) then {
                     nPosXAppo = nPosXAppo + $W ;
                     nPosYAppo = nPosYAppo - $L ;
                  }
                  elsif ( C_nReferencePoint == 4) then
                     nPosYAppo = nPosYAppo - $L ;
               }
               SetTableParam( C_nStepRotateBeam, nPosXAppo, nPosYAppo) ;
              // se ci sono i riferimenti
               if ( C_bUseReference) then
                  SetRefParam( 1, C_nMaxBorderDist, C_nMinDistanceRef, C_nAuxPos) ;
              // se ci sono le ventose
               if ( C_bUseVacuum) then {
                 // se non ci sono le ventose più piccole
                  if ( C_nLimitSmallVac < 0) then {
                     SetVacParam( 0, C_nHeightSubPiece, C_nMinDistanceVac) ;
                  }
                  else {
                     if ( $W <= C_nLimitSmallVac) then
                        SetVacParam( 0, C_nHeightSubPiece, C_nMinDistanceVac) ;
                     elsif ( $W <= C_nLimitSmallVac * 2) then
                        SetVacParam( 2, C_nHeightSubPiece, C_nMinDistanceVac) ;
                     else   
                        SetVacParam( 1, C_nHeightSubPiece, C_nMinDistanceVac) ;
                  }
               }
              // abilito ottimizzazione per rapidi
               if ( C_bDrillOptimize) then
                  SETDISPOPTIMIZE( TRUE) ;
            }
         }
      }

   ON_DISP_ERR :
     // se macchina con carrelli e gestione grezzo in macchina (Cms Suprema, Uniteam Ultra, ...)
      if ( bMachineWithCarr  AND  C_bRawMgmtInMachine) then {
        // non c'è possibilità di riprovare
         $DispRepeat = FALSE ;
      }
     // se macchina con carrelli senza gestione grezzo in macchina (Hage Hagematic, ...)
      elsif ( bMachineWithCarr) then {
         CustomerSpecialManagement( _ON_DISP_ERR) ;
      }
     // altrimenti macchina con tavola ( PMT, PM360, MultL115)
      else {
        // non c'è possibilità di riprovare
         $DispRepeat = FALSE ;
      }

END_AUTODISP